---
title: "[WEB_MVC] WEB_MVC"
layout: post
subtitle: WEB_MVC
date: '2021-03-28-23:45:51 +0900'

categories: study
tags: Spring
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---


![20210329_193843](/assets/20210329_193843.png)

![20210330_005259](/assets/20210330_005259.png)

![20210330_005616](/assets/20210330_005616.png)
![20210330_005703](/assets/20210330_005703.png)

여기 classes가 사라진게 보인다.(사라진게 아니라 안 보임)

수동으로 만들어서 그럼 자동으로 만들면 안 그럼.


![20210330_010023](/assets/20210330_010023.png)

이렇게 짜는 걸 Model 1방식이라 한다.
: JSP+model 과 연동해서 짬.(나머지 부분)
jsp는 뷰, M은 model 이 2가지로만 이뤄짐.
mvc는 controller가 추가.(서블릿) 이 mvc방식을 model2방식이라고 한다.


---

![20210330_011150](/assets/20210330_011150.png)


서블릿인 이유?
server+LET(let로 끝나는 용어는 특징이 있다.)

클래스파일은 톰캣이 실행 못함.

웹에서 구동시키기 위해 서블릿의 형태로 만들어야 한다.


![20210330_012607](/assets/20210330_012607.png)

//	HttpServlet 이건 javaEE용 웹용 이 있어야
//	javase는 rt.jav였는데
//	이 클래스 안에 메서드 만들어줘야.

//	우리가 맘대로 만들면 안되고 정해진 메서드 만들어야 그건  HttpServlet 여기 정해져 있고 우리가 재정의 하는 거.
//	저 안에 서비스 메서드가 있는데 그걸 재정의 해줘야 한다.(재정의도 여러 방법이 있다.)


![20210330_013117](/assets/20210330_013117.png)

서비스는 요청,응답 객체가 무조건 받아야 한다.
protected void service(요청,응답.)


브라우저가 서버 어디서 요청왔는지 알아야 응답한다. IP의 주소와 클라이언트가 열렸던 내부 포트 정보를 알아야 클라이언트에 연결해서 클라이언트 브라우저에 출력.

클라이언트가 서버에 요청할 떄는 ip,port를 서버로 넘어가게 됨.

req,resp가 클라이언트가 서버로 요청시 요청 정보를 req,resp가 인식함.

![20210330_014203](/assets/20210330_014203.png)

클라이언트 정보에 ip와 포트정보가 있고 그걸로 연결하는데 이걸 소켓이라 한다.
소켓은 클라이언트가 다른 클라이언트 연결시 ip번호와 port번호만 알 면 연결 가능하다.
그리고 출력스트림으로PrintWriter out사용

![20210330_014428](/assets/20210330_014428.png)

브라우저로 내려주면 html태그로 해석.

![20210330_014827](/assets/20210330_014827.png)

web-inf가 url에 나타나면 안됨.


web-inf는 보안 디렉터리라 웹상에 나타나면 안된다.(브라우저에 절대 나타나면 안됨)

![20210330_014959](/assets/20210330_014959.png)

1.url 경로가 보안에 취약.
2.경로가 너무 길다.

서블릿 요청 경로를 하면 저런 문제가 있을 수 있다.

---

![20210330_015052](/assets/20210330_015052.png)


mapping해서 hs.do->/web-inf/class/Servlet 서블릿이 이 안에 있으므로 찾아가도록 매핑해주면 되지 않을까?

![20210330_015121](/assets/20210330_015121.png)


---

web.xml에 서블릿 매핑함.

![20210330_021350](/assets/20210330_021350.png)

서블릿 이름은 마음대로 써도 되는데 서블릿 이름은 맞춰줘야한다(url,실제,서블릿 매핑이 찾아가는 이름)

![20210330_021426](/assets/20210330_021426.png)

서블릿 매핑이 찾아가는 이름과 url 서블릿 이름은 같아야 한다.

![20210330_021555](/assets/20210330_021555.png)

서블릿 이름 3개로 부른다.

서블릿이 여러개면?

동일한 게 있으면 문제시킴. 그래서 클래스 이름 적어주는게 바람직하다.

![20210330_021651](/assets/20210330_021651.png)

이게 서블릿을 매핑하는 방법

![20210330_021915](/assets/20210330_021915.png)

매핑된 곳을 찾아간다.



------

서블릿을 먼저매핑해야 한다.

![20210330_022032](/assets/20210330_022032.png)

즉 이걸 실행하면 성공하면 서블릿 성공

![20210330_022058](/assets/20210330_022058.png)

이게 실제 브라우저 화면에 나타난다.
![20210330_022129](/assets/20210330_022129.png)

딱 렌더링 해서 html 형태로 잘 나온다.(최종형태)


응답은 io로 빨대.

![20210330_022313](/assets/20210330_022313.png)

초창기엔 jsp가 아니라 서블릿이 먼저 나왔고 동그라미친 클라이언트 부분이 문제가 생겨 view(jsp)부분이 나옴(유지보수에 문제가 있어서). 그래서 jsp가 나오게 되었다.


---

서블릿 실행할 떄마다 매핑하니까 상당히 번거롭다.
톰캣 버전 올라가면서는 쉽게 매핑할 수 있는 부분이 있다. 그게 어노테이션(메타데이터)


프로그램이 실행하기 전 서버에 알려주는 작업을 메타데이터.
이 어노테이션 무슨 얘기 할지 서버가 인지.

![20210330_024150](/assets/20210330_024150.png)

MVC에서 C의 역할이 클라이언트에게 요청을 제일먼저 받는 거다.

![20210330_024427](/assets/20210330_024427.png)

--------



![20210330_030001](/assets/20210330_030001.png)

![20210330_030051](/assets/20210330_030051.png)


web.xml을 체크하면 배치서술자가 생성되는 거(DD). 없어도 @해서 웹 서블릿으로 서블릿 매핑 할 수도 있지만 이후에 web.xml쓰므로 체크

![20210330_030616](/assets/20210330_030616.png)


![20210330_031514](/assets/20210330_031514.png)


두개의 공통점은 컨텍스트 등록을 했다.
웹 어플리케이션을 톰캣이 인식하도록 컨텍스트 등록


![20210330_031629](/assets/20210330_031629.png)

아까 수동을 하면 일일히 컨텍스트 패스를 등록해 줘야하지만.
다이나믹 웹 프로젝트에서


![20210330_031835](/assets/20210330_031835.png)

이건 웹은 수동으로 등록해서 인식 못하는 거고 add하면 자동으로 contextpath에 등록된다.

![20210330_032111](/assets/20210330_032111.png)

![20210330_032302](/assets/20210330_032302.png)


![20210330_032333](/assets/20210330_032333.png)

중요한건 저 contextpaht가 webcontent로 간다는 걸 알아두자.


![20210330_032631](/assets/20210330_032631.png)

reloadable 에서 true는 리스타트 안하고도 재실행이 되게 한다.(리스타트가 자동으로 되게 한다. 메모리 올리 있던 old 서블릿 내리고 새로운 데이터 올리는 과정이 리스타트) 이게 reloadable=true이면 자동으로 해준다. 근데 시간이 좀 걸려서 그냥 급하면 서버 종료하고 스타트 하는 이유가 빨리 하기 위해서.



![20210330_032930](/assets/20210330_032930.png)

path경로가 와야 우리가 만든 걸 찾아간다.

![20210330_033003](/assets/20210330_033003.png)

JSP는 페이지 단위로 만들어야 되서(view) Webcontent에 만들겠다고
Servlet과 Model은 자바로 만들어야 되서 src(package)에 만든다.


![20210330_035404](/assets/20210330_035404.png)
어떤 url이 왔을 떄 어떤 서블릿을 실행할 건지 매핑.


![20210330_035520](/assets/20210330_035520.png)
저 서블릿 매핑부분은 이름 바꿔도 실행 서블릿 위치만 가리키는거라 무슨 이름이 와도 되긴함(바꿔도 됨)


![20210330_035643](/assets/20210330_035643.png)

이부분에서 service가 체크해제되어있는데 doget, dopost는 응답 방식으로 둘중 하나 쓰거나 둘다 쓰거나 할 수 있는데 service는 상관없이 둘중 뭐 쓰거나 둘다 쓰거나  하고싶으면 check.(우린 서비스만 체크)

그러면 기본적인 서블릿이 생성된다.

그럼 수동으로 만들었을 떄와 똑같이 생성 된다.


![20210330_040624](/assets/20210330_040624.png)

서블릿에 있는  응답부 (프레젠테이션 로직) 과 모델부(비즈니스 로직)을 각각 v,m으로 나눠서 응답에 부하가 없게 한다.


---


배포하는데 war, jar 2개 방식으로 배포 가능

그리고 프로젝트를 옮기거나 이 어플로 여러명이서 할 경우에는 어떻게 해야되나 보자.

![20210330_040849](/assets/20210330_040849.png)


![20210330_040938](/assets/20210330_040938.png)


--------------
