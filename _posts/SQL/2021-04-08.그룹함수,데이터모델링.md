---
title: "[SQL] JOIN, 서브쿼리"
layout: post
subtitle: Spring
date: '2021-04-05-13:45:51 +0900'

categories: class
tags: SQL
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---


## 그룹함수

![20210408_094703](/assets/20210408_094703.png)

![20210408_095434](/assets/20210408_095434.png)

![20210408_095453](/assets/20210408_095453.png)

![20210408_095508](/assets/20210408_095508.png)

---

## Group by 절

- select 문에서 group by 를 사용할 경우 database는 쿼리 된 테이블의 행을 그룹으로 묶는다.
- database는 선택 목록의 집계함수를 각 행 그룹에 적용하고 각 그룹에 대해 단일 결과 행을 반환한다.
- group by 절을 생략하면 데이터베이스는 선택목록의 집계함수를 쿼리 된 테이블의 모든 행에 적용 가능
- select 절의 모든 요소는 group by 절의 표현식, 집계함수를 포함하는 표현식, 또는 상수만 가능.

![20210408_095701](/assets/20210408_095701.png)

![20210408_095721](/assets/20210408_095721.png)

![20210408_095745](/assets/20210408_095745.png)
![20210408_095753](/assets/20210408_095753.png)
![20210408_095802](/assets/20210408_095802.png)

--------

## Having 절

- group by 한 결과에 조건을 추가할 경우 having절을 사용
- 쿼리의 실행순서를 보면 where 절이 group by 절보다 먼저 실행되기 때문에 aggregate 조건은 having 절에 작성
- 부서별 평균 급여가 7000 이상인 부서 번호 , 평균급여

![20210408_101443](/assets/20210408_101443.png)

![20210408_101602](/assets/20210408_101602.png)

![20210408_101611](/assets/20210408_101611.png)

-------

## Set (집합 연산자)

- 모든 집합 연산자는 동일한 우선순위를 갖는다.
- select 절에 있는 column 개수와 타입이 일치해야 한다.

![20210408_102228](/assets/20210408_102228.png)

![20210408_102237](/assets/20210408_102237.png)

![20210408_102245](/assets/20210408_102245.png)

![20210408_102253](/assets/20210408_102253.png)

![20210408_102302](/assets/20210408_102302.png)

--------


## Data Modeling

- 정보화 시스템을 구축하기 위해 어떤 데이터가 존재하는지 또는 업무에 필요한 정보는 무엇인지 분석하는 방법
- 관계형 데이터베이스는 이 표의 개념을 사용해 데이터를 구성하는 방법을 사용.


![20210408_102228](/assets/20210408_102228_3j6kiti2g.png)

![20210408_102237](/assets/20210408_102237_wntbnvxcx.png)

![20210408_102245](/assets/20210408_102245_47g4k6p31.png)

![20210408_102253](/assets/20210408_102253_uabbyyxyq.png)

![20210408_102302](/assets/20210408_102302_5il127xt1.png)

![20210408_103505](/assets/20210408_103505.png)


----

### 개념적 데이터베이스 모델링

- 업무분석 단계에서 얻어진 내용을 토대로 우선 Entity를 추출하고 엔티티 내에 속성을 구성하며 엔티티간의 관계를 정의해서 ER다이어그램을 정의하는 관계

1. 사용자 부문의 처리현상을 분석한다.
2. 중요 실체와 관계를 파악하여 ERD를 작성한다.
3. 실체에 대한 상세 정의를 한다.
4. 식별자를 정의하고, 식별자 업무 규칙을 정한다.
5. 실체별로 속성을 상세화 한다.
6. 필요한 속성 및 영역을 상세 정의한다.
7. 속성에 대한 업무규칙을 정의한다.
8. 각 단계를 마친 후 사용자와 함께 모델을 검토한다.


개체를 뽑아내고 그개체에서 어떤 속성을 뽑아 내고 어떤 관계가 있는지 파악.


-------

![20210408_103834](/assets/20210408_103834.png)


---

### 개체(Entity)
- 사용자와 관계가 있는 주요 객체로서 업무 수행을 위해 데이터로 관리되어져야하는 사람, 사물, 장소 , 사건 등을 개체라고 한다.
- (영속적으로 존재하는 거) ex. 학생, 직원


### Entity 찾는 법

- 영속적으로 존재하는 것
- 새로 식별이 가능한 데이터 요소를 가짐.
- Entity 는 반드시 속성을 가져야 함.
- 명사적 표현.

### 속성(Attribute)
- 저장할 필요가 있는 실체에 대한 정보
- 개체(Entity)의 성질, 분류, 수량, 상태 , 특성 등을 나타내는 세부사항
- 개체에 포함되는 속성의 숫자는 10개 내외로 하는 것이 바람직함.
- 최종 DB 모델링 단계를 통해 테이블의 컬럼으로 활용

ex) 학생: 학번,이름,주민,주소

#### 속성의 유형
- 기초속성: 원래 갖고 있는 속성으로 현업에서 기본으로 사용되는 속성
- 추출속성: 기초속성으로부터 계산(가공)에 의해 얻어질 수 있는 속성
- 설계속성: 실제로 존재하지 않으나 시스템의 효율성을 도모하기 위해 설계자가 임의로 부여하는 속성.  


### 식별자
###### 한 개체에서 인스턴스를 유일하게 구분할 수 있는 단일 속성 또는 속성그룹

- 후보키(Candidate key) : 개체 내에서 각각의 인스턴스를 구분할 수 있는 속성으로 기본키가 될 수 있는 후보속성
- 기본키: 개체(Entity)
: 개체에서 각 인스턴스를 유일하게 식별하는데 가장 적합한 KEY.
기본키 설정시 고려할 사항으로 해당 실체를 대표할 수 있을 것.
업무적으로 활용도가 높을 것, 길이가 짧을 것 등이 있따.

- 대체키(Alternate Key)
: 후보키 중 기본키로 선정되지 않은 속성

- 복합키(COmposite Key)
: 하나의 속성으로 기본키가 될 수 없는 경우 둘 이상의 컬럼을 묶어서 식별자로 정의하는 경우

- 대리키(Surrogate Key)
: 식별자가 너무 길거나 여러개의 속성으로 구성되어 있는 경우에 인위적으로 추가할 식별자.

----------

### 관계(Relationship)

- 정의
: 두 개체간의 업무적인 연관성 또는 관련 사실
- relationship 분석
1. 각 개체간에 특정한 존재여부 결정
2. 현재의 관계 뿐 아니라 장래에 사용될 경우도 고려


![20210408_105922](/assets/20210408_105922_lye2z6k4s.png)

![20210408_105936](/assets/20210408_105936_w0u3xdnkz.png)

![20210408_110150](/assets/20210408_110150_2h2zattkc.png)

![20210408_110203](/assets/20210408_110203_byfob63vx.png)

![20210408_110210](/assets/20210408_110210_8b7a1vczu.png)

![20210408_110218](/assets/20210408_110218_9vwa97q0m.png)

![20210408_110229](/assets/20210408_110229_g3k9z4sl0.png)


---------


## 논리적 데이터베이스 모델링

- 개념적 데이터베이스 모델링 단계에서 정의된 ER-Diagram을 Mapping Rule을 적용하여 관계형 데이터베이스 이론에 입각한 스키마를 설계하는 단계와 이를 이용해 필요하면 정규화 하는 단계로 구성


### 논리적 데이터베이스 모델링

##### 기본키(Primary Key)
- 후보키 중 선택한 주 키
- 널 값을 가질 수 없다(not null)
- 동일한 값이 중복해서 저장될 수 없다.(Unique)

참조키, 이웃키(Foreign key)
- 관계를 맺는 두 엔티티에서 서로 참조하는 릴레이션의 attribute로 지정되는 키.

![20210408_112354](/assets/20210408_112354.png)

![20210408_112405](/assets/20210408_112405.png)

![20210408_112414](/assets/20210408_112414.png)

![20210408_112508](/assets/20210408_112508.png)

![20210408_112542](/assets/20210408_112542.png)

![20210408_112549](/assets/20210408_112549.png)

--------


## 정규화
- Attribute 간에 존재하는 함수적 종속성을 분석해서 관계형 스키마를 더 좋은 구조로 정제해나가는 일련의 과정
- 데이터의 중복을 제거하고 속성들을 본래의 제자리에 위치시키는 것.

![20210408_112957](/assets/20210408_112957.png)

#### 제 1 정규화
- 반복되는 그룹 속성을 제거한 뒤 기본 테이블의 기본키를 추가해 새로운 테이블을 생성하고 기존의 테이블과 1:N의 관계를 형성하는 과정
- 반복되는 그룹속성이란 같은 성격과 내용의 컬럼이 연속해서 나타나는 컬럼을 말함.


![20210408_113249](/assets/20210408_113249.png)

![20210408_113302](/assets/20210408_113302.png)



#### 제 2 정규화
- 복합키(Composite Primary Key)에 전체적으로 의존하지 않는 속성 제거
- 제 2 정규화의 대상이 되는 테이블은 키가 여러 칼럼으로 구성되 ㄴ경우
- 복합키의 일부분에 의해 종속되는 것을 부분적 함수 종속관계라 하며 이를 제거하는 작업

![20210408_113424](/assets/20210408_113424.png)

![20210408_113444](/assets/20210408_113444.png)


#### 제 3 정규화

- 기본키에 의존하지 않고 일반 컬럼에 의존하는 컬럼을 제거한다.
- 이행적 종 함수 종속관계를 갖는 컬럼을 제거하는 과정


![20210408_113632](/assets/20210408_113632.png)

![20210408_113649](/assets/20210408_113649.png)

![20210408_113716](/assets/20210408_113716.png)





----
