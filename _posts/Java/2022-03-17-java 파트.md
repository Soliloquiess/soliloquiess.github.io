---
title: "[java] java 파트"
layout: post
subtitle: Java
date: '2022-11-19 19:45:51 +0900'

categories: class
tags: Java
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---


set path=%JAVA_HOME%;%PATH%

echo %path% 쳐보면
-- 자바 패스가 들어감

윈도우는 ansi타입 기본 사용하다가
윈 10 버전하면서 포매팅을 utf-8로 변경

```

public class Main {

	public static void main(String[] args) {

		byte d;
		d=127;
		d=d+1;
		System.out.print(d);

	}
}

```
이 구문은 에러가 날까? -> ㅇㅇ
byte와 int 부분을 더하는 거라 에러가 난다.

Main.java:8: error: incompatible types: possible lossy conversion from int to byte ->

```    
    public class Main {

    	public static void main(String[] args) {

    		byte d;
    		d=12;
    		d+=1;
    		System.out.print(d);

    	}
    }
```    



이건? 정상 실행되서 13이 나온다.


```    
    public class Main {

    	public static void main(String[] args) {

    		byte d;
    		d=127;
    		d+=1;
    		System.out.print(d);

    	}
    }

```          
이건 어떨까?

-128 이 출력이 된다.

--어렵다-- 헷갈린다.


```

    public class Main {

    	public static void main(String[] args) {

    		byte d,e,f;

    		d=1;
    		e=2;
    		f=d+e;
    		System.out.print(d+"+"+e+"="+f);

    	}
    }
```

이건 뭐가 문제일까?
이건 자바 문제라기보다 시스템적인 문제이다.

2개의 바이트를 더하기 연산 처리하고 있다.
우리 시스템은 바이트를 연산하도록 세팅이 안 되어 있다.


d,e는 둘다 바이트인데 +연산이 등장하면 이걸 더하기 연산처리 하기 위해 둘다 int로 바꾸고 이걸 int인 3이 되서 int인 3이 되기 때문에 int타입의 3이 나왔는데
이 순간 f에 넣었는데 f는 byte이기 때문에 에러가 나게 되는 것.

이걸 자바에서 오토 캐스팅(자동 형변환)이라 한다.


```

    public class Main {

    	public static void main(String[] args) {

    	    double h = 3.14;
    	    System.out.print(h);
    	    float i = 3.14f;    //에러 없음.
    	    float i = 3.14;     //이건 에러 뒤에 f를 안씀. 실수가 정수(8바이트(double)가 4바이트(float))에 들어가므로 에러가 나는 것.
    	    System.out.print(i);


    	}
    }

```

float double 처럼 형 크기가 차이 나는 것도 매한가지.
3.14f였을때 에러가 없던게 3.14로 f를 제거하고 float에 넣으니까 에러가 생겼다.


전산에서는 신뢰가 가장 우선시. 틀린 답을 내놓느니 에러나는게 백만배 나음.



----

```
class Main{
	public static void main(String[] args){
    	char ch1;
    	ch1 = 'A';
    	ch1='\uac00'; 이게 들어가면 '가'로 바뀐다.
    	//ch1 = ch1+1;
		System.out.println(ch1);
	}
}
```

-----

```
class Ex06{
	public static void main(String[] args){
		//제어문-if문
		if(false){
		System.out.println("참");
		}else{
		System.out.println("거짓");

		int su = 1;
		switch(su){
			case1:
			System.out.println("1입니다");
			break;
			case2:
			System.out.println("2입니다");
			break;
			case3:
			System.out.println("3입니다");			
			break;
			default:

			System.out.println("0입니다");
			break;
	}

}
```
각 케이스들 자료형들이 일치해야 한다. 그리고 switch안에 연산을 취하면 안된다.
case 2+1: 이런식으로


----

```
@echo off
set filename = Ex08
del %filename%.class
javac %filename%.java
java %filename%
```

컴파일 하고 클래스 파일 만들고 실행


그래서 소스파일을 쓴다는 건 남들이 가져다 놓은 클래스 파일을 가져다 쓴다고 생각하면 된다.


----

클래스는 3가지 기본요소 가지는데 그게 메서드, 언어에 따라서 어떤건 메서드, 어떤건 함수 ,어떤건 두개 동시지원.

자바는 메서드만 지원

```
class Main{


	public static int func01(){
		System.out.println("func01 run...");
	 	return 1234;
	}
	public static void main(String[] args){
	       System.out.println("호출전");
	       func01();
	       System.out.println(func01());
	       int su = func01();
	       System.out.println("호출후"+su);
	   	return;
	}

}
```

```
class Main{


	public static int func01(){
		System.out.println("func01 run...");
	 	return 1234;
	}

	public static void func02(int a){
	       System.out.println("전달 받은 매개변수는 a");
	   	return;
	}


	public static void main(String[] args){
	       System.out.println("호출전");
	       func01();
	       System.out.println(func01());
	       int su = func01();
	       func02(4321);
	       System.out.println("호출후"+su);
	   	return;
	}

}

```

위 처럼 되는데 메서드끼리 이을떄, 소개 받는 인자, 넘기는 인자의 개수, 타입이 다 일치해야 한다.


--------------

#### 변수
- 기본변수
- 참조변수
	문자열
	String 변수명;
	변수명 = "문자열 ~~~";
	String msg = "";//문자열은 비어있는 문자가 존재 가능
	String 변수명 = 값;
	"값java"=msg+'java';
	"값true" = msg+true;

------

#### 연산

연산자에는 우선순위가 존재

#### 반복문
for (초기화1; 조건2; 증감 3){반복구문4;}
1->2->4->3->2->4->3->2->4

while(조건){반복구문;};

--------

초기화1;
while(조건2){반복구문4; ~~~~~~~~~~증감식3}

------



JAVA_HOME=D:\Program Files\Java\jdk-15.0.1
PATH=%JAVA_HOME%		;	~~~~~~~~~~~~

객체 쓰면 변수 타입 여러개 쓰고 여러개 정의 가능.
다른 타입일지라도 하나의 타입에 저장되서 주고받는게 가능해진다.



null과 빈 문자열은 다른거.(빈 문자열은 문자열 객체가 있는거. 널은 객체를 가리키는게 없는거. 객체적 입장에서 2개는 완전히 다른거.)

자바는 80% 이상이 C로 만들어짐.
C언어에서 포인터 개념이 어려워서 자바에서 그걸 안쓰기로 함 . 근데 비슷한 역할은 무조건 있음.
jvm 구조(클래스 스택 힙 영역)에서 주소를 가리키는거고 포인터가 주소를 가리키듯이 java에서도 해당 변수 주소를 가리키게 하는 (메모리의 주소)게 하나는 존재한다.


------

5일차.

문법은 필요에 의해 쓰는 거지 억지로 쓰면 어..음..

메인 돌다 메서드 호출하면 새 메서드 찾아서 그 메서드 호출해서 스택에 올려주고 리턴하면서 값 가져오고 넘어오면서 이 과정에서 스택에 올렸다 뺐다 하는 일이 발생하는데 이 경우는 메인에서 쭉 가는게 낫지 않나?

**문법을 쓰기 위해 코딩하면 컴퓨터는 불필요한 일을 하게 되는 일이 강하다.**

자동형변환 또 하면 느려지고 이런 식.

지금 코딩 스타일에 대해 상당 부분이 목적없이 문법 써서 코딩하다 보니


-------------


문제 낼때는 필요한 사항 및 요구사항만 만족
그 외에는 문제 안되는 한 결과 잘 나오면 일단은 ㅇㅋ

학습에선 결과보단. 어떤식으로 접근했냐를 더 우선시 함.

--------

객체지향 = 말을 코드로 했다.

문법을 억지로 써먹으려고 하지는 말자. 그렇게 하면 불필요한 객체 쓰게 됨.

그렇게 학습 진행하다 보니 객체 의미없이 찍어냄.
그러기에 메모리 비효율 적이나 시간 복잡도 비효율 적인게 되서
디자인 패턴으로 싱글톤이라는 방식도 생겨나게 된다(객체 막 찍지 못하게)

---------

메서드 = 재사용

클래스도 마찬가지로 클래스에서 다른 클래스로 접근해서 거기 있는 기능과 속성을 볼 수 있었다.

클래스 = 코드의 재사용

단 이때 재사용하는 단위가 클래스 구성 요소를 재사용 할 수 있게 된다.

그 중 하나가 메서드이다.

메서드가 다른곳에서 쓸 수 도 있지만 다른곳에서 쓰는건 클래스를 통해서 다른 곳에서 쓰는 거.

오직 하나의 클래스로 메서드 가진거는 재사용 하는거고


내가 메서드 만드는 건 필요에 따라서 코드를 재사용 하는거

코드의 재사용은 반복문으로 쓰기 불편한 코드의 재사용이 되었다는 것.

클래스를 만드는 목적? = 클래스 단위로 재사용이 필요하니까


코드의 재사용을 위해서 사용되는 거.(상속이라던지 이것도 마찬가지.)
상당수의 문법이 코드의 재사용을 위해 사용된다.

따라서 문법을 쓰기 위해서는 재사용될 코드를 먼저 도출해야 되는 것.

재사용될 코드를 가지고 이것을 반복문으로 바꿀지 클래스로 바꿀지 뭐로 할지 결정을 해야 하는 것이다.

그러한 과정이 코드 리팩토링이다.

개발자들이 계속 프로그램 짜고 끝날게 아니라 계속 수정함.

모듈화 하는 이유?
모듈로 해서 필요한 부분에서 사용이 가능하도록 표준화를 시키는 것이다.

코드를 재사용 하는 것이 중요.

첨부터 그렇게 짜면 좋은데 그렇지 못한 이유가 뭔가?-> 안되니까
어떤 개발자도 한번에 그것을 완성된 모듈화 형태로 나갈 수가 없다.(아무리 경력 좋고 해도)




------------

현존하는 언어의 포맷팅은 문자 체계가 가변이다.

유니코드는 문자코드로서 범주를 얘기한다.
특정 문자 포맷 가졌다가 그걸 유니코드라 하는게 아니다.




숙제(day05)

1. 자바 정규표현식 조사
2. 성적관리 ver 2.0

한 학생 성적을 다음을 통해 출력하시오

객체배열 나오면 String으로 생각해보자. 왜냐면 String도 객체이기 때문.

------------

day 06


클래스에 붙는 final은 더이상 상속하지 않는다.

메서드에 붙는 final은 마지막 메서드(오버라이딩을 허용하지 않겠다.)


final
class: 클래스의 상속 거부
method: 오버라이드의 거부
변수에서의 final : 상수형 변수

내부클래스는 웬만하면 잘 안쓰는데 잘 쓰는 경우가 단 한가지가 있다.
근데 잘 쓰는 경우가 한가지가 있다고 한다.

근데 해외에선 또 잘 쓴다고 하네?
아무튼 그럼.

----

day 07

숫자를 다루는 클래스는 Number클래스를 상속받고 있다.

입력값을 받았는데 정수냐 실수냐에 따라 그걸 하나의 변수가 받아야 된다면?
int와 double을 다 받을수 있는 변수는 Wrapper클래스 말고는 없다.
(Object, Number)


------

day 08

기존 스트링의 단점은 뭔가를 처리하면 새로운 객체를 계속 리턴했다.

내 자신이 바뀌는 게 아니라 조작된 새로운 객체를 리턴.

배열복사를 가장 쉽게하는건

```
public static void main(String[] args) {
        char [] arr1 = {'a','b','c','d'};
//        System.out.println(Arrays.toString(arr1));

        System.out.println(new int[] {1,2,3,4});
        System.out.println(Arrays.toString(arr1));

        char[] arr2 = Arrays.copyOf(arr1, arr1.length);
        System.out.println(Arrays.toString(arr2));
        System.out.println(arr1==arr2);

        //배열복사 가장 쉽게 하는 법
    }
```

로  Array.copyOf를 사용하면 된다.

![20220325_124215](/assets/20220325_124215.png)

객체배열은 객체 주소값 담는데 복사하면 배열은 다르지만 그 안의 element가 가리키는 객체는 동일한 객체라는 것이다.



객체배열 만들면 새로운 배열이 만들어지지만 그 깊은 복사 한 배열은 같은 객체를 가리킨다는 것.

element까지 복사 되지 않는다는 것.

만일 다른 객체를 만들고 싶으면(새로운 element만들고 싶으면)
그때는 배열을 반복문 돌려서 만들어야 된다.


system.arraycopy는 깊은 복사

-------


리팩토링은 하면 어디까지 할지 그런거도 정해야 되고 한다 치게 되면 끝도 없게 된다.


------


정보를 저장하는 단위.

이 단위를 리팩토링 해봐야 한다.

이 내부에서 하긴 껄끄러우므로 (UI까지 겹치므로) 밖으로 뺴놓고 생각해보자.

----

입력 수정 삭제가 자주 일어나는 건 링크드리스트가 더 뛰어날거고
한번 입력하고 보기만 하는 건 어레이 리스트가 성능이 더 뛰어나다.

이게 표면적인 특성이다.

-----

10.


순서가 존재하지 않음 = 중복을 허용하지 않음. set타입의 자료구조 (순서가 없는 자료구조) 근데 사실 엄밀히 말하면 순서가 없을수는 없다. 순서는 존재함.

이론적 : 순서(x), 중복(x) => 실질적 : 순서(o), 중복 (x)
중복을 허용하지 않는 자료구조.


이들은 모두 자바 util 패키지에 set 인터페이스를 상속받음. 그래서 set타입이라 불림.

순서가 있고 중복을 허용하는 것 => 리스트를 상속받음.

그리고 디폴트로 우리가 리스트에서 쓸 건 ArrayList.

리스트에서  인덱스 정순으로 하면 큐. 인덱스 역순이면 스택.

사실 원칙만 잘 지키면 어레이리스트로 모두 해결이 가능.

근데 내가 만든걸 남들이 쓸 때는 내가 원하는 대로 안 쓸수 있다. 그래서 다양한 타입들이 제공.

그리고 Set타입에서도 디폴트로 쓰는게 있는데 그게 HashSet이다.

--------

정렬을 해야만 중복값 검사  가능이때 hashSet 사용하면 숫자가 나오는데 이걸 가지고 정렬하는 게 Hash 함수다.


넣었을 떄 웬만해서 문제가 안되는 이유중 하나는 자료구조 들어갈 떄는 캐스팅 되서
objet로 들어감실제적으로 들어갈 때는 Integer객체든 뭐든 박싱되서 들어감. 

기본 자료형은 주소값만 기억해서 바로 들어갈 수 없다.
        
그럼 객체로 들어간다. 정확히 말하면 객체의 주소값을 기억하는 것.

객체 구분해내는 것 자체가 각각 메모리 주소 가지고 있을 것.
HashSet 의 경우 문제를 일으킬 경우가 거의 없다.  

객체의 주소 집어넣음. 객체가 있으니까 집어넣음.
        
------


TreeSet도 잘 쓰면 좋은데 TreeSet은 이진트리 방식으로 값을 저장한다.

TreeSet에 뭔가를 집어 넣으려면 값이 있어야 한다. 
정렬을 하기 위해서.

알아서 정렬하겠지 하면서 집어 넣으면 내 클래스 객체는 지정된 밸류가 없다.

이를 통해서 정렬을 해낼 수가 없다.
그래서 Exception 오류가 떨어진다.

----

수업만 가지고는 프로그램 능력 배양은 안됨.

항상 중요한 건 반복과 숙달. 근데 여기엔 반복과 숙달이 빠져있따.
프로그램으로 써먹는 거 또한 빠져있다.

그렇게 하기엔 수업에 할당된 비중이 작다.

이걸 우리에게 맡겨둔게 현 수업.

개별적으로 뭔가를 해보고자 하며 따라와야한다.
문법을 배우면 그걸 써본다던가.

그렇지 않으면 한번 듣고 지나가버림.



--------

테스트 과제는 오늘 까지 한거. 자료구조 set 내용.

특정시간 주고 의뢰. 데드라인 줄것.
평가 항목 및 배점 작성. 무엇보다 최우선은 데드라인 .
그리고 공개평가.


평가가 고과에 반영 된다는데. 기준 자체가 최대한 상대평가에 비교라고 한다.

그게 등수는 아니라는데 모르겠다.

국내 개발자는 자바를 할 수밖에 없는데 국내 주도 사업이기 때문(선택과 집중)

기존에 언어는 모든걸 다 하려 했음.
웹을 쳐다보지도 않았는데 스크립트 언어라 천시하는등.
근데 시대가 바뀜. 하드웨어쪽을 다른 언어가 하다가 웹으로 눈 돌린거

뭐 모르겠다 하면 ArrayList 쓰고 본다.
그러다 중복 되면 안되네 이러면  Set 쓰고.
뒤에 가서 UI할 텐데 자바의 Ui는 할 생각이 없음. 퍼포먼스 좋은게 많기 때문.

자바개발로 UI하는건 부담. 그래서 어설프게 만듬. 근데 타 언어를 쓰라고하는게 자바가 취하는 자세



---------


### 제네릭스

    public static void main(String[] args) {
        List<Integer> list = new ArrayList<Integer>();  //이렇게 쓰게 되면 Integer타입만 list에 넣을 수 있다.(제약을 주는거 이게 제네릭스)
        list.add(1111);
        list.add(2222);
        list.add("3333");

    }

처럼 list에 다른 형태가 들어갈 수 있는데 이렇게 주게 되면 Integer형태밖에 들어갈 수 없게 된다.

자바를 공부하는 또다른 방법은 깊게 공부하는 것도 좋지만 다양한 언어들에게도 영향을 줬다. 그리고 발전함에 따라 자바도 그 언어들에 의해 영향을 받음. 콜백이라든지 등등.

요구를 받아들이는게 늦었었따.

그래서 역으로 다른언어에 영향을 받는 스타일이 되버림.

그러므로 다른형태의 언어 공부하고 자바 공부하는거.
다른언어가 기본인데 자바에선 공백이 아님.

자바 공부하는 건 스펙트럼을 넓히는 게 좋다.

----

제네릭스 까지는 끝날 때 까지 계속 반복된다.
제네릭스까지는 꼭 익숙해 져야한다.

쓰레드는 스프링이나 자바에서 다 관리를 해준다.
하지만 제네릭스 까지는 꼭 알아야 하고 매우 중요한 부분이다.

---

### IO

IO의 주 타겟은 콘솔이였다.
근데 이제 우리가 다룰 대상은 File이다.