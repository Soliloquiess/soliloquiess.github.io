---
title: "[java] java 파트"
layout: post
subtitle: Java
date: '2022-11-19 19:45:51 +0900'

categories: class
tags: Java
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---


set path=%JAVA_HOME%;%PATH%

echo %path% 쳐보면
-- 자바 패스가 들어감

윈도우는 ansi타입 기본 사용하다가
윈 10 버전하면서 포매팅을 utf-8로 변경

```

public class Main {

	public static void main(String[] args) {

		byte d;
		d=127;
		d=d+1;
		System.out.print(d);

	}
}

```
이 구문은 에러가 날까? -> ㅇㅇ
byte와 int 부분을 더하는 거라 에러가 난다.

Main.java:8: error: incompatible types: possible lossy conversion from int to byte ->

```    
    public class Main {

    	public static void main(String[] args) {

    		byte d;
    		d=12;
    		d+=1;
    		System.out.print(d);

    	}
    }
```    



이건? 정상 실행되서 13이 나온다.


```    
    public class Main {

    	public static void main(String[] args) {

    		byte d;
    		d=127;
    		d+=1;
    		System.out.print(d);

    	}
    }

```          
이건 어떨까?

-128 이 출력이 된다.

--어렵다-- 헷갈린다.


```

    public class Main {

    	public static void main(String[] args) {

    		byte d,e,f;

    		d=1;
    		e=2;
    		f=d+e;
    		System.out.print(d+"+"+e+"="+f);

    	}
    }
```

이건 뭐가 문제일까?
이건 자바 문제라기보다 시스템적인 문제이다.

2개의 바이트를 더하기 연산 처리하고 있다.
우리 시스템은 바이트를 연산하도록 세팅이 안 되어 있다.


d,e는 둘다 바이트인데 +연산이 등장하면 이걸 더하기 연산처리 하기 위해 둘다 int로 바꾸고 이걸 int인 3이 되서 int인 3이 되기 때문에 int타입의 3이 나왔는데
이 순간 f에 넣었는데 f는 byte이기 때문에 에러가 나게 되는 것.

이걸 자바에서 오토 캐스팅(자동 형변환)이라 한다.


```

    public class Main {

    	public static void main(String[] args) {

    	    double h = 3.14;
    	    System.out.print(h);
    	    float i = 3.14f;    //에러 없음.
    	    float i = 3.14;     //이건 에러 뒤에 f를 안씀. 실수가 정수(8바이트(double)가 4바이트(float))에 들어가므로 에러가 나는 것.
    	    System.out.print(i);


    	}
    }

```

float double 처럼 형 크기가 차이 나는 것도 매한가지.
3.14f였을때 에러가 없던게 3.14로 f를 제거하고 float에 넣으니까 에러가 생겼다.


전산에서는 신뢰가 가장 우선시. 틀린 답을 내놓느니 에러나는게 백만배 나음.



----

```
class Main{
	public static void main(String[] args){
    	char ch1;
    	ch1 = 'A';
    	ch1='\uac00'; 이게 들어가면 '가'로 바뀐다.
    	//ch1 = ch1+1;
		System.out.println(ch1);
	}
}
```

-----

```
class Ex06{
	public static void main(String[] args){
		//제어문-if문
		if(false){
		System.out.println("참");
		}else{
		System.out.println("거짓");

		int su = 1;
		switch(su){
			case1:
			System.out.println("1입니다");
			break;
			case2:
			System.out.println("2입니다");
			break;
			case3:
			System.out.println("3입니다");			
			break;
			default:

			System.out.println("0입니다");
			break;
	}

}
```
각 케이스들 자료형들이 일치해야 한다. 그리고 switch안에 연산을 취하면 안된다.
case 2+1: 이런식으로


----

```
@echo off
set filename = Ex08
del %filename%.class
javac %filename%.java
java %filename%
```

컴파일 하고 클래스 파일 만들고 실행


그래서 소스파일을 쓴다는 건 남들이 가져다 놓은 클래스 파일을 가져다 쓴다고 생각하면 된다.


----

클래스는 3가지 기본요소 가지는데 그게 메서드, 언어에 따라서 어떤건 메서드, 어떤건 함수 ,어떤건 두개 동시지원.

자바는 메서드만 지원

```
class Main{


	public static int func01(){
		System.out.println("func01 run...");
	 	return 1234;
	}
	public static void main(String[] args){
	       System.out.println("호출전");
	       func01();
	       System.out.println(func01());
	       int su = func01();
	       System.out.println("호출후"+su);
	   	return;
	}

}
```

```
class Main{


	public static int func01(){
		System.out.println("func01 run...");
	 	return 1234;
	}

	public static void func02(int a){
	       System.out.println("전달 받은 매개변수는 a");
	   	return;
	}


	public static void main(String[] args){
	       System.out.println("호출전");
	       func01();
	       System.out.println(func01());
	       int su = func01();
	       func02(4321);
	       System.out.println("호출후"+su);
	   	return;
	}

}

```

위 처럼 되는데 메서드끼리 이을떄, 소개 받는 인자, 넘기는 인자의 개수, 타입이 다 일치해야 한다.


--------------

#### 변수
- 기본변수
- 참조변수
	문자열
	String 변수명;
	변수명 = "문자열 ~~~";
	String msg = "";//문자열은 비어있는 문자가 존재 가능
	String 변수명 = 값;
	"값java"=msg+'java';
	"값true" = msg+true;

------

#### 연산

연산자에는 우선순위가 존재

#### 반복문
for (초기화1; 조건2; 증감 3){반복구문4;}
1->2->4->3->2->4->3->2->4

while(조건){반복구문;};

--------

초기화1;
while(조건2){반복구문4; ~~~~~~~~~~증감식3}

------



JAVA_HOME=D:\Program Files\Java\jdk-15.0.1
PATH=%JAVA_HOME%		;	~~~~~~~~~~~~

객체 쓰면 변수 타입 여러개 쓰고 여러개 정의 가능.
다른 타입일지라도 하나의 타입에 저장되서 주고받는게 가능해진다.



null과 빈 문자열은 다른거.(빈 문자열은 문자열 객체가 있는거. 널은 객체를 가리키는게 없는거. 객체적 입장에서 2개는 완전히 다른거.)

자바는 80% 이상이 C로 만들어짐.
C언어에서 포인터 개념이 어려워서 자바에서 그걸 안쓰기로 함 . 근데 비슷한 역할은 무조건 있음.
jvm 구조(클래스 스택 힙 영역)에서 주소를 가리키는거고 포인터가 주소를 가리키듯이 java에서도 해당 변수 주소를 가리키게 하는 (메모리의 주소)게 하나는 존재한다.


------

5일차.

문법은 필요에 의해 쓰는 거지 억지로 쓰면 어..음..

메인 돌다 메서드 호출하면 새 메서드 찾아서 그 메서드 호출해서 스택에 올려주고 리턴하면서 값 가져오고 넘어오면서 이 과정에서 스택에 올렸다 뺐다 하는 일이 발생하는데 이 경우는 메인에서 쭉 가는게 낫지 않나?

**문법을 쓰기 위해 코딩하면 컴퓨터는 불필요한 일을 하게 되는 일이 강하다.**

자동형변환 또 하면 느려지고 이런 식.

지금 코딩 스타일에 대해 상당 부분이 목적없이 문법 써서 코딩하다 보니


-------------


문제 낼때는 필요한 사항 및 요구사항만 만족
그 외에는 문제 안되는 한 결과 잘 나오면 일단은 ㅇㅋ

학습에선 결과보단. 어떤식으로 접근했냐를 더 우선시 함.

--------

객체지향 = 말을 코드로 했다.

문법을 억지로 써먹으려고 하지는 말자. 그렇게 하면 불필요한 객체 쓰게 됨.

그렇게 학습 진행하다 보니 객체 의미없이 찍어냄.
그러기에 메모리 비효율 적이나 시간 복잡도 비효율 적인게 되서
디자인 패턴으로 싱글톤이라는 방식도 생겨나게 된다(객체 막 찍지 못하게)

---------

메서드 = 재사용

클래스도 마찬가지로 클래스에서 다른 클래스로 접근해서 거기 있는 기능과 속성을 볼 수 있었다.

클래스 = 코드의 재사용

단 이때 재사용하는 단위가 클래스 구성 요소를 재사용 할 수 있게 된다.

그 중 하나가 메서드이다.

메서드가 다른곳에서 쓸 수 도 있지만 다른곳에서 쓰는건 클래스를 통해서 다른 곳에서 쓰는 거.

오직 하나의 클래스로 메서드 가진거는 재사용 하는거고


내가 메서드 만드는 건 필요에 따라서 코드를 재사용 하는거

코드의 재사용은 반복문으로 쓰기 불편한 코드의 재사용이 되었다는 것.

클래스를 만드는 목적? = 클래스 단위로 재사용이 필요하니까


코드의 재사용을 위해서 사용되는 거.(상속이라던지 이것도 마찬가지.)
상당수의 문법이 코드의 재사용을 위해 사용된다.

따라서 문법을 쓰기 위해서는 재사용될 코드를 먼저 도출해야 되는 것.

재사용될 코드를 가지고 이것을 반복문으로 바꿀지 클래스로 바꿀지 뭐로 할지 결정을 해야 하는 것이다.

그러한 과정이 코드 리팩토링이다.

개발자들이 계속 프로그램 짜고 끝날게 아니라 계속 수정함.

모듈화 하는 이유?
모듈로 해서 필요한 부분에서 사용이 가능하도록 표준화를 시키는 것이다.

코드를 재사용 하는 것이 중요.

첨부터 그렇게 짜면 좋은데 그렇지 못한 이유가 뭔가?-> 안되니까
어떤 개발자도 한번에 그것을 완성된 모듈화 형태로 나갈 수가 없다.(아무리 경력 좋고 해도)




------------

현존하는 언어의 포맷팅은 문자 체계가 가변이다.

유니코드는 문자코드로서 범주를 얘기한다.
특정 문자 포맷 가졌다가 그걸 유니코드라 하는게 아니다.




숙제(day05)

1. 자바 정규표현식 조사
2. 성적관리 ver 2.0

한 학생 성적을 다음을 통해 출력하시오

객체배열 나오면 String으로 생각해보자. 왜냐면 String도 객체이기 때문.

------------

day 06


클래스에 붙는 final은 더이상 상속하지 않는다.

메서드에 붙는 final은 마지막 메서드(오버라이딩을 허용하지 않겠다.)


final
class: 클래스의 상속 거부
method: 오버라이드의 거부
변수에서의 final : 상수형 변수

내부클래스는 웬만하면 잘 안쓰는데 잘 쓰는 경우가 단 한가지가 있다.
근데 잘 쓰는 경우가 한가지가 있다고 한다.

근데 해외에선 또 잘 쓴다고 하네?
아무튼 그럼.

----

day 07

숫자를 다루는 클래스는 Number클래스를 상속받고 있다.

입력값을 받았는데 정수냐 실수냐에 따라 그걸 하나의 변수가 받아야 된다면?
int와 double을 다 받을수 있는 변수는 Wrapper클래스 말고는 없다.
(Object, Number)


------

day 08

기존 스트링의 단점은 뭔가를 처리하면 새로운 객체를 계속 리턴했다.

내 자신이 바뀌는 게 아니라 조작된 새로운 객체를 리턴.

배열복사를 가장 쉽게하는건

```
public static void main(String[] args) {
        char [] arr1 = {'a','b','c','d'};
//        System.out.println(Arrays.toString(arr1));

        System.out.println(new int[] {1,2,3,4});
        System.out.println(Arrays.toString(arr1));

        char[] arr2 = Arrays.copyOf(arr1, arr1.length);
        System.out.println(Arrays.toString(arr2));
        System.out.println(arr1==arr2);

        //배열복사 가장 쉽게 하는 법
    }
```

로  Array.copyOf를 사용하면 된다.

![20220325_124215](/assets/20220325_124215.png)

객체배열은 객체 주소값 담는데 복사하면 배열은 다르지만 그 안의 element가 가리키는 객체는 동일한 객체라는 것이다.



객체배열 만들면 새로운 배열이 만들어지지만 그 깊은 복사 한 배열은 같은 객체를 가리킨다는 것.

element까지 복사 되지 않는다는 것.

만일 다른 객체를 만들고 싶으면(새로운 element만들고 싶으면)
그때는 배열을 반복문 돌려서 만들어야 된다.


system.arraycopy는 깊은 복사

-------


리팩토링은 하면 어디까지 할지 그런거도 정해야 되고 한다 치게 되면 끝도 없게 된다.


------


정보를 저장하는 단위.

이 단위를 리팩토링 해봐야 한다.

이 내부에서 하긴 껄끄러우므로 (UI까지 겹치므로) 밖으로 뺴놓고 생각해보자.

----

입력 수정 삭제가 자주 일어나는 건 링크드리스트가 더 뛰어날거고
한번 입력하고 보기만 하는 건 어레이 리스트가 성능이 더 뛰어나다.

이게 표면적인 특성이다.

-----

10.


순서가 존재하지 않음 = 중복을 허용하지 않음. set타입의 자료구조 (순서가 없는 자료구조) 근데 사실 엄밀히 말하면 순서가 없을수는 없다. 순서는 존재함.

이론적 : 순서(x), 중복(x) => 실질적 : 순서(o), 중복 (x)
중복을 허용하지 않는 자료구조.


이들은 모두 자바 util 패키지에 set 인터페이스를 상속받음. 그래서 set타입이라 불림.

순서가 있고 중복을 허용하는 것 => 리스트를 상속받음.

그리고 디폴트로 우리가 리스트에서 쓸 건 ArrayList.

리스트에서  인덱스 정순으로 하면 큐. 인덱스 역순이면 스택.

사실 원칙만 잘 지키면 어레이리스트로 모두 해결이 가능.

근데 내가 만든걸 남들이 쓸 때는 내가 원하는 대로 안 쓸수 있다. 그래서 다양한 타입들이 제공.

그리고 Set타입에서도 디폴트로 쓰는게 있는데 그게 HashSet이다.

--------

정렬을 해야만 중복값 검사  가능이때 hashSet 사용하면 숫자가 나오는데 이걸 가지고 정렬하는 게 Hash 함수다.


넣었을 떄 웬만해서 문제가 안되는 이유중 하나는 자료구조 들어갈 떄는 캐스팅 되서
objet로 들어감실제적으로 들어갈 때는 Integer객체든 뭐든 박싱되서 들어감.

기본 자료형은 주소값만 기억해서 바로 들어갈 수 없다.

그럼 객체로 들어간다. 정확히 말하면 객체의 주소값을 기억하는 것.

객체 구분해내는 것 자체가 각각 메모리 주소 가지고 있을 것.
HashSet 의 경우 문제를 일으킬 경우가 거의 없다.  

객체의 주소 집어넣음. 객체가 있으니까 집어넣음.

------


TreeSet도 잘 쓰면 좋은데 TreeSet은 이진트리 방식으로 값을 저장한다.

TreeSet에 뭔가를 집어 넣으려면 값이 있어야 한다.
정렬을 하기 위해서.

알아서 정렬하겠지 하면서 집어 넣으면 내 클래스 객체는 지정된 밸류가 없다.

이를 통해서 정렬을 해낼 수가 없다.
그래서 Exception 오류가 떨어진다.

----

수업만 가지고는 프로그램 능력 배양은 안됨.

항상 중요한 건 반복과 숙달. 근데 여기엔 반복과 숙달이 빠져있따.
프로그램으로 써먹는 거 또한 빠져있다.

그렇게 하기엔 수업에 할당된 비중이 작다.

이걸 우리에게 맡겨둔게 현 수업.

개별적으로 뭔가를 해보고자 하며 따라와야한다.
문법을 배우면 그걸 써본다던가.

그렇지 않으면 한번 듣고 지나가버림.



--------

테스트 과제는 오늘 까지 한거. 자료구조 set 내용.

특정시간 주고 의뢰. 데드라인 줄것.
평가 항목 및 배점 작성. 무엇보다 최우선은 데드라인 .
그리고 공개평가.


평가가 고과에 반영 된다는데. 기준 자체가 최대한 상대평가에 비교라고 한다.

그게 등수는 아니라는데 모르겠다.

국내 개발자는 자바를 할 수밖에 없는데 국내 주도 사업이기 때문(선택과 집중)

기존에 언어는 모든걸 다 하려 했음.
웹을 쳐다보지도 않았는데 스크립트 언어라 천시하는등.
근데 시대가 바뀜. 하드웨어쪽을 다른 언어가 하다가 웹으로 눈 돌린거

뭐 모르겠다 하면 ArrayList 쓰고 본다.
그러다 중복 되면 안되네 이러면  Set 쓰고.
뒤에 가서 UI할 텐데 자바의 Ui는 할 생각이 없음. 퍼포먼스 좋은게 많기 때문.

자바개발로 UI하는건 부담. 그래서 어설프게 만듬. 근데 타 언어를 쓰라고하는게 자바가 취하는 자세



---------


### 제네릭스

    public static void main(String[] args) {
        List<Integer> list = new ArrayList<Integer>();  //이렇게 쓰게 되면 Integer타입만 list에 넣을 수 있다.(제약을 주는거 이게 제네릭스)
        list.add(1111);
        list.add(2222);
        list.add("3333");

    }

처럼 list에 다른 형태가 들어갈 수 있는데 이렇게 주게 되면 Integer형태밖에 들어갈 수 없게 된다.

자바를 공부하는 또다른 방법은 깊게 공부하는 것도 좋지만 다양한 언어들에게도 영향을 줬다. 그리고 발전함에 따라 자바도 그 언어들에 의해 영향을 받음. 콜백이라든지 등등.

요구를 받아들이는게 늦었었따.

그래서 역으로 다른언어에 영향을 받는 스타일이 되버림.

그러므로 다른형태의 언어 공부하고 자바 공부하는거.
다른언어가 기본인데 자바에선 공백이 아님.

자바 공부하는 건 스펙트럼을 넓히는 게 좋다.

----

제네릭스 까지는 끝날 때 까지 계속 반복된다.
제네릭스까지는 꼭 익숙해 져야한다.

쓰레드는 스프링이나 자바에서 다 관리를 해준다.
하지만 제네릭스 까지는 꼭 알아야 하고 매우 중요한 부분이다.

---

### IO

IO의 주 타겟은 콘솔이였다.
근데 이제 우리가 다룰 대상은 File이다.

--------

프로그램의 중요성은 다양한 기능들이든 뭐든 좋지만

플젝 보면 상품성이 없다.
학원들 널리고 멀캠가면 매달 100만원 씩 줘가면서 가리키는데 필드에선 무시함 - 학원에서 뭘 배웠냐.

마인드를 바꾸자 우리는 이미 갈 길이 정해져있다. 나가면 바로 상품 만들어야됨.

현장가서 일 시작하면 이부분

기존엔 구현해놓고 끝. (나 할수있다)
근데 할수있다해놓고 시키면 개판. 그리고 좀 꺠지면 출그하기 싫음.
만들때마다 욕먹음.

그러다보니 다른 길이라던가 이직을 함.(이길 밖에 없냐 내가)

문제자체만 해결은 별거 아니지만 기본기능을 리팩토링하고 잘 되게하는거. 완벽하게 하는게 우선.


간단한 플젝이라 해도 생각하지도 못한 문제가 엄청 나온다.

자바로 메모장 만들려면 어어엄청 나옴. 경력자도 메모장 처럼 하려면 1일 이상 걸림. 우리가 만드려면 할 말은 없지.

------

윈도우 콘솔은 관리자 권한 줘야 파일이라던지 폴더 생성 된다고 함.
만약 안되면 이클립스나 인텔리제이 권한으로 실행해서 해보자.

디렉토리도 파일.
윈도우로 넘어왔다고 그 원칙 자체가 바뀌지는 않는다.
폴더와 디렉토리는 완벽히 일치하는 개념은 아님.
하지만 윈도우만 폴더를 디렉토리라고 한다.
그래서 파일 포매팅을 보면 윈도우가 사용하는 포매팅 기술이 디렉토리를 특수하게 사용한다.


----

절대경로 입력해도 완벽하게 나오게.
상대경로 입력해도 완벽하게 나오게 dir을 처리하는게 과제

txt파일 은 루트노드에서 다 실행해보자.

-------

운영체제 임시 저장에 대한 관점에서 특수 상황을 얘기하고 끝내자.
그리고 입출력

로컬 temp상 경로는 절대 겹치면 안됨.
그래서 내가 지정한 옵션은 prefix에서 suffix
파일의 앞부분 뒤부분은 지정하고 그 중단은 겹치지 않게 알아서 생성.
그래서 prefix로 시작해서 끝날때 suffix로 끝나는지 확인하면 된다.

이렇게 임시로 저장하는 위치를 정할 수 있다.

```
package com.bit.day11;

import java.io.File;
import java.io.IOException;

public class Ex06_tempFile {
    public static void main(String[] args) {
        File file = null;
        try {
            file = File.createTempFile("abcdefg", "txt"); //임시 파일 만드는 것
            System.out.println(file.getPath());
        }catch (IOException e){
            e.printStackTrace();
        }
    }
}


```

이러면 temp에 abcdef로 시작하고 txt로 끝나는 파일이 생길거다.

![20220330_121827](/assets/20220330_121827.png)

![20220330_121940](/assets/20220330_121940.png)

이걸 지워줘야 되는데 운영체제에서 이런 temp파일은 저장했다가 용량이 부족하다거나 필요 없으면 지우는 경우도 있다.

(ex.디스크 조각모음)

이걸 강제로 지우지 않아도 되긴함.
기본적으로 30일 기준으로 운영체제가 관리함.
30일 안 지나도 용량 벗어나면 가장 오래된 것을 지우게 한다.


어느정도 운영 체제가 관리를 해줌.


-----


IO 한해서 자바는 로우레벨에 가깝다.


IO의 기본은 쓰고 읽는거.
이렇게 쓰고 읽기에는 너무 불편하고 느리고 하니까 여기에 기능을 장착.

어디까지나 편의를 위함.


0이 나오면?
양수로만 하면 -128~127에서 0~255까지인데.

126이되면 제일 끝에 가고 다음 빌드는 제일 끝으로 갔다 그래서 0이 되는 거.

----

메모장의 특성은 다른 문서와 달리 바이너리 코드에 해당하는 숫자값을 그대로 글자로 표현해준다.

메모리 상 65면 화면에 A라 보여준다.

자체적으로 가진 포매팅으로 화면에 저장.

그래서 메모장은 그림 첨부나 표를 안되지만 워드나 한글은 자체적 포매팅 방식이 있어서 이런 표현이 가능하다.

메모장은 순수히 바이너리 코드로 화면에 띄워주는 역할을 하는 프로그램이다.

폰트는 바꿔도 데이터에 영향은 안줌. 다만 데이터 어떻게 보여줄까 그거만 정하는게 폰트

encoding은 데이터의 변형이 존재한다.
encoding 패턴에 맞춰 1,2byte로 조절한다.

----

byte는 바이트 제어해야되는데 바이트 스트림으로 바이트 제어 안하고 문자열을 쓰고 문자열을 제어하려고 해서 겪는 현상들.

이거 자체가 잘못된 것.

바이트를 바꿔서 문자열 쓰던지
문자열 스트림 쓰던지 해야되는데

바이트 스트림밖에 쓸 수 밖에 없으면 문자열을 바이트로 처리해야하긴 함.

-----


사용자가 버퍼 만들어서 처리한다는 거 뭔 뜻?
끝 나기 전 까지 다음 코드가 안 넘어감.

항상 확인 후 다음으로 넘어가는데 그러지 말고 한번에 몇바이트 통채로 써버리면 성능 향상됨.

읽어들일떄는 한번에 통쨰로 읽어들이고 읽어들이면 향상됨.

이게 BufferedReader, BufferedWriter 방식
알고리즘때 많이 했었는데 추억이새록새록

-----



버퍼를 쓴다 = 바이트 배열에 집어넣고 바이트 배열에 담아서 가져온다.
그래서 한번에 가져온다.

이제 이 수는 뭘 리턴하나?  => 몇개를 읽어 왔는지를 리턴한다.

기본적으로 양이 많으니까 버퍼만큼 꽉채워서 읽어옴.

그러다가 마지막 가니까 1005(버퍼만큼 꽉 채워서 나옴)


----

![20220330_153748](/assets/20220330_153748.png)

그럼 읽어들인 값을 누가 가지고 있나? -> 바이트
그럼 바이트 배열을 가지고 문자열 조립을 해야됨.

버퍼만큼 읽어오고 버퍼만큼 문자열 만듬. 문제는 문자열 만드는 과정에서 버퍼를 통째로 가져다가 문자열을 만듬.


만약 7바이트 파일에 사이즈 2만큼 주고 실행하면?

abcdefg까지만 나와야 되는데 f가 나옴. -> 왜?
중요한건 버퍼라는 건 바이트. 바이트 배열 읽을때마다 재사용 함.

반복문 돌때마다 재사용함.

한번 쓰면 다음번 쓸때마다 덮어씀.

그러면서 파일 끝을 만나면? 2만큼 읽으면 적은숫자 읽은거 그럼 그전 읽은 거 남아있으므로 그걸 가지고 문자열을 만들어버리게 된다.

이건 컴퓨터 입장에서 얘기가 달라진다.

이러한 현상을 이용하는게 우리가 함부러 파일 다운로드 받아서 정상적으로 열면 안되는 이유가 바로 이거. 내가 모르는 값이 숨어있을 수 있음. 파일이 정상적으로 열었는데 뒤에 악성 코드가 드러있다.


그리고 내가 연 순간 (의지에 의해 열면)  운영체제는 권한으로 연것으로 파악하고 악성코드가 실행되게 된다.



이걸 방지 하기 위해 buf를 주고 인덱스 0부터 원하는길이만큼 읽어들이게 하면 된다.

```
package com.bit.day11;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class Ex11_BufferedReader {
    public static void main(String[] args) {

        File file = new File("test11.txt");

        FileInputStream fis = null;
        byte[] buf = new byte[1024];    //쓸때와 달리 읽을때는 얘기가 다르다.

        //앞서선 1바이트씩 썼으면 지금은 읽어들이는게 3바이트
//        전체가 2800개면 3번만 읽어들이면 됨.4번째에 나감.
        long before , after;
        try{
            fis = new FileInputStream(file);
            before = System.currentTimeMillis();

//            while(true){
//                int su = fis.read();
//                if(su==-1) break;
//            }

            while(true){
                int su = fis.read(buf);
                if(su ==-1) break;
//                System.out.println(su);
                System.out.println(new String(buf,0, su));  //이러면 su 만큼(버퍼만큼) 문자를 읽게 된다.
                //읽어들인 값이 test11과 일치 하는지를 봐야한다.
            }

            fis.close();
            after = System.currentTimeMillis();
            System.out.println(""+(after-before)+"ms");
        }catch (FileNotFoundException e){
            e.printStackTrace();
        }catch (IOException  e){
            e.printStackTrace();
        }
    }
}


```

물론 쓸때도 마찬가지로


```

                fos.write(buf,0,buf.length);//쓸때도 마찬가지로 인덱스 0번부터 원하는 숫자만큼만 작성
```

이런식으로 써주면 된다.


-----

그럼 앞선 그림 읽는데 얼마나 빨라지는지 확인도 할 수 있다.



```
package com.bit.day11;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class Ex13_BufferedReaderImg {
    public static void main(String[] args) {


        File origin = new File("big02.jpg");
        File copy = new File("copy.jpg");

        FileInputStream fis = null;
        FileOutputStream fos = null;
        byte[] buf = new byte[1024];
        try {
            if (!copy.exists()) copy.createNewFile();
            fis = new FileInputStream(origin);
            fos = new FileOutputStream(copy);

            while(true){
                int cnt = fis.read(buf);
                if(cnt ==-1) break;
                fos.write(buf);
            }
            fos.close();
            fis.close();
            System.out.println();

            //성능 향상이 1kb버퍼로 인해 엄청난 성능향상. 2kb를 주면 1/2로 준다. 4kb는 1/4로 줄고. ㅇㅇ

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

앞서선 얼마 읽어들일지  고민할 때 지금은 얼마나 쓸 지 고민


그럼 이번엔 IO 쪽에서 제공하는 걸 써보자(필터 스트림)


-------

우리가 직접적으로 IO를 할 게 없는데 개념들을 이해하고 내부에서 동작하겠구나라는 걸 알아야 한다.

구현하는 게 중요하는게 아니라 내부 동작을 이해하기 위함이 중요한것.

IO 구현 못해도 개념으로 이해하면 전산상의 IO가 해석은 될것.

우선은 개념적인 접근이 우선이다.


그리고 편의성.제공해주는게 있는데 그래도 자바는 쉽게 써주는 것도 제공하나 코드상으로는 뭔가 더 복잡해진다.
코드상으로는 복잡한데 개념상으로는 어떻게 쉽게 프로그램 짜는게 가능한 지 나오게 된다.


기존 IO가 안되도 저 부분 까지의 IO는 알아두자.



byteStream의 기본은 숫자 다루는 거(stream으로)

프로그래밍의 특징은? 둘 중 하나 다루면 숫자 다루거나 문자 열을 다루거나 이거다.

문자열을 분해해서 숫자로 다룸.

프로그래밍이라는게 숫자열이나 문자열을 다룸.

그래서 문자열을 다룰때가 껄끄러운거

--------
테스트 =
의뢰 제품 만들고 제품 만들어 내면 됨.


------

### 필터 클래스


IO는 일방통행 흐름.
이거의 흐름과 똑같다.

필터클래스는 기능을 좀 더 쉽게 쓰게 된다.

그러면 필터클래스 쓰는 의미가 사라진다. 못하는 건 아니지만.

하지만 필터클래스다는 순간 기능이 확장됨.

클래스에서 기능은 메세드.

그 대표적인게 버퍼.

내가 만든 바이트 배열 가져와서 읽었다면

1바이트씩 읽으넌 마찬가지(내부에도 바이트 배열 있는건 마찬가지지만)
반복문이 2800몇번 돌아감.

버퍼 달았다해서 어떻게 하면 빨리 읽을 수 있을까.


필터클래스가 버퍼 가지고 있어서 거기서 버퍼의 양만큼을 읽어옴.

```
package com.bit.day11;

import java.io.*;

public class Ex13_BufferInputStream {
    public static void main(String[] args) {
        File file = new File("test11.txt");
        FileInputStream fis = null;
        BufferedInputStream bis =null;
        long before, after;

        try{
            fis = new FileInputStream(file);
            bis = new BufferedInputStream (fis); //inputStream에 필터 제공하는 건 BufferedInputStream이다.

            before = System.currentTimeMillis();
            while(true){
                int su = fis.read();
                if(su==-1) break;
                System.out.println((char)su);
            }
            bis.close();
            //bufeerdInputStream을 먼저 해제해줘야한다.
            fis.close();
            after=System.currentTimeMillis();
            System.out.println(":" + (after-before)+"ms");

        }catch (FileNotFoundException e){
            e.printStackTrace();
        }catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```

내가 반복문 돌릴때마다 가져오는 건 하드로부터 읽어옴.
반면 지금의 읽어오는 위치는 (IO의 버퍼 필터클래스는)

IO에서 읽어오는 건 메모리에서 메모리를 읽어오는거.

주기억장치와 보조기억 장치 속도차이는?

메모리만 있으면 되는데 한계 극복하려고 보조기억장치 등장한거. 대신 얘는 느림.

2배의 작업이라도 메모리에서 읽어오는 거라 빠름

같은 버퍼라도 버퍼의 위치가 다름.

그리고 객체를 생성하는 순간 버퍼를 읽어옴.

이걸 잘못하면 문제가 됨.

제대로 close()하지 않으면 값이 날아간다.

읽어오는 과정에서 값을 읽어옴.
정확히 해주지 않으면 파일 읽어오는 순간 다 날아감.

원하는 출력 하려면 일괄적으로 담아놨다 한번에 처리.

사실 하나씩 출력하는 건 너무 느려짐.


-----


```
package com.bit.day11;

import java.io.*;
import java.util.Arrays;

public class Ex13_BufferInputStream {
    public static void main(String[] args) {
        File file = new File("test11.txt");
        FileInputStream fis = null;
        BufferedInputStream bis =null;
        long before, after;
        byte [] arr = new byte[(int)file.length()] ;
        System.out.println(arr.length);
        int cnt = 0;

        try{
            fis = new FileInputStream(file);
            bis = new BufferedInputStream (fis); //inputStream에 필터 제공하는 건 BufferedInputStream이다.

            before = System.currentTimeMillis();


            while(true){    //정삳ㅇ 실행 코드
//                int su = fis.read();    //fis 대신 bis 버퍼에 담아서 실행하면 엄청난 속도 향상
                int su = bis.read();
                if(su==-1) break;
                arr[cnt++] = (byte)su;
//                System.out.println((char)su);// 하나씩 보내는건 속도저하에 엄청난 영향
                if(cnt == 1024){    //배열이 너무 큰 경우 문제가 생겨서 1024가 되면 배열을 줄였다.
                    cnt = 0;
                    System.out.println(Arrays.toString(arr));
                    arr= new byte[1024];
                }
            }


            bis.close();
            //bufeerdInputStream을 먼저 해제해줘야한다.
            fis.close();
            after=System.currentTimeMillis();
            System.out.println(new String(arr)+":" + (after-before)+"ms");

        }catch (FileNotFoundException e){
            e.printStackTrace();
        }catch (IOException e) {
            e.printStackTrace();
        }
    }
}


```


위 코드가 BufferedInputStream bis를 만들고 그 안에 넣어서 메모리로 부터 버퍼 읽어옴.

버퍼의 의미가 다름.

그래서 2가지를 동시에 할 수 있다.

-----

이 경우들이 다 되는 거는 아닐수 있다.
OS에 따른 제약사항도 좀 있다.
문자열에 길이 제한이 있다. (운영체제 특성상)


#### 버퍼 달 때 주의할 점

쓸때 BufferedInputStream, FileInputStream을 close를 안하면 안된다. (해제를 해줘야 됨).

이건 read할 때도 마찬가지.

꽉 차지 않더라도 밀어내는게 flush
그리고 버퍼를 초기화.
close 안해도 써짐.

API는 기능 쓰도록 요청.
그외에는 노출 안되있음.

-----


### 필터 클래스 중 특이한 필터 클래스를

스트림은 양방향(단방향인데 input, output 존재)

BufferedInputStream, BufferedOutputStream

예외가 있다.

printStream 는 기능을 더해주는데 새로운 기능을 더해줌.

이건 output을 목적으로 하는 필터 클래스다.
오직 쓰기만 제공됨.(outputStream만 제공)

이건 익히 지금까지 다 써왔던거.

참조변수 처럼 출력이 안되는 건 toString으로 호출


printStream조차도 필터클래스
이거 장착한다고 끝나는게 아니라.
정수기가 그렇다.

각각의 필터가 끝나면 필터 걸러져서 물 얻듯이
이건 무한 장착이 가능하다.


이 사이에 뭘 넣을 수 있나? 버퍼드 장착 가능.(성능 향상시키겠다면)


버퍼드 스트림의 특징은 버퍼의 기능. 버퍼는 성능향상.
프린트 스트림의 기능은 문자열 처리로 빨리.쉽게.
이걸 두가지 합하면 빠르면서 쉽게 가능.

기본적으로 바이트 스트림, 아웃풋 스트림으로 기능은 함.
단지 느리고 쓰기 불편.


------

IO에 확장된 개념을 가지자.
