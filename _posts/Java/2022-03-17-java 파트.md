---
title: "[java] java 파트"
layout: post
subtitle: Java
date: '2022-11-19 19:45:51 +0900'

categories: class
tags: Java
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---


set path=%JAVA_HOME%;%PATH%

echo %path% 쳐보면
-- 자바 패스가 들어감

윈도우는 ansi타입 기본 사용하다가
윈 10 버전하면서 포매팅을 utf-8로 변경

```

public class Main {

	public static void main(String[] args) {

		byte d;
		d=127;
		d=d+1;
		System.out.print(d);

	}
}

```
이 구문은 에러가 날까? -> ㅇㅇ
byte와 int 부분을 더하는 거라 에러가 난다.

Main.java:8: error: incompatible types: possible lossy conversion from int to byte ->

```    
    public class Main {

    	public static void main(String[] args) {

    		byte d;
    		d=12;
    		d+=1;
    		System.out.print(d);

    	}
    }
```    



이건? 정상 실행되서 13이 나온다.


```    
    public class Main {

    	public static void main(String[] args) {

    		byte d;
    		d=127;
    		d+=1;
    		System.out.print(d);

    	}
    }

```          
이건 어떨까?

-128 이 출력이 된다.

--어렵다-- 헷갈린다.


```

    public class Main {

    	public static void main(String[] args) {

    		byte d,e,f;

    		d=1;
    		e=2;
    		f=d+e;
    		System.out.print(d+"+"+e+"="+f);

    	}
    }
```

이건 뭐가 문제일까?
이건 자바 문제라기보다 시스템적인 문제이다.

2개의 바이트를 더하기 연산 처리하고 있다.
우리 시스템은 바이트를 연산하도록 세팅이 안 되어 있다.


d,e는 둘다 바이트인데 +연산이 등장하면 이걸 더하기 연산처리 하기 위해 둘다 int로 바꾸고 이걸 int인 3이 되서 int인 3이 되기 때문에 int타입의 3이 나왔는데
이 순간 f에 넣었는데 f는 byte이기 때문에 에러가 나게 되는 것.

이걸 자바에서 오토 캐스팅(자동 형변환)이라 한다.


```

    public class Main {

    	public static void main(String[] args) {

    	    double h = 3.14;
    	    System.out.print(h);
    	    float i = 3.14f;    //에러 없음.
    	    float i = 3.14;     //이건 에러 뒤에 f를 안씀. 실수가 정수(8바이트(double)가 4바이트(float))에 들어가므로 에러가 나는 것.
    	    System.out.print(i);


    	}
    }

```

float double 처럼 형 크기가 차이 나는 것도 매한가지.
3.14f였을때 에러가 없던게 3.14로 f를 제거하고 float에 넣으니까 에러가 생겼다.


전산에서는 신뢰가 가장 우선시. 틀린 답을 내놓느니 에러나는게 백만배 나음.



----

```
class Main{
	public static void main(String[] args){
    	char ch1;
    	ch1 = 'A';
    	ch1='\uac00'; 이게 들어가면 '가'로 바뀐다.
    	//ch1 = ch1+1;
		System.out.println(ch1);
	}
}
```

-----

```
class Ex06{
	public static void main(String[] args){
		//제어문-if문
		if(false){
		System.out.println("참");
		}else{
		System.out.println("거짓");

		int su = 1;
		switch(su){
			case1:
			System.out.println("1입니다");
			break;
			case2:
			System.out.println("2입니다");
			break;
			case3:
			System.out.println("3입니다");			
			break;
			default:

			System.out.println("0입니다");
			break;
	}

}
```
각 케이스들 자료형들이 일치해야 한다. 그리고 switch안에 연산을 취하면 안된다.
case 2+1: 이런식으로


----

```
@echo off
set filename = Ex08
del %filename%.class
javac %filename%.java
java %filename%
```

컴파일 하고 클래스 파일 만들고 실행


그래서 소스파일을 쓴다는 건 남들이 가져다 놓은 클래스 파일을 가져다 쓴다고 생각하면 된다.


----

클래스는 3가지 기본요소 가지는데 그게 메서드, 언어에 따라서 어떤건 메서드, 어떤건 함수 ,어떤건 두개 동시지원.

자바는 메서드만 지원

```
class Main{


	public static int func01(){
		System.out.println("func01 run...");
	 	return 1234;
	}
	public static void main(String[] args){
	       System.out.println("호출전");
	       func01();
	       System.out.println(func01());
	       int su = func01();
	       System.out.println("호출후"+su);
	   	return;
	}

}
```

```
class Main{


	public static int func01(){
		System.out.println("func01 run...");
	 	return 1234;
	}

	public static void func02(int a){
	       System.out.println("전달 받은 매개변수는 a");
	   	return;
	}


	public static void main(String[] args){
	       System.out.println("호출전");
	       func01();
	       System.out.println(func01());
	       int su = func01();
	       func02(4321);
	       System.out.println("호출후"+su);
	   	return;
	}

}

```

위 처럼 되는데 메서드끼리 이을떄, 소개 받는 인자, 넘기는 인자의 개수, 타입이 다 일치해야 한다.


--------------

#### 변수
- 기본변수
- 참조변수
	문자열
	String 변수명;
	변수명 = "문자열 ~~~";
	String msg = "";//문자열은 비어있는 문자가 존재 가능
	String 변수명 = 값;
	"값java"=msg+'java';
	"값true" = msg+true;

------

#### 연산

연산자에는 우선순위가 존재

#### 반복문
for (초기화1; 조건2; 증감 3){반복구문4;}
1->2->4->3->2->4->3->2->4

while(조건){반복구문;};

--------

초기화1;
while(조건2){반복구문4; ~~~~~~~~~~증감식3}

------



JAVA_HOME=D:\Program Files\Java\jdk-15.0.1
PATH=%JAVA_HOME%		;	~~~~~~~~~~~~

객체 쓰면 변수 타입 여러개 쓰고 여러개 정의 가능.
다른 타입일지라도 하나의 타입에 저장되서 주고받는게 가능해진다.



null과 빈 문자열은 다른거.(빈 문자열은 문자열 객체가 있는거. 널은 객체를 가리키는게 없는거. 객체적 입장에서 2개는 완전히 다른거.)

자바는 80% 이상이 C로 만들어짐.
C언어에서 포인터 개념이 어려워서 자바에서 그걸 안쓰기로 함 . 근데 비슷한 역할은 무조건 있음.
jvm 구조(클래스 스택 힙 영역)에서 주소를 가리키는거고 포인터가 주소를 가리키듯이 java에서도 해당 변수 주소를 가리키게 하는 (메모리의 주소)게 하나는 존재한다.


------

5일차.

문법은 필요에 의해 쓰는 거지 억지로 쓰면 어..음..

메인 돌다 메서드 호출하면 새 메서드 찾아서 그 메서드 호출해서 스택에 올려주고 리턴하면서 값 가져오고 넘어오면서 이 과정에서 스택에 올렸다 뺐다 하는 일이 발생하는데 이 경우는 메인에서 쭉 가는게 낫지 않나?

**문법을 쓰기 위해 코딩하면 컴퓨터는 불필요한 일을 하게 되는 일이 강하다.**

자동형변환 또 하면 느려지고 이런 식.

지금 코딩 스타일에 대해 상당 부분이 목적없이 문법 써서 코딩하다 보니


-------------


문제 낼때는 필요한 사항 및 요구사항만 만족
그 외에는 문제 안되는 한 결과 잘 나오면 일단은 ㅇㅋ

학습에선 결과보단. 어떤식으로 접근했냐를 더 우선시 함.

--------

객체지향 = 말을 코드로 했다.

문법을 억지로 써먹으려고 하지는 말자. 그렇게 하면 불필요한 객체 쓰게 됨.

그렇게 학습 진행하다 보니 객체 의미없이 찍어냄.
그러기에 메모리 비효율 적이나 시간 복잡도 비효율 적인게 되서
디자인 패턴으로 싱글톤이라는 방식도 생겨나게 된다(객체 막 찍지 못하게)

---------

메서드 = 재사용

클래스도 마찬가지로 클래스에서 다른 클래스로 접근해서 거기 있는 기능과 속성을 볼 수 있었다.

클래스 = 코드의 재사용

단 이때 재사용하는 단위가 클래스 구성 요소를 재사용 할 수 있게 된다.

그 중 하나가 메서드이다.

메서드가 다른곳에서 쓸 수 도 있지만 다른곳에서 쓰는건 클래스를 통해서 다른 곳에서 쓰는 거.

오직 하나의 클래스로 메서드 가진거는 재사용 하는거고


내가 메서드 만드는 건 필요에 따라서 코드를 재사용 하는거

코드의 재사용은 반복문으로 쓰기 불편한 코드의 재사용이 되었다는 것.

클래스를 만드는 목적? = 클래스 단위로 재사용이 필요하니까


코드의 재사용을 위해서 사용되는 거.(상속이라던지 이것도 마찬가지.)
상당수의 문법이 코드의 재사용을 위해 사용된다.

따라서 문법을 쓰기 위해서는 재사용될 코드를 먼저 도출해야 되는 것.

재사용될 코드를 가지고 이것을 반복문으로 바꿀지 클래스로 바꿀지 뭐로 할지 결정을 해야 하는 것이다.

그러한 과정이 코드 리팩토링이다.

개발자들이 계속 프로그램 짜고 끝날게 아니라 계속 수정함.

모듈화 하는 이유?
모듈로 해서 필요한 부분에서 사용이 가능하도록 표준화를 시키는 것이다.

코드를 재사용 하는 것이 중요.

첨부터 그렇게 짜면 좋은데 그렇지 못한 이유가 뭔가?-> 안되니까
어떤 개발자도 한번에 그것을 완성된 모듈화 형태로 나갈 수가 없다.(아무리 경력 좋고 해도)




------------

현존하는 언어의 포맷팅은 문자 체계가 가변이다.

유니코드는 문자코드로서 범주를 얘기한다.
특정 문자 포맷 가졌다가 그걸 유니코드라 하는게 아니다.




숙제(day05)

1. 자바 정규표현식 조사
2. 성적관리 ver 2.0

한 학생 성적을 다음을 통해 출력하시오

객체배열 나오면 String으로 생각해보자. 왜냐면 String도 객체이기 때문.

------------

day 06


클래스에 붙는 final은 더이상 상속하지 않는다.

메서드에 붙는 final은 마지막 메서드(오버라이딩을 허용하지 않겠다.)


final
class: 클래스의 상속 거부
method: 오버라이드의 거부
변수에서의 final : 상수형 변수

내부클래스는 웬만하면 잘 안쓰는데 잘 쓰는 경우가 단 한가지가 있다.
근데 잘 쓰는 경우가 한가지가 있다고 한다.

근데 해외에선 또 잘 쓴다고 하네?
아무튼 그럼.

----

day 07

숫자를 다루는 클래스는 Number클래스를 상속받고 있다.

입력값을 받았는데 정수냐 실수냐에 따라 그걸 하나의 변수가 받아야 된다면?
int와 double을 다 받을수 있는 변수는 Wrapper클래스 말고는 없다.
(Object, Number)


------

day 08

기존 스트링의 단점은 뭔가를 처리하면 새로운 객체를 계속 리턴했다.

내 자신이 바뀌는 게 아니라 조작된 새로운 객체를 리턴.

배열복사를 가장 쉽게하는건

```
public static void main(String[] args) {
        char [] arr1 = {'a','b','c','d'};
//        System.out.println(Arrays.toString(arr1));

        System.out.println(new int[] {1,2,3,4});
        System.out.println(Arrays.toString(arr1));

        char[] arr2 = Arrays.copyOf(arr1, arr1.length);
        System.out.println(Arrays.toString(arr2));
        System.out.println(arr1==arr2);

        //배열복사 가장 쉽게 하는 법
    }
```

로  Array.copyOf를 사용하면 된다.

![20220325_124215](/assets/20220325_124215.png)

객체배열은 객체 주소값 담는데 복사하면 배열은 다르지만 그 안의 element가 가리키는 객체는 동일한 객체라는 것이다.



객체배열 만들면 새로운 배열이 만들어지지만 그 깊은 복사 한 배열은 같은 객체를 가리킨다는 것.

element까지 복사 되지 않는다는 것.

만일 다른 객체를 만들고 싶으면(새로운 element만들고 싶으면)
그때는 배열을 반복문 돌려서 만들어야 된다.


system.arraycopy는
