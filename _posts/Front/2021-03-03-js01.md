---
title: "[front] WebFrontEnd 3일차"
layout: post
subtitle: front
date: '2021-03-4 09:45:51 +0900'

categories: class
tags: Front
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---

20210304


##자바스크립트의 개요


- 자바스크립트는 프로토타입 기반의 스크립트 프로그래밍 언어로 객체지향 개념을 지원
- 웹 브라우저가 자바스크립트를 html과 함꼐 다운로드해서 실행
- 웹프라우저가 html문서 읽어들이는 시점에 자바스크립트 엔진이 실행된다
- 대부분의 자바스크립트 엔진은 ECMA스크립트 표준을 지원한다.


##자바스크립트의 특징


- 자바스크립트는 HTML,CSS와 함께 웹을 구성하는 요소 중 하나로 웹 브라우저에서 동작하는 유일한 프로그래밍 언어
- 자바스크립트는 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어이다.
- 각 브라우저 별 자바스크립트 엔진(v8엔진등)은 인터프리터와 컴파일러 장점을 결합하여 비교적 처리 속도가 느린 인터프리터의 단점을 해결
- 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어.

##요약


- 웹 브라우저는 자바스크립트를 hTML과 함꼐 다운로드 하고 브라우저의 자바스크립트 엔진이 자바스크립트를 실행한다.
- 자바스크립트는 클래스가 존재하지 않는 프로토타입 기반의 객체지향 언어이다(edition6 에선 클래스 개념 지원)
- Netscape에서 처음 만들었으며 이후, ECMA에서 ECMA스크립트라는 이름으로 표준화 됨.
- 각 브라우저에서는 ECMA스크립트 스펙을 준수하는 방식으로 자바스크립트를 지원한다.


##자바스크립트 선언

- HTML에서 자바스크립트를 사용하려면 script 태그를 사용
- script 태그는 'src'와 'type 속성을 사용하여 자바스크립트를 선언 (HTML5부터는 type속성 생략 가능)'
- src속성은 외부의 자바스크립트 파일을 HTML 문서에 포함할 때 사용하며 생략할 수 있다.
- type 속성은 미디어 타입을 지정할 때 사용 자바스크립트 코드는 'text/javascript'로 지정.
- 스크립트 태그는 HTML 파일 내부의 head나 body 안 어느곳에서나 선언 가능
하지만 body안의 끝부분에 script태그를 둘 것을 권장함
- head안에 위치한 자바스크립트는 브라우저의 각종 입출력 발생 이전에 초기화 되므로 브라우저가 먼저 점검함
- body안에 위치시 브라우저가 html부터 해석해 화면에 그리기 떄문에 사용자가 빠르다 느낄 수가 있음.

![20210304_093043](/assets/20210304_093043.png)


자바를 제외한 웹 모든 파일은 웹 컨텐츠에 넣는다.

js 파일도 저기 웹 컨텐츠에 임포트.

js파일이나 html파일은 저기 안에 카피 해도 되지만 가능하면 임포트 하자 왜냐면 src안의 자바파일을 인식 못하는 경우가 나올수 있기 때문.



```
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>구구단</title>
</head>
<body>
	<script type="text/javascript">
	//변수 선언.
	var dan = 7;
	var result = 0;

	console.log('** ' + dan + '단 ** ');
	//for문을 이용하여 9번 반복.
	for(var i=1;i<10;i++) {
		//곱셈 연산의 결과를 저장.
		result = dan * i;

		//콘솔창에 출력
		console.log(dan + ' * ' + i + ' = ' + result);
	}
	</script>
</body>
</html>


```
를 실행하면 화면엔 아무것도 안나 올 것이다. f12로 개발자 모드로 들어가자.

그럼 콘솔부분에

![20210304_093620](/assets/20210304_093620_l4nux9f57.png)

위와 같이 나오는 걸 알 수있다.



```
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>구구단</title>
  <script type="text/javascript">
  //변수 선언.
  var dan = 9;
  var result = 0;

  console.log('** ' + dan + '단 ** ');
  //for문을 이용하여 9번 반복.
  for(var i=1;i<10;i++) {
    //곱셈 연산의 결과를 저장.
    result = dan * i;

    //콘솔창에 출력
    console.log(dan + ' * ' + i + ' = ' + result);
  }
  </script>
</head>
<body>

</body>
</html>

```

저 스크립트를 head안에 넣어서 실행해도 똑같이 실행된다. 값만 바꿔서 확인해보자.

![20210304_093727](/assets/20210304_093727.png)


브라우저에서 흔히 말하는 창을 윈도우라 하고 이 창 안에 타이틀 바와 로케이션 바  로케이션 부분을 빼고

저  중앙 부분을 document라 한다.


![20210304_093945](/assets/20210304_093945_h0qxq5rtd.png)



```
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>시계</title>
	<script type="text/javascript">
	window.onload = function() {
		setInterval(showTime, 1000);
	};

	function showTime() {
		var view = document.getElementById("view");
		var date = new Date();
		view.innerHTML = date.toLocaleTimeString();
	}
	</script>
</head>
<body>
	현재 시간 : <span id="view"></span>
</body>
</html>
```

함수는 우리가 아는 메서드 기능 수행하지만
자바스크립트는 변수나 객체같은 거로 담을 수 있다. 1급객체고 객체를 변수에 담을 수 있따.
setInterval은 앞의 함수를 호출하는데 그냥 하는게 아니라 밀리세컨즈 말을 한다.

1초마다 주기적으로 호출해버림.
getElementById로 아이디가 view인 걸 얻어오자

setInterval 뿐 아니라 setTimeout도 있다. 1초후 한번만 호출함.
주기적으로 호출하는건 setInterval

## 구구단 출력
- 반복문을 이용해서 브라우저 콘솔창에 구구단 출력
## 변수 선언시엔 숫자형이든 문자형이든 모두 var키워드를 사용
- 연산결과를 선언한 변수에 저장
- console.log()함수를 이용해서 브라우저의 콘솔창의 결과 출력.

## 시계구현
- 자바스크립트ㅡ이 date내장 객체로 현재시간을 출력
- date객체의 tolocaltimeString()함수를 호출하면 현재시간을 return
- span태그에 시간을 출력하기 위해 innerHtml프로퍼티에 값을 할당
- setInterval() 함수를 이용해 1초마다 현재시간을 업데이트.

## 요약
- html문서에서 자바스크립트 쓰려면 script태그 사용
- 자바스크립트 코드는 html 파일 안에 두거나 외부 자바스크립트파일(*.js)를 html문서 안에 포함
- script태그는 html 문서의 어느 위치에서나 선언 가능하며 일반적으로 head, body 내부에 위치
- 웹브라우저가 html 문서를 순차적으로 해석(파싱)하므로 스크립트 위치에 따라 로드와 실행시점이 달라진다.

## 자바스크립트의 기본문법

###변수

- 자바스크립트는 변수 선언시 타입을 명시하지 않고 var keyword를 사용하여 선언
- 자바스크립트는 동적타입(dynamic,weak type)언어, 변수타입 지정 없이 값이 할당되는 과정에서 자동으로 변수 타입 결정 -> 같은 변수에 여러타입의 값을 할당 가능
- 변수이름은 함수 이름과 혼동되지 않도록 유일한 이름을 사용(변수[형용사,명사], 함수[동사] 사용)
- 자바스크립트는 ECMA스크립트 표준에 따라 카멜케이스 사용
키워드,공백문자 포함, 숫자로 시작 안됨
특수문자는 _와 $허용

### 자료형

- 프로그램은 정적인 데이터값을 동적으로 변환해가며 원하는 정보를 얻는다
- 프로그램에서 다루는 데이터값의 종류들을 자료형이라 표현
- 자바스크립트에서는 자료형을 원시타입과 객체타입(primitive, object)로 분류
원시타입엔 숫자, 문자열, boolean, null undefine과 같이 5가지가 있다. 이를 제외한 모든 값은 객체타입이다.

| 숫자형     | 문자열형    |
| :------------- | :------------- |
| number       | string      |
| 정수 또는 실수형       | 문자, single or double quotation으로 표기   |

| boolean형 | undefined     |  null |
| :------------- | :------------- |  :------------- |
| boolean      | undefined        | object
|참 or 거짓     | 변수가 선언되었지만 초기화 되지 않을 경우       | 값이 존재하지 않을 경우 |



![20210304_095556](/assets/20210304_095556.png)

이클립스 마켓 가서 다운받아도 되는데 다운 받았으면 인스톨 뉴 소프트웨어 가서 해도 된다. zip파일 있을 경우

![20210304_095658](/assets/20210304_095658.png)

add 에 아카이브에 zip파일로 선택하고

term repositroy선택하고 열기 하고 add하면

![20210304_095725](/assets/20210304_095725.png)

위와같이 들어가고 다 선택하고 넥스트

![20210304_095947](/assets/20210304_095947.png)

그리고 다 선택하고 동의한다하고 설치하면 된다.

설치 다 했으면 tern이라는 플러그인 사용하게 바꿔줘야

프로젝트 -configure- convert to tern project가 설치하기 전에 없었는데 생기게 된다.

![20210304_100549](/assets/20210304_100549.png)

이렇게 생기게 된다.

좀 내려가면jquery로 체크하자 그럼 브라우저도 같이 체크가 됨.
제이쿼리는 새로운 언어라 표현할 수 없고 자바스크립트에서 자주쓰는걸 라이브러리로 만들어 둔거.


이제 넣고 자동완성이 되게 된다.

물론 vsc에서도 하면 자동완성 되지만 이클립스 기반의 ide에서도 쓰는 법은 알아야 하니 이렇게 해두자.


## 자료형을

- 자바스크립트는 숫자를 정수와 실수로 나눠 구분하지 않는다.
- 모든 숫자를 8바이트 실수형태로  처리 >> 실수로 처리(정수만을 표현하기 위한 데이터 타입은 없다.)
- 편의성을 위해 정수 리터럴과 실수리터럴을 제공
- 숫자의 연산처리시 실수형태로 하기 때문에 특정 소수점을 정확히 표현하지는 못함.
- 기본 연산기호는 자바나 C++과 같은 일반프로그래밍과 같다.
- 자바스크립트는 언더플로, 오버플로, 0으로 나누는 연산에 예외를 발생시키지 않는다.

![20210304_101008](/assets/20210304_101008.png)

어떤 숫자를 0으로 나누면 인피니티가 나오는데 무한대라 생각하자
- infinity: 무한대를 나타내는 상, 어떤 수를 0으로 나누거나 인피니티를 어떤 수로 사칙연산한 결과
- Nan : not a number : 계산식의 결과가 숫자가 아님을 나타내는 상수

![20210304_101301](/assets/20210304_101301.png)


## 문자열

- 자바스크립트에서 문자열은 16비트의 유니코드 문자를 사용
- 문자 하나를 표현하는 char과 같은 문자형은 제공하지 않는다. 'a'과 같은 한 글자도 문자열로 표현
- 작은 따옴표(', singlequotes') 또는 큰 따옴표(', doublequotes')둘 다 사용가능, 혼용불가
- 이스케이프 시퀀스(\)도 사용 가능.)

```
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Insert title here</title>
	<script type="text/javascript">

	console.log("큰따옴표 문자열");						// 큰따옴표 문자열
	console.log('작은따옴표 문자열');					// 작은따옴표 문자열
	console.log("3.14");							// 3.14
	console.log('문자열 안에 포함된 \'작은따옴표\' 표현');	// 문자열 안에 포함된 '작은따옴표' 표현
	console.log("특수문자 사용\n줄바꿈 했다.");			// 특수문자 사용
													// 줄바꿈 했다.

	</script>
</head>
<body>

</body>
</html>
```

boolean은 비교연산의 결과값으로 true또는 false중 하나의 값을 갖는다

#### 비어있는 문자열, null, undefined, 숫자 0 은 false로 간주된다.
- null 은 값이 없거나 비어있음을 뜻하고, undefined는 값이 초기화되지 않았음(정의되지 않음)을 의미.
- null 과 indefined는 의미가 비슷하지만 값을 할당하지 않은 변수는 undefined가 할당되고(시스템레벨), 코드에 명시적을 값이 없음을 나타낼 때(프로그램 레벨) 는 null을 사용


### 자동형변환(동적 타이핑, dynamic typing)

- 자바스크립트는 자바나 C++ 과 달리 자료형에 대해 매우 느슨한 규칙이 적용
- 어떤 자료형이든 전달할 수 있고 그 값을 필요에 따라 변환 가능
- 서로 다른 자료형의 연산이 가능
- 모든 자료형을 var로 선언하기 떄문에 변수 선언은 쉽지만 이런 느슨한 규칙 떄문에 혼란을 야기

```
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Insert title here</title>
	<script type="text/javascript">

	var msg = 40;

	console.log("message : " + msg);		// message 40
	msg = "hello javascript";
	console.log(msg);						// hello javascript

	console.log("The message is " + 40);	// The message is 40
	console.log(40 + " is The message");	// 40 is The message

	console.log("40" - 5);					// 35
	console.log("40" + 5);					// 405

	console.log(parseInt("123.45") + 1);	// 124
	console.log(parseFloat("123.45") + 1);	// 124.45

	console.log("1.1" + "1.1");				// 1.11.1
	console.log((+"1.1") + (+"1.1"));		// 2.2

	</script>
</head>
<body>

</body>
</html>

```
문자열에서 5 뺴니까 35가 되고 5 더하니까 405가 나온다. 문자열에서 뺴기는 못하니까 자동으로 숫자로 바꿔서 계산하지만 더하기는 문자열도 가능하니까 405가 나온다.

실수형도 1.11.1
근데 앞에 똑같은거인데 + 를 넣으면(단항연산자)
이 +는 숫자 앞에만 나타낼수 있어서 자동으로 숫자로 형변환 되서 계산한다.

+는 문자열도 가능한 연산이라 자동 형변환이 안된다.


##변수 호이스팅

- var키워드를 이용한 변수는 중복해서 선언이 가능
- 호이스팅이란 var 선언문이나 function 선언문 등 모든 선언문이 해당 scope의 처음으로 옮겨진 것 처럼 동작하는 특성, 즉, javascript는 모든 선언문이 선언되기 이전에 참조가 가능
#### 변수의 생성
- 선언단계:  변수객체에 변수 등록
- 초기화 단계 : 변수객체에 등록된 변수를 메모리에 할당. undefined로 초기화 됨.
(이 두단계는 한번에 이뤄짐)
- 할당단계: undefined 로 초기화된 변수에 실제 값을 할당.


```
console.log(num); //undefined
var num = 123;
console.log(num)//123
{
  var num =456;
}
console.log(num); //456
```
- num이 선언되지 않아서 에러 날거 같지만 콘솔엔 언디파인드가 출력 모든 선언문은 호이스팅 되기 떄문.
<br>
- var num =123; 이 호이스팅 되어 첫 줄 앞에 var num 이 옮겨진 것 처럼 동작. 이때 num에는 undefined로 초기화가 일어나며,(선언, 초기화 단계가 실행) 실제 123값이 할당되는 곳은 두번쨰줄에서 실행이 된다.

<br>

- 자바스크립트는 블록레벨 스코프를 가지지 않고 함수레벨 스코프만 갖는다. num은 전역변수이므로 전역에 선언한 변수 num에 두번째 num에서 재할당 되기 때문에 456을 갖는다>> 해결책:const, let(ES6)

### 상수(constant)

####ECMAscript6 이전까지는 상수표현 지원 안함.
- 변수의 값 변경하면 안되는 상수와 일반변수를 구분하고자 변수명명규칙을 다르게 하여 사용
- 상수의 표기법은 모든 대문자 사용하고 단어사이로는 '_' 로 표기


###let과 const키워드

-es6부터 let,const키워드 추가


| 키워드   |구분    |선언위치     |재선언    |
| :------------- | :------------- |:------------- |:------------- |
| var      | 변수     |전역스코프    |가능       |
| let      |  변수      |해당스코프        |불가능      |
 const      |  상수      |해당스코프           |불가능      |


```
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Insert title here</title>
	<script type="text/javascript">
	window.onload = function() {
		{
			var val = 10;
			//let val = 20;
			const con = 10;
			//con = 20;
		}
		{
			alert(val);
			//alert(con);
		}
		alert(val);
	}
	</script>
</head>
<body>

</body>
</html>

```
여기서 alert은 undefine가 선언되서 찍혔고 호이스팅 되서 (자바같으면 변수 선언 안하고 쓰면 에러나지만 자바스크립트에선 아니다).


중괄호 나왔는데 이러면 실행 안될거 같은데? 근데 오히려 상단의 개념으로 전역의 개념에 호이스팅.(var로 하면 전역변수 취급)

그래서 let,const를 추가했다(ES6에서)
이번에 let으로 바꾸고 실행하면 ?
이번엔 에러가 난다.

![20210304_103724](/assets/20210304_103724.png)

에러확인은 콘솔창에서 확인.

에러는 초기화 하기 전에는 접근 자체가 안된다고 나온다.
let은 스코프가 있다.

###연산자
- 연산자는 연산의 대상이 되는 값(타입) 에 따라서 동작이 결정
- "+"연산자는 대상의 값이 모두 숫자인 경우 산술연산을 수행
- "+" 연산자는 대상 중에 문자열이 포함된 경우 모든 연산 대상을 문자열로 변환하고 문자열 결합
- 연산자는 종류에 따라 1항 연산자, 2항 연산자, 3항 연산자로 구분.
- 논리값을 비교해서 참, 거짓을 판단.
- 비교연산자 ==, ===의 차이는 자료형까지 비교하는지 아닌지의 여부


###객체

- 객체는 이름과 값으로 구성된 프로퍼티의 집합.
- 문자열, 숫자, boolean, null, undefined를 제외한 모든 값은 객체
- 자바스크립트의 객체는 키(key)와 값(Value) 로 구성된 프로퍼티(property)들의 집합
- 전역 객체를 제외한 자바스크립트 객체는 프로퍼티를 동적으로 추가하거나 삭제 가능
- 자바스크립트의 함수는 일급객체이므로 값으로 사용할 수 있다. 따라서 프로퍼티의 값으로 함수를 사용 가능
- 자바스크립트 객체는 프로토 타입이라는 특별한 프로퍼티를 포함.

#### 객체리터럴
- 가장 일반적인 방법
- {} 를 사용하여 객체를 생성 {} 내에 1개 이상의 프로퍼티를 추가하여 객체를 생성

#### Object 생성자 함수
 - new 연산자와 Object생성자 함수를 호출하여 빈 객체를 생성
 - 빈 객체 생성 후 프로퍼티 또는 메서드를 추가하여 객체 완성

#### 생성자 함수
- 동일한 프로퍼티를 갖는 객체생성시 위 두 방법은 동일한 코드를 반복적으로 작성
- 생성자 함수를 이용시 템플릿(클래스) 처럼 사용해 프로퍼티가 동일한 객체 여러개를 간단히 생성 가능.

객체 리터럴 예시

```
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Insert title here</title>
    <script type="text/javascript">
      var obj = {}; // empty obejct
      console.log(typeof obj);

      var student = {
        name: '김싸피',
        area: '서울',
        classNum: 7,
        info: function () {
          console.log(this.name + '은 ' + this.area + this.classNum + '반');
        },
      };
      console.log(typeof student); // object
      console.log(student); // {name: "김싸피", area: "서울", classNum: 7, info: f}
      student.info(); // 김싸피는 서울7반
    </script>
  </head>
  <body></body>
</html>

```

여기까지 자바로 따지면 변수 만든거
자바스크립트에서 객체 만드는 건 꼭 알아야.

콘솔창에서 확인해보자.

![20210304_105543](/assets/20210304_105543.png)


생성자 함수 확인

```
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Insert title here</title>
    <script type="text/javascript">
      /*
      var student1 = {
        name: '김싸피',
        area: '서울',
        classNum: 7,
        info: function () {
          console.log(this.name + '은 ' + this.area + this.classNum + '반');
        },
      };
      var student2 = {
        name: '박싸피',
        area: '대전',
        classNum: 4,
        info: function () {
          console.log(this.name + '은 ' + this.area + this.classNum + '반');
        },
      };
      */
      // 생성자 함수
      function Student(name, area, classNum) {
        this.name = name;
        this.area = area;
        this.classNum = classNum;
        this.info = function () {
          console.log(this.name + '은 ' + this.area + this.classNum + '반');
        };
      }

      // 객체 생성.
      var student1 = new Student('김싸피', '서울', 7);
      var student2 = new Student('박싸피', '대전', 4);

      console.log(typeof student1);
      console.log(typeof student2);

      console.log(student1);
      console.log(student2);

      student1.info();
      student2.info();
    </script>
  </head>
  <body></body>
</html>

```

/*
var student1 = {
  name: '김싸피',
  area: '서울',
  classNum: 7,
  info: function () {
    console.log(this.name + '은 ' + this.area + this.classNum + '반');
  },
};
var student2 = {
  name: '박싸피',
  area: '대전',
  classNum: 4,
  info: function () {
    console.log(this.name + '은 ' + this.area + this.classNum + '반');
  },
};
*/

여기 네임, 에어리어 , 클래스네임 이런게 없는데 생성자 함수엔 this.name이런식으로 사용.
앞에 this쓰면 그 함수의 속성이 되는거고 그 뒤의 name이나 area는 변수로 생각하자.


아까 접근 할 때 = 있으면 자바로 따지면 setter라 생각
this,은 가진 값을 얻어와라는 뜻

- 객체는 dot(.)을 사용하거나 대괄호([])를 사용해서 속성값에 접근. 대괄호 내에 들어가는 프로퍼티 이름은 반드시 문자열이여야 한다.
- 객체에 없는 속성에 접근시 undefined를 반환
- 객체속성값을 조회시 || 연산자를 사용하는 법도 가능.

-속성값 변경시 dot이나 대괄호 사용
-객체에 값을 할당하는 속성이 없을 시 그 송성은 추가됨
elete연산자를 이용해 속성 제거.

![20210304_111400](/assets/20210304_111400.png)

자바는 추가라던가 제거가 없음.

####참조

- 객체는 복사되지 않고 참조된다
- 자바스크립트에서 원시 데이터 타입이 아닌 모든 값은 참조타입
- 참조타입은 Object, Array, date, error를 포함
- 타입 확인 방법으로는 typeof연산자가 있다.(null은 원시타입이지 만 typof연산자에서 object를 반환)



![20210304_111610](/assets/20210304_111610.png)

![20210304_111625](/assets/20210304_111625.png)

js에서 돔 부분은 매우 중요하니까 꼭 알아두고 가자.

###함수
- 자바스크립트에서 함수는 일급(first-class)객체이다
- 함수는 변수나 객체나 배열에 저장 가능, 다른 함수에 전달하는 전달인자(콜백함수) 또는 리턴값으로 사용 가능
- 함수는 프로그램 실행 중에 동적으로 생성 가능
- 함수 정의 방법은 함수선언문, 함수 표현식, Function 생성자(constructor)함수 세가지 방식 제공.


변수의 호이스팅은 아래에 var로 선언해도 맨앞으로 자동이동해서 undefined으로 초기화 했던거.

함수도 호이스팅이 있다.

####함수 호이스팅은
- 함수도 내부적으로 호이스팅이 일어난다.

- 함수 선언문의 경우 함수 선언의 위치와 상관 없이 코드 내 어느곳에서든지 호출이 가능
- 자바스크립트는 모든 선언(var, function)을 호이스팅함
- 함수선언문으로 정의된 함수는 자바스크립트 엔진이 스크립트가 로딩되는 시점에 이를 변수객체 저장한다. 함수선언, 초기호 ㅏ , 할당이 한번에 이뤄진다.

- 함수 표현식의경우 함수 호이스팅이 아니라 변수 호이스팅이 발생

![20210304_112234](/assets/20210304_112234.png)

##### 함수 선언문으로 함수 정의시 사용하기 쉽지만 대규모 어플을 개발시 인터프리터가 너무 많은 코드를 변수 객체에 저장하므로 어플리케이션의 응답속도를 저하시킬 수 있다.


###매개변수

- 함수의 정의 부분에 외부로부터 전달 받을 변수를 매개변수(parameter)라 함.
- 함수를 호출시 전달하는 값을 전달인자(argument)라고 함
- javascript에서 함수 정의시 매개변수에 대한 타입은 명시하지 않는다.
- 함수를 호출시 정의된 매개변수와 전달 인자의 개수가 일치하지 않더라도 호출 가능.

자바스크립트는 함수형 언어라 개념잡기가 힘들다..


### 콜백함수

- 콜백함수는 함수를 명시적으로 호출하는게 아니라 특정 이벤트가 발생시 시스템에 의해 호출되는 함수를 말함.( ex. addActionLister 같은거)

- 일반적으로 콜백함수는 매개변수를 통해 전달되고 전달받은 함수의 내부에서 어느 특정시점에 실행됨.
- 콜백함수는 주로 비동기 식 처리모델에서 사용 됨. >> 처리가 종료되면 호출될 함수(콜백함수)ㄹ,ㄹ 미리 매개변수에 전달하고 처리가 종료되면 콜백함수를 호출

저걸 누르면 actionperform 이런걸 내부적으로 실행하고 그 안에 구현된 함수가 있을 거.
근데 우리는 이런 함수를 구현하거나 호출한 적이 없음.
addActionLister 가 감시하다 이 버튼이 눌려지는 순간 내부적으로 버츄어머신이 알려줌. 호출해야 되는 메서드가 어디 있다고 그럼 이클립스 안에 내부적으로 구현된 메서드를 호출.

내부적으로 시스템에 의해 호출됨.

감시하다 어느 시점에 딱 실행.


이러한 방식은 비동기 처리인 ajax에 가서 실행 많이 됨.


![20210304_113256](/assets/20210304_113256.png)

이벤트 핸들러의 경우를 예로 들면
위의 버튼 가져와서 클릭 언제하는지 감시. 어느순간 클릭하면 그 밑의 함수 실행
클릭하는 시점에서 리스너가 감시하다 함수 호출.
이런걸 콜백함수라 표현.

#####여기까지가 가장 기본적인 자바스크립트의 문법.
-------
