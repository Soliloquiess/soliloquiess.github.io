---
title: "[front] Web 개발 중 그냥 필요한거 개인 정리"
layout: post
subtitle: front
date: "2022-08-12 19:45:51 +0900"

categories: class
tags: Front
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---

- label 태그 입력하는 거 아주 중요(html)
- CSS는 캐스캐이딩 스타일
  - 프로그래밍 언어는 아니지만 시각적으로 표현하기 위해 사용
  - Cascading은 선택자에 적용된 많은 스타일 중에 어떤 스타일로 브라우저에 표현할지 결정해주는 원리

![20221224_165312](https://user-images.githubusercontent.com/37941513/209426648-ba625242-2270-4709-9f12-59fdc49a2b44.png)

L 후손선택자 R 자식선택자

- 자식, 자손 선택자

1. 후손선택자 = 자손선택자 = 하위선택자

- 자식을 포함하는 의미 = 계층구조에서 하위에 오는 모든 자손선택

- 선택자 : 공백(스페이스바 한번)

→ 사진이 의미하는 것 : #container ul

2. 자식선택자

- 앞 요소의 자식인 뒷요소를 선택 = 직계 자식만을 선택

- 선택자 : >

→ 사진이 의미하는 것 : #container > ul

![20221224_165353](https://user-images.githubusercontent.com/37941513/209426656-fa5ff7ea-f5ed-4450-8862-f11c5b069291.png)

3. 동위선택자 = 형제선택자

- 같은 부모를 가진 요소들 = 계층구조에서 요소 바로 다음에 오는 요소선택

- 선택자 : +, ~

- 인접형제선택자(+) : 앞의 요소 바로 뒤에 있는 요소만선택

→ 사진이 의미하는 것 : p + ul

- 일반형제선택자(~) : 앞요소 뒤에 있는 모든 요소를 선택

→ 사진이 의미하는 것 : p ~ ul

- 참조 : https://chpofo.tistory.com/26

  - https://developer.mozilla.org/ko/docs/Web/CSS/Child_combinator

- 인접 선택자 ('+') 사용
- 직계자손 선택자 ('>') 사용

속성 선택자

```
- input[type="password"]
```

이런식으로 쓰임 password에 대한 부분만 잡고 사용
속성 선택자에선 = 를 대신 쓰기도 한다.

유사 클래스

가상 클래스는 선택자 끝에 붙여 상태를 특정하는 키워드

이것으로 체크박스나 선택요소등 선택. 그중 5번째나 10번쨰나 이런식으로만 특정해서 가져오기도 가능.

- https://developer.mozilla.org/ko/docs/Web/CSS/Pseudo-classes

- https://www.w3schools.com/css/css_pseudo_classes.asp

인라인 스타일

- id, class 보다 더 명시적임
- 이걸 쓰거나 추천하는 사람은 거의 없으나 알아두긴 하자

- !important같은게 있는데 이런걸 최대한 안 쓰는게 좋다. 있긴 하지만 안 쓰는걸 최대한 지향

CSS 상속

- CSS 속성 뒤에 :inherit을 붙임

패딩과 마진의 차이

- 패딩 : 콘텐츠와 테두리간의 간격
- 마진 : 한 요소와 다른 요소의 각 테두리 간 간격

디스플레이 속성

- 인라인
- 블록
- 인라인 블록

inline vs block vs inline-block 속성을 비교해보자.
display: inline ?
대표적인 태그로는 span을 예로 들 수 있는데, text 크기만큼만 공간을 점유하고 줄바꿈을 하지 않는다.

width/height 적용불가
margin/padding-top/bottom 적용불가
line-height를 원하는대로 사용할 수 없다.
display: block ?
block 속성은 무조건 한줄을 점유하고 있고, 다음 태그는 무조건 줄바꿈이 적용된다. 대표적인 태그는 div가 있다.

display: inline-block ?
inline-block 속성은 inline 속성의 특징과 block 속성의 특징 둘 다 가지고 있는 속성이다. 기본적인 특징은 inline 속성과 비슷한데 (줄바꿈을 하지 않고, 동일한 라인에 작성가능) inline속성에서 할 수 없었던 width/height 변경 및 line-height를 커스텀하게 적용할 수 있는 특징이 있다.

width/height 적용 가능
margin/padding-top/bottom 적용 가능
line-height 적용 가능
\*\* 고려사항

inline-block 사이에 공백이 생기게 되는데, parent 태그에 font-size: 0를 적용하면 해결된다.
inline-block 끼리 높이가 안맞을 때 상위 공백이 생기게 되는데 vertical-align: top을 적용하면 해결할 수 있다.

인라인 블록은 여백, 패딩, 가로, 세로와 함꼐 가능

- 참고 : https://ruden91.github.io/blog/inline-vs-block-vs-inline-block/

px em rem 차이

- em : px과 달리 글꼴 크기에 따라 자동으로 크기 바뀜
  - em의 단점: 단계별로 누적이 된다

em vs. rem 차이 : 변환되는 기준이 다름
em과 rem은 가변단위로서 브라우저 환경에서 px로 변환됩니다.

em은 같은 엘리먼트에서 지정된 font-size를 기준으로 px로 바뀌어 화면에 표시됩니다. 같은 엘리먼트에 설정된 폰트 크기 값이 없을 경우, 상위 요소의 폰트 사이즈가 기준이 됩니다.

div {
font-size: 10px;
}
div {
font-size : 1em; /_1em 대략 10px_/
}

rem은 최상위 엘리먼트에서 지정된 font-size의 값을 기준으로 변환됩니다. 대개는 HTML tag에서 지정된 font-size가 기준이 됩니다. 만약 별도의 font-size를 설정하지 않은 경우에는 각 브라우저에서 기본적으로 설정된 값을 상속 받습니다.

html {
font-size : 10px; /_설정 안했을 때는 브라우저 기본 값으로 _/
}
div {
margin: 1.5em; /_대략 15px_/
}

=> rem은 기준이 되는 폰트 크기 하나로 고정되어 있는 반면, em은 같은 엘리먼트는 어디서라도 그 기준이 바뀔 수 있기 때문에 복잡한 css를 가질 경우 변환될 크기를 예측하기 어렵다는 단점이 있습니다.

참고 : https://monkeydeveloper.tistory.com/entry/CSS-px-em-rem-%EC%B0%A8%EC%9D%B4%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90

```
img {
    width: 30%;
    /* margin: 1.6666666%; */ /* 백분율로 이미지 크기 변환*/
    margin: calc(10%/6);
        /* 10%가 남았다는 뜻 */
}

nav {
    font-family: 'Raleway', sans-serif;
    font-size: 1.5em;
    text-transform: uppercase;
    border-bottom: 2px solid #f1f1f1;
    width: 30%;
    margin-left: calc(10%/6);
    padding: 1.2em 0;
}

```

/\* 30 + 30 + 30

10% \*/

미디어 쿼리

- 미디어가 웹에서 많이 쓰임에 따라 등장한 csss 개념

참고 : https://developer.mozilla.org/ko/docs/Learn/CSS/CSS_layout/Media_queries

---

### Javascript

js

Null과 undefined의 차이

undefined은 변수를 선언하고 값을 할당하지 않은 상태, null은 변수를 선언하고 빈 값을 할당한 상태(빈 객체)이다.

즉, undefined는 자료형이 없는 상태이다.
따라서 typeof를 통해 자료형을 확인해보면 null은 object로, undefined는 undefined가 출력되는 것을 확인할 수 있다.

null은 원시값(Primitive Type) 중 하나로, 어떤 값이 의도적으로 비어있음을 표현한다.

undefined는 값이 지정되지 않은 경우를 의미하지만, null의 경우에는 해당 변수가 어떤 객체도 가리키고 있지 않다는 것을 의미한다.

#### Truthy and Falsy

자바스크립트의 모든 값은 다음 경우 제외하고는 다 Truthy다

- false
- 0
- ""(빈 문자열)
- null
- undefined
- NAN

---

#### push, pop, shift, unshift

- push: 스택 배열 맨 뒤 넣는거
- pop : 스택 큐 맨 앞부터 뺴는거
- shift : 배열 스택 큐 맨앞부터 제거
- unshift : 배열 스택 큐 맨 뒤부터 제거

---

#### 유용한 메서드들

concat - 어레이 합치기(문자열도)
includes - 값이 있는지 확인. indexof와 비슷한데 이건 불리언값(true,false로 반환)
indexOf - 문자열 안에 해당 값이 있는지 확있 있으면 그 인덱스를 리턴 없으면 -1 리턴
join - 배열 안 중 문자열을 합친다.
reverse - 배열 역순 출력
slice - 배열 중 해당 부분만 잘라서 가져옴
splice - 해당 요소 부분 해서 제거함

```

colors.splice(5,1) :그럼 5번쨰 인덱스부터 1개가 제거

colors.splice(5,1, orange): 5번쨰 인덱스 하나를 orange로 바꾸기도 가능

```

- slice는 원본 배열을 수정하지 않고 새로운 배열을 만드는 것과 다르게 splice는 원본 배열 자체를 수정

sort - 배열 정렬

근데 sort가 약간 이상함

-12, 70 100 2500 34 이렇게 있으면

-12 100 2500 34 로 정렬(맨 앞자리 기준)
쓸만한 정렬방식은 아님

sort 쓸떄 이런걸 주의해야 함

오름차순이나 내림차순 정렬이나 특정 부분만 해서 정렬도 가능

---

자바스크립트에서

[1,2,3] == [1,2,3] 은 true지만
[1,2,3] === [1,2,3] 은 false.
참조하는 메모리가 다르기 떄문

---

자바스크립트 객체에서 {} 를(중괄호) 쓰는 건 객체를 선언할 떄 뿐(만들 때 뿐)

해당 데이터 접근하려면 대괄호 써야[]

```
person= {firstName:"Mick",lastName : "jagger"}

person["lastName"]
-> "jagger"
```
