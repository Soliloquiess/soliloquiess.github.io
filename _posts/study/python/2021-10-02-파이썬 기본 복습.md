---
title: "[python] python Learn"
layout: post
subtitle: Python
date: '2021-06-02 19:45:51 +0900'

categories: study
tags: Python
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---



#### 배열(Array), List(Python)

### 1. 배열은 왜 필요할까?
- 같은 종류의 데이터를 효율적으로 관리하기 위해 사용
- 같은 종류의 데이터를 순차적으로 저장
- 장점:
  - 빠른 접근 가능
    - 첫 데이터의 위치에서 상대적인 위치로 데이터 접근(인덱스 번호로 접근)
- 단점:
  - 데이터 추가/삭제의 어려움
    - 미리 최대 길이를 지정해야 함

- 파이썬에서는 리스트로 배열 구현 가능


* range(stop): range(10)은 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
* range(start, stop): range(1, 11)은 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
* range(start, stop, step): range(0, 20, 2)은 0, 2, 4, 6, 8, 10, 12, 14, 16, 18
  - start, stop, step은 음수로 지정 가능


-----

#### 큐(Queue)

* 줄을 서는 행위와 유사
* 가장 먼저 넣은 데이터를 가장 먼저 꺼낼 수 있는 구조
  - 음식점에서 가장 먼저 줄을 선 사람이 제일 먼저 음식점에 입장하는 것과 동일
  - FIFO(First-In, First-Out) 또는 LILO(Last-In, Last-Out) 방식으로 스택과 꺼내는 순서가 반대

<img src="https://www.fun-coding.org/00_Images/queue.png" />
* 출처: http://www.stoimen.com/blog/2012/06/05/computer-algorithms-stack-and-queue-data-structure/



* Enqueue: 큐에 데이터를 넣는 기능
* Dequeue: 큐에서 데이터를 꺼내는 기능
* https://visualgo.net/en/list





###### 어디에 큐가 많이 쓰일까?

- 멀티 태스킹을 위한 프로세스 스케쥴링 방식을 구현하기 위해 많이 사용됨 (운영체제 참조)
> 이건 알아두고 가야 한다.

> 큐의 경우에는 장단점 보다는 (특별히 언급되는 장단점이 없음), 큐의 활용 예로 프로세스 스케쥴링 방식을 함께 이해해두는 것이 좋음



--------


##### 스택(Stack)
* 데이터를 제한적으로 접근할 수 있는 구조
  - 한쪽 끝에서만 자료를 넣거나 뺄 수 있는 구조
* 가장 나중에 쌓은 데이터를 가장 먼저 빼낼 수 있는 데이터 구조
  - 큐: FIFO 정책
  - 스택: LIFO 정책



##### 스택 구조
  * 스택은 LIFO(Last In, Fisrt Out) 또는 FILO(First In, Last Out) 데이터 관리 방식을 따름
    - LIFO: 마지막에 넣은 데이터를 가장 먼저 추출하는 데이터 관리 정책
    - FILO: 처음에 넣은 데이터를 가장 마지막에 추출하는 데이터 관리 정책

  * 대표적인 스택의 활용
    - 컴퓨터 내부의 프로세스 구조의 함수 동작 방식

  * 주요 기능
    - push(): 데이터를 스택에 넣기
    - pop(): 데이터를 스택에서 꺼내기

  <img src="http://www.fun-coding.org/00_Images/stack.png" />


-------


#### 스택 구조와 프로세스 스택
- 스택 구조는 프로세스 실행 구조의 가장 기본
  - 함수 호출시 프로세스 실행 구조를 스택과 비교해서 이해 필요




#### 자료 구조 스택의 장단점
  - 장점
    - 구조가 단순해서, 구현이 쉽다.
    - 데이터 저장/읽기 속도가 빠르다.
  - 단점 (일반적인 스택 구현시)
    - 데이터 최대 갯수를 미리 정해야 한다.
      - 파이썬의 경우 재귀 함수는 1000번까지만 호출이 가능함
    - 저장 공간의 낭비가 발생할 수 있음
      - 미리 최대 갯수만큼 저장 공간을 확보해야 함

  > 스택은 단순하고 빠른 성능을 위해 사용되므로, 보통 배열 구조를 활용해서 구현하는 것이 일반적임.
  > 이 경우, 위에서 열거한 단점이 있을 수 있음


----------


#### 링크드 리스트(Linked List)

* 연결 리스트라고도 함
* 배열은 순차적으로 연결된 공간에 데이터를 나열하는 데이터 구조(배열 문제 해결하기 위해 나온게 링크드 리스트. 배열은 미리 특정한 연결된 공간을 예약하고 데이터를 쓰고있는 구조, 링크드 리스트는 미리 예약 안하고 필요할 때마다 데이터를 더 추가하는 구조이다. )
* 링크드 리스트는 떨어진 곳에 존재하는 데이터를 화살표로 연결해서 관리하는 데이터 구조
* <font color='#BF360C'>본래 C언어에서는 주요한 데이터 구조이지만, 파이썬은 리스트 타입이 링크드 리스트의 기능을 모두 지원</font>


* 링크드 리스트 기본 구조와 용어
  - 노드(Node): 데이터 저장 단위 (데이터값, 포인터) 로 구성
  - 포인터(pointer): 각 노드 안에서, 다음이나 이전의 노드와의 연결 정보를 가지고 있는 공간

<br>
* 일반적인 링크드 리스트 형태
<img src="https://www.fun-coding.org/00_Images/linkedlist.png" />
(출처: wikipedia, https://en.wikipedia.org/wiki/Linked_list)


##### Node 구현
- 보통 파이썬에서 링크드 리스트 구현시, 파이썬 클래스를 활용함
  - 파이썬 객체지향 문법 이해 필요


#### 배열과 링크드 리스트 차이

배열은 만약 그림처럼 A,B를 가진 배열에 C를 넣을 수가 없다.(A,B가 가지고 있기 떄문. 파이썬은 append이든 뭐든 될지 몰라도 만약 C나 자바처럼 배열크기가 정해지면 범위를 초과해서 넣을 수가 없다.)

링크드리스트는 어느 공간이던 노드 저장할 공간 만들고 그 앞에 새로운 데이터를 넣고 앞의 데이터가 새로생성된 노드를 가리키도록 주소가 가리키게만 만들면 된다.


![20211002_183124](/assets/20211002_183124.png)

링크드 리스트는 이런 구조라 무한정으로 뻗어나갈 수 가있다.

#### 링크드 리스트의 장단점 (전통적인 C언어에서의 배열과 링크드 리스트)
  * 장점
    - 미리 데이터 공간을 미리 할당하지 않아도 됨
      - 배열은 **미리 데이터 공간을 할당** 해야 함
  * 단점
    - 연결을 위한 별도 데이터 공간이 필요하므로, 저장공간 효율이 높지 않음
    - 연결 정보를 찾는 시간이 필요하므로 접근 속도가 느림
    - 중간 데이터 삭제시, 앞뒤 데이터의 연결을 재구성해야 하는 부가적인 작업 필요


#####  링크드 리스트의 복잡한 기능1 (링크드 리스트 데이터 사이에 데이터를 추가)

- 링크드 리스트는 유지 관리에 부가적인 구현이 필요함


<img src="https://www.fun-coding.org/00_Images/linkedlistadd.png" />

(출처: wikipedia, https://en.wikipedia.org/wiki/Linked_list)


##### 링크드 리스트의 복잡한 기능2 (특정 노드를 삭제)

![20211002_183231](/assets/20211002_183231.png)

링크드 리스트는 맨앞 노드를 꼭 가져야 하고 그걸 헤드라 하기로 했다.
삭제하려면 헤드가 다음 노드로 바뀌어야 한다 C라는 거 삭제하려면(맨 마지막 노드) 그냥 없애면 되지만 그 앞의 노드의 주소값을 null, 또는 none으로 바꿔줘야 한다.

중간노드삭제는 B를 없애고 C로 A의 노드 주소값을 바꿔줘야한다.

* 다음 코드는 위의 코드에서 delete 메서드만 추가한 것이므로 해당 메서드만 확인하면 됨

----


##### 다양한 링크드 리스트 구조
* 더블 링크드 리스트(Doubly linked list) 기본 구조
  - 이중 연결 리스트라고도 함
  - 장점: 양방향으로 연결되어 있어서 노드 탐색이 양쪽으로 모두 가능



  <br>
<img src="https://www.fun-coding.org/00_Images/doublelinkedlist.png" />
(출처: wikipedia, https://en.wikipedia.org/wiki/Linked_list)


노드 찾고 연결할떄 반드 노드가 3개라 가정시 마지막 데이터든 어느곳이든 반드시 헤드데이터 찾고 원하는 데이터로 이동해야 한다.

노드가 1만개라 생각해보자 맨 끝에 있으면 1만번을 검색해야한다.

이 만개의 노드가 0~9999까지 있다 가정시 8000번대에 있다 가정하고 소트정렬 하면 8천번인데 8000이 끝에서 가까우니까 8000번은 2000번 정도만 하면 가능하다.

찾고자 하는 위치에 따라 앞에서 검색해서 찾든 뒤에서부터 검색해서 찾든 찾는 곳의 위치를 알수 있고 이렇게 적용해서 찾고 싶다 -> 그래서 나온게 LinkedList다.



![20211002_182417](/assets/20211002_182417.png)

더블 링크드 리스트는 노드의 구조가 좀 다르다.

기존의 일반 링크드리스트의 구조는 데이터와 다음 노드 가리키는 주소 갖는 반면에 더블 링크드리스트는 그 앞의 구조를 저장할수 있게 만든다.

앞의 구조를 갖게 되면 맨끝에서 앞으로 , 또는 반대로 맨 뒤에서 맨 앞으로 찾아갈 수도 있다.

기존의 링크드리스트 관점인 앞에서부터 검색해야된다는 점을 보완한 점이 더블 링크드 리스트이다.

노드는 앞뒤로 주소 갖고 있다.


----


#### 시간복잡도

##### 알고리즘 복잡도 표현 방법



##### 알고리즘 복잡도 계산이 필요한 이유
###### 하나의 문제를 푸는 알고리즘은 다양할 수 있음
  - 정수의 절대값 구하기
    - 1, -1 ->> 1
    - 방법1: 정수값을 제곱한 값에 다시 루트를 씌우기
    - 방법2: 정수가 음수인지 확인해서, 음수일 때만, -1을 곱하기

> 다양한 알고리즘 중 어느 알고리즘이 더 좋은지를 분석하기 위해, 복잡도를 정의하고 계산함



##### 알고리즘 복잡도 계산 항목
1. **시간 복잡도**: 알고리즘 실행 속도
2. **공간 복잡도**: 알고리즘이 사용하는 메모리 사이즈

> 가장 중요한 시간 복잡도를 꼭 이해하고 계산할 수 있어야 함

-> 시간복잡도는 반복문이 가장 큰 영향을 끼친다.
입력이 커질수록 반복문이 알고리즘 수행시간에 큰 영향을 끼친다.




##### 알고리즘 성능 표기법
- Big O (빅-오) 표기법: O(N)
  - 알고리즘 최악의 실행 시간을 표기
  - **가장 많이/일반적으로 사용함**
  - **아무리 최악의 상황이라도, 이정도의 성능은 보장한다는 의미이기 때문**

- Ω (오메가) 표기법:  Ω(N)
  - 오메가 표기법은 알고리즘 최상의 실행 시간을 표기

- Θ (세타) 표기법: Θ(N)
  - 오메가 표기법은 알고리즘 평균 실행 시간을 표기

> 시간 복잡도 계산은 반복문이 핵심 요소임을 인지하고, 계산 표기는 최상, 평균, 최악 중, 최악의 시간인 Big-O 표기법을 중심으로 익히면 됨




###### 대문자 O 표기법
* 빅 오 표기법, Big-O 표기법 이라고도 부름
* O(입력)
  - 입력 n 에 따라 결정되는 시간 복잡도 함수
  - O(1), O($log n$), O(n), O(n$log n$), O($n^2$), O($2^n$), O(n!)등으로 표기함
  - 입력 n 의 크기에 따라 기하급수적으로 시간 복잡도가 늘어날 수 있음
    - O(1) < O($log n$) < O(n) < O(n$log n$) < O($n^2$) < O($2^n$) < O(n!)
      - 참고: log n 의 베이스는 2 - $log_2 n$

* 단순하게 입력 n에 따라, 몇번 실행이 되는지를 계산하면 됩니다.
  - **표현식에 가장 큰 영향을 미치는 n 의 단위로 표기합니다.**
  - n이 1이든 100이든, 1000이든, 10000이든 실행을
    - 무조건 2회(상수회) 실행한다: O(1)
       ```python
            if n > 10:
                 print(n)
       ```
    - n에 따라, n번, n + 10 번, 또는 3n + 10 번등 실행한다: O(n)
     ```python
            variable = 1
            for num in range(3):
                for index in range(n):
                     print(index)
       ```
    - n에 따라, $n^2$번, $n^2$ + 1000 번, 100$n^2$ - 100, 또는 300$n^2$ + 1번등 실행한다: O($n^2$)
       ```python
            variable = 1
            for i in range(300):
                for num in range(n):
                    for index in range(n):
                         print(index)
       ```    


<img src="http://www.fun-coding.org/00_Images/bigo.png" width=400/>

* 빅 오 입력값 표기 방법
  - 예:
    - 만약 시간 복잡도 함수가 2$n^2$ + 3n 이라면
      - 가장 높은 차수는 2$n^2$
      - 상수는 실제 큰 영향이 없음
      - 결국 빅 오 표기법으로는 O($n^2$) (서울부터 부산까지 가는 자동차의 예를 상기)




-------


#### 해쉬테이블(Hash Table)
###### 해쉬 구조
* Hash Table: 키(Key)에 데이터(Value)를 저장하는 데이터 구조
  - Key를 통해 바로 데이터를 받아올 수 있으므로, 속도가 획기적으로 빨라짐
  - 파이썬 딕셔너리(Dictionary) 타입이 해쉬 테이블의 예: Key를 가지고 바로 데이터(Value)를 꺼냄
  - 보통 배열로 미리 Hash Table 사이즈만큼 생성 후에 사용 (공간과 탐색 시간을 맞바꾸는 기법)
  - <font color='#BF360C'>단, 파이썬에서는 해쉬를 별도 구현할 이유가 없음 - 딕셔너리 타입을 사용하면 됨</font>


![20211002_222528](/assets/20211002_222528.png)

배열과 차이는 배열은 인덱스 위치 한거 하나하나 찾아야 하지만(16번) 해쉬 테이블은 이 트럼프라는 데이터가 어디있는지 알수 있어 곧바로 데이터를 찾아올 수 있다.
###### key를 해쉬함수에 넣으면 데이터가 저장되있는 위치가 나온다.

배열을 다 검색할 필요없이 데이터가 저장된 위치를 알아낼 수 있다. 그런 구조를 해쉬테이블 구조라 한다.

###### 파이썬에서도 딕셔너리를 쓰는데 이게 해쉬함수를 이용한 자료구조이다.


###### 관련 용어
  * 해쉬(Hash): 임의 값을 고정 길이로 변환하는 것
  * 해쉬 테이블(Hash Table): 키 값의 연산에 의해 직접 접근이 가능한 데이터 구조
  * 해싱 함수(Hashing Function): Key에 대해 산술 연산을 이용해 데이터 위치를 찾을 수 있는 함수
  * 해쉬 값(Hash Value) 또는 해쉬 주소(Hash Address): Key를 해싱 함수로 연산해서, 해쉬 값을 알아내고, 이를 기반으로 해쉬 테이블에서 해당 Key에 대한 데이터 위치를 일관성있게 찾을 수 있음
  * 슬롯(Slot): 한 개의 데이터를 저장할 수 있는 공간
  * 저장할 데이터에 대해 Key를 추출할 수 있는 별도 함수도 존재할 수 있음
  <img src="https://www.fun-coding.org/00_Images/hash.png" width=400 />



###### 키에 해시함수를 넣으면 특별한 주소가 나오는데 이 주소와 데이터 공간이 연결되어있다. 이 구조를 해시테이블이라 한다.


다시 보면


![20211002_224111](/assets/20211002_224111.png)

각각 키를 추출할 수 있게끔 하고 해쉬함수를 만들면 해쉬 테이블 특정 슬롯에 저장하는 셈이 된다.

이걸 배열로 만들면?

일일이 하나씩 모든 인덱스 배열을 다 탐색해야 한다.
만약 트럼프면 맨 뒤까지 검색해야.

반면 해쉬함수는 해쉬함수 한번만 돌리면 바로 알아낼 수 있다.

해쉬테이블이라는 구조가 그래서 검색시 굉장히 많이 쓰일 수 있다.
