---
title: "[C] C lang 포인터"
layout: post
subtitle: C
date: "2022-02-25-04:42:51 +0900"

categories: study
tags: C
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---

### 포인터

![20221012_132409](https://user-images.githubusercontent.com/37941513/195249628-8af2f0d8-c9a3-4617-83ec-84dc8bbc9004.png)



우리가 알던 메모리 저장 과정


나도 주소를 사용해서 메모리에 있는 내 변수에 접근이 가능한가?



<br>


-----

#### 다른 언어였다면 얼토당토 않은 일

- 그러나 C는 하드웨어와 가장 친한 친구
- 그러므로 가능함
- 그리고 이걸 잘 쓰면 매우 강력한 일도 가능함(사고 치는 거도 가능하고..)


<br>


-----



### 주소 연산자 &

#### 지역변수 주소 출력하기

```
#include <stdio.h>

void print_address(void)
{
  int num =10;
  printf("Address of num : %p\n",(void *) &num);
}

int main(void)
{
  print_address();
  return 0;
}

```


![20221012_135710](https://user-images.githubusercontent.com/37941513/195253750-11e11d05-eb64-4072-a58d-9df04f33e5d2.png)


<br>


-------


#### 주소 연산자 &

- 비트 연산자 &가 아님.

  - 비트 연산자는 피연산자가 2개, 주소 연산자는 피연산자가 1개

    ```
    const unsigned char result = num1 & num2; /* 비트연산자 */
    printf("address of num %p\n", (void*) &num);  /* 주소 연산자 */
    ```
- num 이라는 변수가 있으면 그 &num은 그 변수가 위치한 메모리 주소

![20221012_140629](https://user-images.githubusercontent.com/37941513/195254835-a57289ab-d660-4443-8c1a-819ebabcb457.png)



<br>


- 보통 주소 보여줄 떄는 16진수를 사용
- 읽기 편하기 때문
  - 그래서 printf()에서 서식문자 %p는 주소를 16진수로 보여줌

- 참고: 실행할 때마다 주소가 달라질 수 있음
  - 요즘 운영체제는 보안 강화를 위해 실행시마다 주소를 바꿔줌(ASLR)

  ![20221012_140957](https://user-images.githubusercontent.com/37941513/195255258-3a0392f5-acf5-46a0-a8db-2a79695ce694.png)


<br>

-----


### 메모리 주소 저장하기

#### 근데 이건 어떻게 쓰나?

- 주소를 구할 때 마다 그 변수가 필요하면 그냥 그 변수를 쓰지
- 그 보다는 그  주소를 어딘가에 저장하면 좋을텐데
- 그러면 변수가 없어도 주소만으로 여기저기 옮겨다닐 수 있음
  - 가령 '변수의 주소' 다음 메모리 위치를 읽는다던가..


#### 혹시 메모리 주소를 저장할 수 있는가?

- 어떤 데이터를 저장 시 쓰는 건 -> 변수
  - 숫자, 문자 다 변수에 저장하는데?

- 그럼 메모리 주소도 변수에 저장할 수 있지 않을 까?

- 메모리 주소도 숫자긴 함.(조금 큰 수)

![20221012_142820](https://user-images.githubusercontent.com/37941513/195257582-dc2905c2-5b1b-47ec-a756-a728ee527d9f.png)


#### 주소 저장해보자

```
void try_save_address(void)
{
  int num =10;
  int num_address = &num;
}
```



 컴파일 하니까 오류나는데? 포인터를 저수로 반환하는게 에러남.
 또 int에 별표달렸네? 여기보면 또 뭐가 쭉 나옴. 아 안되네

 ![20221012_143359](https://user-images.githubusercontent.com/37941513/195258368-6dd80d87-0abd-4330-bf2f-a30d58cd5b81.png)


#### 만약 이게 되도 문제

이 중 어떤게 주소고 어떤게 값?

```
void play_game(void)
{
  int a = 202020;
  int b = 212121;
}
```

- 이러면 정말 헷갈릴듯.
- 따라서 주소 저장하기 위한 ***특별한 변수*** 가 있어야 함.

-> 그 특별한 변수가 **포인터** 이다.

<br>

----

###  포인터의 의미

- 주소를 저장하기 위한 변수형
- 이건 외워햐한다 -> 변수인데 속에 담긴 내용은 메모리 주소
- 다른데선 뭘 가리키고 어쩌고 설명하는데 이렇게 외우면 더 헷갈리게 된다.


#### 결국 포인터는 메모리를 저장하는 변수


<br>


-----

#### 그 주소에 저장된 자료형은?

- 사실 하드웨어는 신경 안 씀
  - 그 비트패턴을 char로 읽으면 char고
  - int로 읽으면 int고,
  - float으로 읽으면 float이 됨

- 예 : 주소 0x100으로 접근시 'char'로 읽는다면

![20221012_154446](https://user-images.githubusercontent.com/37941513/195269502-ab431526-ea08-401d-8632-c659fd5f291e.png)


- 그러나 해당 주소에서 부터 몇 바이트를 읽어야 하는지는 하드웨어에 알려줄 필요가 있음.
- 그래서 포인터 변수 선언 시에는 ' 그 주소에 어떤 형의 데이터가 있는지 ' 명시하기 위해 포인터 앞에 자료형을 붙임
  - int 포인터, float포인터, char 포인터..


####   포인터 변수를 선언하는 방법

```
void save_address(void){
  int num = 10;
  int * num_address = &num;
}
```


포인터 변수 선언하려면 자료형 뒤에 *를 붙임
  int * char * float *


![20221012_155139](https://user-images.githubusercontent.com/37941513/195270729-21fadc12-b3a2-4bea-9e61-84692b1305a1.png)



#### 코딩 표준: 자료형에 *를 붙인다

- int *address로 쓰는 경우도 있음
- 우리의 코딩 표준은 int * address;

위 둘다 같은거.

<br>

----------


### 포인터 변수를 부르는 법.


```
void save_address(void){
  int num = 10;
  int * num_address = &num;
}
```

- 보통 num_address를 int 포인터라고 부름
- 근데 영어로는 int로의 포인터(pointer to an int)라고도 함
- 포인터는 읽을 떄 오른쪽에서 왼쪽으로 읽음. 다른건 왼쪽에서 오른쪽에서
- 포인터는 **메모리를 저장하는 변수** 라고 했다.
- 이 변수는 메모리 어딘가에 저장되어 있다.
- 따라서 아래 예처럼 되어 있음

![20221012_183852](https://user-images.githubusercontent.com/37941513/195308140-8eb1fd6d-0a0d-4f68-8a26-224b1706673b.png)

- 이처럼 다른 위치를 가리키는 변수라 해서 **포인터**라고 함.

<br>

- 근데 이렇게 기억하면 **이중 포인터** 나올 때 헷갈릴 수 있음
- 따라서 기본 개념은 ***메모리 주소를 저장하는 변수*** 라 기억하고 가끔 시각적으로 필요하면 그려볼 것
- 처음엔 잘 이해 안되니 그려보면서 하는게 좋다.
- 눈으로만 보면 헷갈리게 됨

<br>

---------


### 포인터 변수의 실제 메모리 뷰

#### 실제 메모리


![20221012_191625](https://user-images.githubusercontent.com/37941513/195317002-cb40c24e-aec9-4561-b696-746ec1d41591.png)



- num이라는 변수의 주소, num_address 안에는 뭐가 들어가 있나. -> num의 주소가 들어가 있다.




- 잠깐 복습하면 **데이터가 끝나는 마지막 단위가 가장 작은 메모리 주소**에 위치하는 저장순서를 리틀 엔디언이라 했다.


![20221012_192253](https://user-images.githubusercontent.com/37941513/195318367-803063aa-4ee3-45b1-b380-36e2231a5ee4.png)



<br>

--------



#### 다른 포인터 예 : char 포인터

```
void create_char_pointer(void){
  char ch = 'c'; /* 주소 : 0x007EF7D3
  char * ch_pointer = &ch;  /* 저장된 값 : 0x007EF7D3
}
```


![20221012_193611](https://user-images.githubusercontent.com/37941513/195321131-c8506563-4e78-4bca-bc8e-39f240a65d78.png)


cc에서 4바이트 더하면 D0이 되고 1,2,3, 더하면 D3이 된다.


#### 다른 포인터 예 : short 포인터

```
void create_short_pointer(void){
  short num = 2154; // 주소: 0x00F3FE36
  short * num_pointer = &num; //  저장된 값 : 0x00F3FE36
}
```

![20221012_194051](https://user-images.githubusercontent.com/37941513/195322400-1e3a9879-66fe-4bea-a54e-cd6ea2567a42.png)


<br>



------


#### 다른 포인터 예 : float 포인터

```
void create_float_pointer(void){
  float num = 2154; // 주소: 0x012FF7F8
  float * num_pointer = &num; // 저장된 값 : 0x012FF7F8
}
```

![20221012_200929](https://user-images.githubusercontent.com/37941513/195327587-e556da83-4192-4f1d-a10e-8f487bf6e4f7.png)



<br>

------



#### 다른 포인터 예 : double 포인터

```
void create_double_pointer(void){
  double num = 2154; // 주소: 0x005DF9D8
  double * num_pointer = &num; // 저장된 값 : 0x005DF9D8
}
```

![20221012_201049](https://user-images.githubusercontent.com/37941513/195327883-17a822e2-3d66-4f38-9a70-59a726e706e0.png)




<br>

-------

###   포인터에 저장된 주소도 바꿀 수 있나?

- 물론, 가능
- 포인터도 변수(중요하니까 반복)
- 따라서 포인터에 저장한 값도 변경 가능
- 즉, 다른 주소로 바꿀 수 있음.


![20221012_202525](https://user-images.githubusercontent.com/37941513/195330700-3ace829e-4bd1-48b4-b669-a7f38450bb60.png)


<br>

----------

###   역 참조 연산자 *

#### 포인터와 함수 매개변수

- 포인터도 변수니까 당연히 변수 쓰는 곳에는 다 쓸 수 있다.

- 따라서 매개변수도 가능

```
void print_address(int)
{
  printf("address of num :%p\n" , (void *) num);
}

//메인함수
int score = 98;
print_address (&score);s
```

- 근데 이 함수에서 뭔 짓을 할 수 있지?
- 주소만 보여주는 건 의미 없을텐데

<br>


#### 주소에 저장된 값 출력하기


![20221012_212531](https://user-images.githubusercontent.com/37941513/195342063-048f08a4-eea7-48a8-bbdb-42eb285ab569.png)


주소 가져와서 출력해줌.


#### 역참조 연산자 *

- 곱하기 연산자 아님
  - 곱하기 연산자는 피연산자 2개를, 역참조 연산자는 피연산자 1개를 가짐

```
const int result = num1 * num2

printf(*num)
```

1. 포인터가 저장하고 있는 메모리 위치로 가서
2. 거기에 저장된 값에 접근(읽거나 쓰거나)함
  - 포인터가 가리키는 값에 접근한다고도 말함

  ![20221012_224826](https://user-images.githubusercontent.com/37941513/195360357-960a275a-49ff-4543-a60c-a614ae2a5423.png)


<br>

--------



### 참조와 역 참조

- 참조
  - 포인터가 이미 하고 있는 일
  - 어떤 변수의 값을 직접 가져다 쓰는 게 아닌, 그게 어디 있다고 '참조'
  - 즉, 값이 어디 있는지 가리키고 있는 것

- 역 참조
  - 주소로 직접 가서 저장되어 있는 값에 접근하는 것
  - 참조(reference)의 반대라 역참조

<br>

----

#### 실제 데이터에 간접적으로 접근

- 값에 직접 접근하는 게 아님.
- **주소를 이용해 간접적(한 단계 거쳐서)으로 접근**
- 따라서 **간접 연산자**라고도 함
- 매우 중요한 개념이므로 반드시 숙지해야함
  - 여태까지는 모든 데이터를 복사해서 썼다.
  - 이제 그렇게 안하고 원본 접근 가능
  - 컴퓨터 구조에서 데이터를 오랫동안 메모리에 저장하는 방법
  - 바로 눈에 보이지 않는 추상적 개념을 이해하는 능력이기도 함.

<br>

----------

### 역참조를 이용한 값 변경의 예


![20221013_002616](https://user-images.githubusercontent.com/37941513/195384305-7d846ff8-8f06-4951-b6c2-b3bddf146200.png)



- 이 두 코드는 결과적으로 동일하다.

#### 포인터 변수 선언 vs 역참조


##### 헷갈리지 말자

- 앞에서 굳이 int * 를 코딩 표준으로 삼은 이유도 헷갈리지 말라는 뜻

```
int score = 100;
int * pointer =  &score; // 포인터 변수 선언
*pointer = 50; //역참조

```

<br>

-------


###   포인터로 두 변수의 값 바꾸기


![20221013_031852](https://user-images.githubusercontent.com/37941513/195418449-0066c284-8e02-433e-9561-55764aa80196.png)


위 스왑은 실제로 교체가 안된다.
- 스택 메모리에 값을 복사하기 때문
  - C#은 ref키워드로 해결
  - C는 그런거 없다.


![20221013_032002](https://user-images.githubusercontent.com/37941513/195418643-31a9dc81-fa64-4c34-b38b-594d037c5324.png)


이걸 포인터로 이용해서 바꿔야 한다.

![20221013_032249](https://user-images.githubusercontent.com/37941513/195421045-1de17574-c06d-4311-b27c-daedf9e0607c.png)


<br>

----


### 값에 의한 전달 vs 참조에 의한 전달.

- 전에 매개변수로 배열 전달할떄 했듯이 의견이 분분
- 원본이 바뀌니 -> 참조에 의한 전달
- 근데 메모리 주소 복사했는데? -> 값에 의한 전달

#### 아주 엄밀히 말하면 C는 값에 의한 전달

- 함수를 호출 할 떄 언제나 변수(그게 포인터든 아니든) 복사를 함
- 고로 값에 의한 전달
- 단 , 포인터를 사용해서 참조에 의한 전달을 흉내 낼 뿐.

<br>

- 뭐든 간에 말장난 여기서 중요한건
- **원본이 바뀌는지 안바뀌는지가 제일 중요**
- 그걸 굳이 xx에 의한 전달 이라고 해야한다면
- **참조에 의한 전달** 이라고 말하는 게 차라리 나음


-----

### 포인터와 함수 반환 값

- 당연히 포인터도 변수니까 함수 반환값으로 사용 가능

```
int * do_something(const int op1, const int op2)
```
- 다만 포인터 반환시 주의할 점이 있음

#### 지역변수의 주소를 반환: 매우 위험한 코드

```
int* add (const int op1, const int op2)
{
  int result = op1+ op2;
  return &result;
}

int main(void)
{
  int * result;
  result = add(10,20);
  return 0;
}
```

![20221013_042406](https://user-images.githubusercontent.com/37941513/195430266-8744b521-8ffb-41e6-ba37-c78df92a32ae.png)


컴파일러도 문제 있는 걸 안다.

#### 포인터가 잘못된 주소를 가르킴

- 함수의 지역변수는 어디 저장되나? => 스택
- 함수 호출이 끝나면 지역변수도 사라짐


![20221013_042645](https://user-images.githubusercontent.com/37941513/195430708-af8e11a3-aff9-4d1f-82b0-75e53f89960a.png)


여기서 함수를 나가면 스택 메모리에서 나가게 됨(add 프레임에서 나가게 되고, 더이상 유효하지 않음)


<br>

---------


### 댕글링 포인터(dangling pointer)

- 지역변수가 사용한 "주소" 자체가 사라지는 것은 아님.
- 따라서 그 주소를 반환한다고 컴파일 오류가 나지는 않음.
  - 컴파일러에 따라 경고는 줄 수 있음

- 문제는 포인터가 유효하지 않은 주소를 가리키는 것.
  - 이 경우 예측하지 못한 결과가 발생할 수 있다.
  - 잘못된 메모리를 가리킨다? 엄처어어ㅓ엉 큰 문제 발생ㄴ

- 이러한 포인터를 댕글링 포인터라고 할 수 있다.
- **절대 작성해선 안 되는 코드**

![20221013_135119](https://user-images.githubusercontent.com/37941513/195505008-ee6f7e53-ea4f-41f7-a6af-c146ff9c75fe.png)


<br>

-----------


#### 포인터와 함수 반환값 다시 보자.

- 포인터를 반환 할 경우 댕글링 포인터 조심
- 포인터 반환해도 되는 경우
  - 전역 변수
  - 파일 속 static 전역변수
  - 함수 내 static 변수
  - 힙 메모리에 생성한 데이터


![20221013_201455](https://user-images.githubusercontent.com/37941513/195582288-3eb5287c-5d32-48d5-a7bf-0f61ef658534.png)


- 언제 포인터를 반환할까
  - 도우미 함수 안에 생성한 변수를 다른 함수에서 사용하고자 할 때
    - 이건 아까 말한 정적변수라던가. 힙 메모리에서한.  아주 좋은 패턴 아닌데 가끔 해야될 때가 있음.
    - 단, 일반 지역변수면 안됨(함수 호출이 끝나면 스택에서 사라짐)
  - 함수 안에서 대용량 데이터를 생성하고 그걸 반환하고자 할 떄
    - 이 경우에는 데이터를 스택메모리가 아니라 힙 메모리라는 곳에 생성함.



<br>

---------


### 널(NULL) 포인터

- 근데 반환할 주소가 없는 경우는 어떻게 해야하나?
  - 메모리 주소에서 유효하지 않은 값은 어디냐라는 질문과 같다.


```
void do_something()
{
  int number;
  int * num_ptr = &number;
  num_ptr = NULL; //얘는 아무것도 안 가르팀. 주소가 없다.
  //이걸 대입하면 실제 메모리주소가 없다고 말하는 것
}
```


- 아무것도 가리키지 않는 포인터
1. 값이 '0'인 상수 표현식, 혹은
2. void * 로 캐스팅 된 표현식

- 전용 매크로가 있음
 - #define NULL((void*)0)
- 널 포인터 표현시 이 매크로를 사용할 것.

- 포인터 변수와 NULL은 비교 (==, !=) 가능

```
int *ptr;
if(ptr==NULL) //만약 ptr이 널 포인터면
{

}
if (ptr!=null) //만약 ptr이 널 포인터가 아니라면
{

}
```

#### 코딩 표준 : 매크로 NULL을 반드시 사용할 것.

- 0은 사용하지 않는다.

![20221017_001649](https://user-images.githubusercontent.com/37941513/196043454-70cc2fd0-345e-4c9a-90b5-d7a5a2df7659.png)


포인터와 if 쓸때는 재밌는게 많다
이전에 if문 쓸떄는 0은 자동으로 거짓이 되고 아니면 참이 되서 C는 넣는 경우가 있는데 가독성을 위해 넣자고 했다.

포인터에선 의미가 바뀔 수 있음.

포인터 ptr이 있는데 null이고 말고 비교안하는 코드가 있을 떄

그럼 이렇게 이해도 됨. 포인터가 존재하면 뭘해라 아니면 0이면(false)하지 말아라

이거를 직접 안 붙여도 명확하게 할 수있음.

근데 일관되게 하려고 오른쪽 처럼함.(NULL)


<br>

-----

### NULL이 가지는 문제점들

#### NULL은 골칫덩어리다. : 매개변수편

- 어떤 함수의 매개변수로 포인터가 들어온다. 근데 포인터가 들어올 떄 그 포인터의 주소가 유효하다고 믿고 싶다.  min,max 구하는 거 처럼. 근데 메모리 주소 없는데 어떻게 함수롤 왜 호출하지? 말이 안되는데? 이제 복잡해진다.  NULL이라는게 포인터가 들어올 떄 NULL이 될 수 있다는 거 자체가 복잡해 지게 되는 것.
  - 이런건 함수의 선조건으로 해결하는 게 좋다.  함수를 호출했는데, 참조형 타입, 아니면 NULL포인, 포인터가 들어온다고 해서 그게 NULL이 될 수 있다는 가정을 하고 그것을 다 해결하는 함수를 작성하는 것 자체가 함수의 본래 의도를 너무 벗어남.  그래서 기본적으로 함수를 작성할 때는 매개변수로 넘어오는 것, 얘는 무조건 NULL이 아니라고 기본 가정을 하고 시작하면, 그리고 회사 안에서 규율이 다 그래버리면 코드 작성 시 깨끗하다.

  - 근데 NULL을 집어넣어야 하는 함수들도 있음.
  - 그런 경우는 매개변수 이름에서 분명히 밝히자는 의미

- 함수 매개변수로 포인터가 들어올 때는 언제나 골치 골칫덩어리
- 누구나 NULL을 넣을 수 있기 떄문
- 함수의 선 조건(precondition) 문제
- 기본적으로 NULL이 안 들어온다고 가정하고 함수를 작성할 것
- NULL 이 들어올 수 있는 함수는 매개변수 명에서 분명히 밝힐 것.


#### 코딩표준 : 널 포인터를 허용하는 매개변수도

- 함수의 매개변수가 널 포인터를 허용한다면, 매개변수 이름 끝에 '_or_null'을 붙인다.

```
int get_score(const char * const student_id_or_null)
{

}
```

- 그러면 null이 들어와도 함수가 알아서 잘 처리해준다.  그렇지 않으면 null이 들어오면 제대로 작동하지 않는 선 조건이 존재하게 됨. 선 조건은 반드시 NULL 이 아니어야 선조건으로

- 그러면 assert()가 날 수 있음. 프로그램에서 assert()를 넣는다, 실행중에 NULL이 들어오면, 또 릴리스 빌드에서 NULL이 들어오면, 프로그램이 오작동 하거나 크래시가 난다.  그래서 반드시 적어주는게 좋은 표준이긴 하다.


- NULL이 안 들어 온다고 가정하는 경우 assert()를 사용해 검증한다.

```
#include <assert.h>

#define PRICE(2)
void increase_price(int* current_price)
{
  assert(current_price != NULL)
  *current_price += PRICE;
}
```


<br>

------


#### NULL은 골치덩어리다 : 반환값

- NULL을 반환할 떄도 마찬가지
- 기본적으로 함수는 NULL을 반환 안함
- 근데 NULL 반환을 해야한다면 (NULL 반환이 올바른 함수면) 함수 이름에 NULL을 반환하는 것을 명시할 것.


<br>

----


#### 코딩 표준: 널 포인터를 반환하는 함수 명

- 함수가 널 포인터를 반환할 수 있다면, 함수 끝에 'or_null'을 붙인다.
```
const char *get_name_or_null(const int id)
{
  return null;
}
```

<br>


-----------


### 널 포인터는 언제 사용하나?

1. 포인터 변수를 초기화 하고 싶을 떄
  - 아직 참조할 주소가 없을 떄

```
void do_something(void)
{
  int * ptr = NULL //당장 사용하지 않으므로 널 포인터로 초기화
  //코드생략
  ptr = &g_monster_count; //전역 변수의 주소 저장
}

```
포인터 변수 초기화 하고 싶을 떄 가끔 사용한다.
C나 C++ 같은 언어는 여기에 스택에 딱 공간을 잡을 뿐, 이 값을 초기화 해주지는 않는다.

즉, 여기에 세미콜론(;)만 적어두면 ptr 뒤에 초기화를 안 해줌.

그래서 그 값이 예전에 스택 사용한 사람들이 사용한 또 함수들이 남겨둔 값, 그 똑같은 위치로 내 로컬변수, 지역변수가 생겼기 떄문에
그 값은 그냥 가지고 있다.

그래서 그거 쓰는 순간 실제 메모리 주소 가보니 하드웨어가 보호하고 있는 메모리거나 접근이 불가능하면 크래시 나고 그럼.  그런거 방지하기 위해 NULL로 초기화 하는 경우들이 있다.


성능이 중요하면 이런거 까지 초기화 하지 말라는 곳도 있고 안정성 떄문에 초기화 권장하는 회사도 있다.

프로그래머가 자기 역량에 따라 함,

C#이나 다른언어는 초기화 하라고 강요하는 부분은 C는 프로그래머에 맡김. 그래서 중요.

2. 포인터 변수가 유효한 주소를 참조하는지 확인하고 싶을 떄
  - 아무것도 가리키지 않는 포인터 변수를 역 참조하면?
    - 결과가 정의되지 않음(undefined behavior)

![20221017_015546](https://user-images.githubusercontent.com/37941513/196048075-ec839998-0267-4de8-80e9-ac72cf7b1bfd.png)


만약 유효하지 않은 주소를 역참조 한다거나, NULL같은거, NULL로 대입해준 것들 얘를 곧바로 역참조 하려고 하면 존재하지 않는 주소를 역참조 해야한다.

c표준에선 이걸 어떻게 돌아야 한다고 정의하나? => 정의하지 않고 있음.

어떻게 될 지 얘기를 안해둠. 그렇기 때문에 무슨 일이 일어날 지 모름.

일반적으로 크래시가 난다고 말함. OS에서 잡는 경우가 많음.

결과가 정의되지 않은 코드. 널 포인터 크래시가 바로 이 경우.

이게 ***포인터의 위험성 1*** 이다.

<br>


- 올바르게 쓰려면 역참조를 하기 전에 널 포인터인지 확인 할 것.



-----


3. 댕글링 포인터를 막기 위해
  - 동적 메모리 할당된 메모리를 더 필요 없어서 해제했는데, 이를 여전히 가리키는 포인터가 있다면?
  - 더 이상 사용할 수 없는 데이터니, 포인터 변수에 저장되어 있는 그 주소를 초기화 해야함.
  - 이떄 널 포인터를 이용해 리셋함.


  ![20221017_023549](https://user-images.githubusercontent.com/37941513/196049758-c88a6fad-ad5c-45d0-add5-d753cc76fcbc.png)



  - 댕글링 포인터 얘기할 떄 동적 메모리 할당해서 내가 메모리를 사용하려고 불러옴. S에 나 메모리 큰거 필요하니까 스택에 있는 거 말고 내가 오래 쓸 수 있는 메모리 좀 줘 해서 받아옴.  아니면 스택 메모리에 들어갈 수 없는 용량이야 큰 거 줘 이렇게 함.  받아오면 이거 어떻게 쓰는 지는 중요하지 않다. 그걸 한 거고 포인터에 들고 있다. 
  
  <br>

  그러다가 어느 순간 포인터를 지운다. 이게 지우는게 포인터를 지운다. 기보다 그걸 지워달라고 운영체제에 부탁함.  그럼 이제 포인터가 가리킨 주소는 지워진 메모리. 그럼 댕글링 포인터와 같은 개념이 나온다.
  그걸 다시 NULL로 초기화 안해주고 있으면 포인터에 주소값은 들어가 있음.

  **free 한다고 주소를 지워주는 게 아님. 메모리를 지워줌**

  주소는 여전히 ptr이라는 변수에 들어가 있음.

  걔를 나중에 변수 봤는데 NULL이 아님. 어 유용한가 쓰려고 하면 그 순간 문제가 발생함.
  막 실행 문제 없이 됐는데 2시간 후 문제 생길수 있고 이럼.
  유효하지 않은 포인터에 대해 값을 갑자기 적어버리는 행위. 이걸 **메모리 스톰프** 라고 한다. (메모리를 짓밟는다.)

  그걸 막기 위해 이미 지운 메모리인걸 확인하기 위해 ptr = NULL 처럼 널 포인터 명시해준다.


  <br>

#### 결과적으로는 존재하지 않는 메모리 주소에서 값을 읽어오려고 하면 문제가 엄청 터진다!

포인터 이런건 메모리 크래시 이런거로 문제가 보이게 된다.
대부분 메모리 이상한 걸 작성한 것. 그래서 포인터 관리 못하면 정말 문제가 많이 터지고 포인터 대충 이해하고 쓰면 차라리 C 언어 안 쓰는게 낫다.


------



