---
title: "[C] C lang 콘솔 입력, 파일 입출력, 커맨드 라인 인자"
layout: post
subtitle: C
date: "2022-03-04-08:42:51 +0900"

categories: study
tags: C
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---


### 입력


- 출력의 반대

- 외부의 데이터를 읽어와서 프로그램에서 사용
- 어떤 데이터가 올 지 몰라서 괴상한 데이터가 종종 들어옴.
    - 사용자가 잘못된 데이터를 키보드에서 입력
    - 예전에 저장해 둔 파일을 누가 잘 못 바꿨거나 일부 데이터가 유실



#### 입력은 출력보다 까다롭다.


- 출력에 비해 조심해야 할 일들이 많음
- 데이터 읽기에 실패했는데, 제대로 처리 안하면 펑펑 터짐
- 정말 많이 실수한다.
- 그래서 모든 입력 값에는 반환값이 존재함.
**따라서 어떤 함수가 어떤 값을 반환하는 지, 문서에서 확실히 읽고 코드에서 검사할 것.**

- 대부분의 입력 처리 코드의 문제는 반환값이 뭔지 문서를 제대로 안 봐서 발생. 🤔


<br>

------

#### 입력의 출처는 어디?

- 입력은 어디에서 읽어올까?
- 어딘가에 출력을 했다면 거기서 읽어올 수 있다고 생각하면 편함
- 스트림
    - 콘솔 창에 출력했으니, 콘솔(키보드)로 부터 받아옴.
    - 파일에 출력(저장)했으니 파일로부터 입력받아 옴.
    - 등등

- 문자열
    - 문자열에 출력(저장) 했으니, 문자열로 부터 , 입력받아 옴.

- 어디로 출력하던 거의 비슷한 함수들이 몇 있었다.
- 입력도 마찬가지

<br>

-------

#### 입력 처리 전략

- 크게 4가지 전략이 있음.

1 . 한 글자씩 읽기
2 . 한 줄씩 읽기
3 . 한 데이터씩 읽기.
4 . 한 블록 씩 읽기(이진 데이터)


<br>

------

#### 한 글자씩 읽기, 한 글자씩 읽는 알고리듬 1

1 . 한 글자(char)를 읽어온다.
2 . 그 글자를 필요한 곳에 사용한다.
3 . 1번 단계로 되돌아간다.



<br>


```
#include<stdio.h>

int c;

while(TRUE){    //define TRUE(); 
    c = getchar();
    putchar(c);
}

```

![20221024_232251](https://user-images.githubusercontent.com/37941513/197549364-50755703-2efb-4930-bcb3-af2281bbcb25.png)


![20221024_232516](https://user-images.githubusercontent.com/37941513/197553562-e583e8d4-6623-429a-947f-41ef22c6c409.png)

<br>

---------


#### getchar() 반쪽짜리 설명 ver


```
int getchar(void)
int fgetc(FILE * stream)    //여기에 stdin 넣어주면 getchar와 동일함.
//getchar는 기본적으로 stdin에서 읽어오는 거, stdin이라 하면 키보드임.
```

- 키보드 (stdin)으로 부터 문자 하나를 읽어서 int형으로 반환
     - 왜 int형?
     - 사실 굉장히 많은 입출력 함수들이 문자를 읽고 쓸 때, char 대신 int 씀
- fgetc(stdin) 하고 같음

<br>

-----


### getchar()와 EOF 키

```
#include<stdio.h>

int c;

while(TRUE){    //define TRUE(); 
    c = getchar();
    putchar(c);
}

```



![20221024_233853](https://user-images.githubusercontent.com/37941513/197553568-99fd2452-efbd-4649-80a7-d5280ff9149a.png)

위 코드에도 문제가 있다.
무한 루프 돌음. 


<br>

-----

#### 언제 멈춰야 하는가?

1 . 특별한 키를 입력 받았을 경우
- 예) 'x'는 프로그램 종료
- 메뉴 입력받은 거 받을 때는 가능
- 그러나 타자 프로그램 등에서 모든 키보드 문자를 허용할 때는 불가능.


![20221024_234024](https://user-images.githubusercontent.com/37941513/197553572-2b9b5bdf-d078-4449-b84d-41181a29e5f0.png)


<br>


------


2. 어디에서도 사용 가능한 "입력 끝~" 을 나타내는 무언가가 있으면 좋겠다.

- 그게 뭔가?
- 혹시 반환값이 int형인게 뭔가 이유가 있어서가 아닐까?
```
int getchar(void)
```

- getchar()에 대한 설명에서 실마리를 얻어보자.(레퍼런스 참조)

<br>

--------

#### getchar()의 반환 값


![20221024_235603](https://user-images.githubusercontent.com/37941513/197557626-47af2092-9f2d-4ba9-a5e0-c81625709ee3.png)


- 성공하면 문자를, 실패하면 EOF(End Of File)를 반환
- EOF 바로 얘다.

<br>


-----

#### 입력의 끝을 나타내는 값, 'EOF'

- C 표준에 의하면 EOF는 음수라고 함.
- 그런데 표준에 따르면 char는 부호가 있을 수도 있고 없을 수도 있음.
- 따라서 char에 언제나 이 음수값을 담는게 불가
- 그리고 char는 unsigned인지 char인지 표준이 정해두지 않음.
- 이게 getchar()가 int를 반환하는 이유



<br>


-------


#### 완전한 getchar() 설명

```
int getchar(void);
int fgetc(FILE * stream);
```

- 키보드 (stdin)로 부터 문자를 하나씩 읽음
- 반환값
    - 성공시, 읽은 문자의 아스키 코드를 반환
    - 실패시 EOF를 반환

- fgetc(stdin)하고 같음.

