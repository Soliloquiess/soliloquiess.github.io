---
title: "[C] C lang 실행과정"
layout: post
subtitle: C
date: "2022-02-24-04:42:51 +0900"

categories: study
tags: C
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---


### C 프로그램에서의 빌드 과정

- 빌드란
  - 사람이 읽기 쉬운 명령어를 기계어로 변경하는 과정
  - 명령어들을 모아 기계에서 실행 가능한 파일로 만드는 것.

- C의 빌드란(과정 전체 통틀어서 빌드라 일컫는다.)

1. 전처리
2. 컴파일
3. 어셈블
4. 링크


<br>


![20221010_112700](https://user-images.githubusercontent.com/37941513/194791679-65323dac-1add-4b9b-9214-f8bf956df2fe.png)

중간 초록 부분은 어떤 부분은 따로 봐서 컴파일링 어셈블링을 따로 보기도 하고 어떤 부분은 합쳐서 컴파일링이라 보는 곳도 있기는 하다.


<br>

-----



보통 아래와 같이 빌드함.

- clang -std=c89 -W -Wall -pedantic-errors *.c

- 그럼 clang이 알아서   4단계를 실행해준다.
  - 결과는 최종 실행파일 a.out, a.exe파일을
  ![20221010_123107](https://user-images.githubusercontent.com/37941513/194795653-537f12f6-fe0f-4428-b10c-33eb607dbb5e.png)


- 물론 clang에서 한단계 씩도 진행 가능은 함.




![20221010_123918](https://user-images.githubusercontent.com/37941513/194796195-6eb2ae7f-1ded-4832-991e-19cd0af9de50.png)



<br>

-----


### .h, .c파일



![20221010_124353](https://user-images.githubusercontent.com/37941513/194796516-b7c1a5e5-22ad-47e6-b5c5-56dd28ae968d.png)




![20221010_124505](https://user-images.githubusercontent.com/37941513/194796595-32f53ac7-5c52-48b3-95bd-084c5f130993.png)


.c 파일이 실제 우리가 쓰는 일반 소스코드라 보면 된다.

실제 프로그램을 돌게하는 코드들. 로직코드 저장해두는게 c파일
이걸 구현한 것을 정의라 한다.

<br>


헤더파일은 여러소스코드에서 공유하고 싶은 코드들이 있는데 이걸 저장해둠

함수 원형을 저장해둠.


![20221010_124740](https://user-images.githubusercontent.com/37941513/194796756-20cc00f5-30c1-4aab-a42d-a8b6411b85b9.png)


<br>

------


### 헤더파일이 필요한 이유?

- 반드시 필요하진 않음. 근데 좀 더 효율적으로 구조 잡고 작성하려면 파일 분리해야 하는데 C는 워낙 고대언어라 이걸 문제없이 지원하기 힘듬.


- 만약 동일한 함수 써야된다고 동일한 함수를 복붙하면 되지 않나?
  - 함수나 코드 중복은 엄청난 죄악
  - 유지보수 어쩔껀데..



#### 근데 함수 선언만으로 어떻게 프로그램이 도나?

- 컴파일 단계를 자세히 보면 됨.

- 빌드가 여러 단계로 쪼개져 있는 이유가 정의 없이 선언만 가지고도 컴파일 되게 하기 위함.

- 실제 올바른 기능 호출은 링크 단계 이후에 이뤄짐.


<br>

-------

### include <>  와   include ""


- 인클루드 하는 방법은 2가지가 있음.
- 이 둘의 차이는 디스크 상에서 어디서 파일을 찾냐 의미.


<br>



#### #include <>

- <>는 시스템 경로에서만 헤더 파일을 검색
  - 보통 컴파일러가 제공하는 시스템 헤더파일을 인클루드 할 때 사용.




#### #include ""

- ""는 현재 작업중인 디렉토리에서 헤더파일을 먼저 검색한 뒤 없으면 시스템 경로를 검색

  - 개발자가 구현한 헤더파일들을 인클루드 시 사용.



<br>


-----


### 빌드과정 1: 전처리 단계


![20221010_132145](https://user-images.githubusercontent.com/37941513/194798955-5ebdd41b-db4c-46f3-86e3-e4d2a3a94e37.png)




- 보통 전처리기(processor) 라는 별도 프로그램이 담당.

- 전처리 단계 : 입력 - 처리 - 출력
  - 먼저 주석 제거함.
  - 매크로 (복붙) 확장 함.
  - #로 붙는 매크로들 다 확장한다 보면 됨.

  - 인클루드 파일들을 확장하고 그 자리에 헤더파일 있는 내용들을 가져다 붙인다.

- 출력 : 확장된 소스코드
  - 컴파일의 기본단위인 트랜슬레이션 유닛(translation unit)




<br>


-----



#### 트랜슬레이션 유닛 보는 법

- clang -std=c89 -W -Wall -pedantic-errors -E adder.c

clang 컴파일 중 -E 플래그를 넣으면 됨.

전처리기까지 돌리고 결과 보여줌.


![20221010_144803](https://user-images.githubusercontent.com/37941513/194805648-6a19a35c-1af2-4782-a2b0-c35d5629f6d9.png)

<br>


- clang -std=c89 -W -Wall -pedantic-errors -E adder.c > adder.pre

파일로 저장하려면 출력 리디렉션을 쓰면 된다.


-----


### 빌드과정 : 컴파일 단계

- 컴파일러라는 프로그램이 담당.


![20221010_150638](https://user-images.githubusercontent.com/37941513/194806722-1d54d54b-ad50-4ddd-b5ce-c74c5058cf2f.png)



- 어셈블리어는 기계어와 거의 1:1로 대응(하드웨어와 아주 가까움.)

- 그러나 텍스트 파일이라 여전히 사람이 읽기 쉬운언어(그나마)



![20221010_151237](https://user-images.githubusercontent.com/37941513/194807236-0290d7ea-aed4-48b0-b47b-39fcc4e701f6.png)


<br>


-----


어셈블리어 코드는 아직 정의를 모르는 심볼 사용이 가능
  - 심볼: 함수나 변수 이름 등
  - 이것이 헤더를 통한 선언만으로 컴파일이 가능한 이유

컴파일러가 어떤 함수나 변수의 정의를 못 찾을 경우
  - 선언만 보고 다음과 같이 행동함

  ![20221010_151431](https://user-images.githubusercontent.com/37941513/194807413-d160cdc8-404c-4824-a2e6-e73e0560dd1f.png)


이걸 메꾸는 게 링크 단계가 해줌.


<br>


- 어셈블리어 코드 보는 방법
  -   컴파일 플래그 -S를 쓰면 된다. 어셈블리어 코드가 .s파일로 저장됨.

  - clang -std=c89 -W -Wall -pendatic-errors -S adder.c

<br>

-----


#### 어셈블리어 코드가 나왔다는 의미?

- 이 단계 부터는 코드는 ***특정 플랫폼에서만 동작***
- C가 크로스 플랫폼이라는 주장은 컴파일 되기 전 까지임.
- 또 타겟 플랫폼이 몇 비트냐에 따라 C 자료형 크기가 달라질 수 있음.  
  - 어셈블리어 코드는 이미 그 자료형 크기가 결정된 후

- 64비트 OS에서는 32비트 프로그램을 실행할 수 있지만 그 반대는 안됨.



<br>

----


### 빌드 과정: 어셈블 단계


- 어셈블러라는 프로그램이 담당


![20221010_153851](https://user-images.githubusercontent.com/37941513/194810025-7070b20f-0c3d-459a-9569-5f6347fc840e.png)



- 오브젝트 출력

  - 기계가 곧바로 이해 가능한 코드.
  - 기계어라고 한다.
  - 즉, 이진코드
  - 어셈블리어와 마찬가지로 메꿔야 하는 구멍이 있음.



<br>

----


오브젝트 코드는 -c 플래그를 넣어서 컴파일 하면 .o 파일로 컴파일 됨.

- clang -std=c89 -W -Wall -pendatic-errors -c main.c


오브젝트 파일은 이진파일이므로 메모장이나 텍스트 툴로 열면 깨져서 안보임.

Hex editor같은 특별한 에디터를 써야 보인다.(16진수 편집기.)

![20221010_155523](https://user-images.githubusercontent.com/37941513/194812051-820ac991-197d-4898-8c90-933a36a29c31.png)

![20221010_155630](https://user-images.githubusercontent.com/37941513/194812189-a20a6b19-8cb2-48e3-81d4-ad2ba6d8b13f.png)

<br>

------


### 빌드과정 : 링크 단계

- 링커라는 프로그램이 담당.

- 입력 : 모든 오브젝트 코드들.

- 링커는 모든 오브젝트 코드들을 모아다 구멍을 메꾼뒤 실행 파일로 저장.

![20221010_160015](https://user-images.githubusercontent.com/37941513/194813001-c2f52b5f-72fe-4403-88fc-cbb221cf7966.png)

![20221010_160026](https://user-images.githubusercontent.com/37941513/194813006-6c26b588-be88-4d8a-be6d-80e5df4f6e7a.png)


<br>

----


- 만약 선언만 믿고 사용한 함수나 변수가 여전히 구멍으로 남아있다면?  (즉, 다른 오브젝트 코드에서 정의를 못 찾았다면?)

  - 링커가 못 찾는다며 링커 오류 뱉음.
  - 그 함수나 변수가 없어 실행할 방법이 없기에 경고가 아니라 오류.



  ![20221010_160510](https://user-images.githubusercontent.com/37941513/194813591-5d39309e-df90-4b0b-96a9-e1ec389e63c3.png)


위 에러는 선언만 해놓고 실제 구현을 제대로 안 해놔서 나오는 에러

<br>

링크단계가 다 끝나면 출력으로 최종 실행파일을 출력한다.(.exe, .out)


------


### 링크 단계가 분리되어 있는 이유

#### 왜  굳이 링크 단계가 분리되어 있는가

 - 사람들은 보통 컴파일(처음 3단계) 와 링크, 두단계로 나눠서 생각.



 ![20221010_172114](https://user-images.githubusercontent.com/37941513/194824786-90e19907-4dae-4319-984a-f2c4105cd276.png)


#### 수많은 구멍을 컴파일 할 때마다 메꾸기엔

-  조금 전 예에서 보듯 .c파일이 많으면 구멍 메꾸는 일이 매우 복잡
  - 예: .c 파일이 수천인 프로젝트에서 .c 프로젝트 하나 컴파일 할 때마다 모든 함수 찾아서 구멍 메꿔야 하나?

- 여러개의 .c 파일에서 동일한 외부 함수를 사용할 경우, 최종 실행 파일에 그 함수 정의가 중복으로 들어가는 것도 막아야 함.
  - 이 중복을 체크하려면?


- 그럼 모든 c파일을 한번에 합쳐서 컴파일 하면 되지 않나?
  - .c파일 하나만 수정해도 모든걸 다 컴파일 해야하는데?

- .c 파일 하나씩 따로 컴파일해서 오브젝트 파일로 저장해두는 방법이 낫다.

  - 나중에 바뀐 .c 파일만 컴파일해서 새로운 오브젝트 파일 생성
  - 기존에 있던 오브젝트 파일과 합쳐서 링크
  - 훨씬 빠르다.
  - 분리 시켜 놓으니 간단해짐. 할 일 분리되고


<br>

----


#### 근데 .o 파일로 어떻게 .exe파일을 만들지?
- 실제로 업계에서 가장 흔한 방식
- vs에선 기본적으로 오브젝트 파일과 .exe파일을 모두 만들어 줌.
- clang은 그냥 바로 .exe파일만 만들어줄 뿐
- clang에서 어떻게 .o 파일로 .exe파일을 만들 까


-------


- clang -std=c89 -W -Wall -pedantic-errors main.o adder.o
//이런식으로 .o파일을 명시하면 된다.

- clang -std=c89 -W -Wall -pedantic-errors *.o

<br>

-----


### 라이브러리, 정적/동적 라이브러리와 링크

##### 라이브러리로도 빌드 할 수 있다.

- 참고로 빌드 결과가 실행파일이 아니라 라이브러리 파일이 나오게 할 수 도 있다.

- 라이브러리란?
  - 위에서 본 함수들을 기계어로 변환 후, 파일 하나로 저장해놓은 것.
  - 나중에 다른 .c 파일에서 이 기능이 필요 시 , 같이 링크해서 쓸 수 있음.

- 라이브러리는 2 종류가 있음.
  - 정적 라이브러리
  - 동적 라이브러리


<br>


-------


#### 정적 라이브러리와 링크

- 정적 라이브러리와 링크하는 것을 정적 링킹이라고 함

- 라이브러리 안에 있는 기계어를 최종 실행파일에 가져다 복사함.
- 동적 링킹에 비해
  - 실행파일의 크기가 커짐.
  - 메모리를 더 잡아먹을 수 있음.
  - 실행 속도가 빠름.



  ![20221010_174637](https://user-images.githubusercontent.com/37941513/194828966-dc5c47ce-24f2-4b9d-baae-ea5ce197626c.png)


<br>


#### 동적 라이브러리와 링크

- 동적 라이브러리와 링크 하는 것을 동적 링킹이라고 함
- 실행파일 안에 여전히 구멍을 남겨두는 방법
- 실행파일을 실행할 때 실제로 링킹이 일어남
  - 이 링킹은 실행 주엥 운영체제가 해줌.

  ![20221010_181640](https://user-images.githubusercontent.com/37941513/194834091-7cbb3597-7cde-44a3-987f-d419ff10246c.png)

<br>

--------


#### dll 파일?

- C#등에서 .dll파일 본적 있다면 이게 바로 그것
- dll은 dynamic link library 의 약자

![20221010_182144](https://user-images.githubusercontent.com/37941513/194834987-7216ec38-921e-401c-9111-90fff2da3eb8.png)


- 정적 링킹에 비해
  - 실행파일 크기가 적다
  - 여러 실행 파일이 동일한 라이브러리를 공유 가능하다 -> 메모리 절약
  - 여러 실행파일이 이름은 같지만 버전이 다른 동적 라이브러리를 사용시 DLL 지옥을 볼 수 있다.
    - 보안 프로그램을 A은행에서 깔고  B은행이 크래시 나고 B은행에서 깔면 A은행에서 크래시 나고 이런 경우
