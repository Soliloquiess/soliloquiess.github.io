---
title: "[C] C lang 자료구조
"
layout: post
subtitle: C
date: "2022-03-23-08:42:51 +0900"

categories: study
tags: C
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---

### 자료구조 기초

#### 자료구조란

- 컴퓨터에서 여러 자료들을 조직적, 체계적으로 저장하는 방법.
- 보통 동일한 자료형을 여런 저장하는 구조를 의미

- 자료구조에 따라 요소들 사이의 관계를 정의하는 규칙이 있음
- 다음 요인에 따라 상황마다 보다 효율적인 자료구조가 존재

  - 데이터에 접근하는 빈도
  - 데이터에 접근하는 방법

#### 자료구조의 효율성

- 효율성은 주로 시간복잡도를 말함
- 공간 복잡도를 포함하는 경우도 있음
- 따라서 빅오 표기법을 주로 사용

- 보통 효율성을 논할 시 하드웨어 최적화를 고려 안한 이론이 전부

  - 대용량 데이터 사용시 그래도 맞음
  - 적은 용량 데이터는 그렇지 않을 수도 있음.

![20221128_125651](https://user-images.githubusercontent.com/37941513/204190943-42691256-b8b5-48bb-9c62-0b3402415aaa.png)

#### C에서 자료구조를 배우는 이유

- 배열을 제외한 자료구조는 하드웨어 위에서 프로그래머가 만든 개념
- 유수의 석박사들이 만듬
- 우리도 만들줄 알아야함

- 다른 언어에서는 이런 자료구조를 라이브러리로 줘서 직접 구현해가며 배울기회가 적다
- 자칫하면 추상적으로 이해해서 그냥 라이브러리만 쓸 걸 방지
- 포인터 연습하기에도 매우 좋은 기회

<br>

---

#### 자료구조의 시간 복잡도

![20221128_132028](https://user-images.githubusercontent.com/37941513/204193353-1aa94e17-e9d5-4226-8a2c-b1957b7e66ab.png)

<br>

---

### 배열(array)

- 이미 수도 없이 사용함.
- 메모리 한 덩이를 표현하기 위한 가장 간단한 구조
- 여러 자료들을 그 메모리 덩이에 줄줄이 세워놓는 구조
- 각 자료는 색인(index)으로 접근

  - 연속된 메모리니 각 요소의 실제 메모리 상의 위치를 알 수 있음.

  - 위치 = 시작 주소 + sizeof(자료형) \* 색인

#### 배열의 삽입 예

![20221128_132501](https://user-images.githubusercontent.com/37941513/204193829-4f25466d-a93c-47b9-8124-c4b8b57609cb.png)

<br>

---

![20221128_132815](https://user-images.githubusercontent.com/37941513/204194155-ce8fa50a-3e48-48d6-8471-0e3564c9eac3.png)

- 새로운 데이터 들어올 때마다 기존 요소들이 뒤로 밀림.

- 이 다음에 0번째에 데이터를 넣으면 기존 0,1에 있던 값이 1,2로 이동

![20221128_133042](https://user-images.githubusercontent.com/37941513/204194454-a04741c7-9cac-4ef2-a19a-0f1640d798a8.png)

<br>

---

#### 마지막 삽입

![20221128_133144](https://user-images.githubusercontent.com/37941513/204194533-53637888-f9d7-45e7-9ad2-a4b26b680b1a.png)

<br>

---

#### 배열의 삽입

- 배열 맨 뒤에 넣으면 간단히 삽입하고 끝
- 그 외 경우에는 삽입하려는 위치의 요소부터 마지막 요소를 모두 뒤로 한칸 씩 민 뒤에 삽입.

![20221128_133940](https://user-images.githubusercontent.com/37941513/204195361-a1c408bf-a5be-46b7-8466-7780be904994.png)

<br>

---

### 배열의 삭제

![20221128_134402](https://user-images.githubusercontent.com/37941513/204195743-87256408-b43a-4d90-aa94-0244921d4343.png)

![20221128_134448](https://user-images.githubusercontent.com/37941513/204195847-d87dda4d-39ff-407a-8256-8eb0c5de70b4.png)

뒤에 있던 걸 앞으로 복사해오면서 땡겨온다.
결과적으로는 삭제된 부분부터 전체적으로 한칸씩 앞으로 이동.

![20221128_152755](https://user-images.githubusercontent.com/37941513/204208702-7e39ef73-a7e7-4068-82cb-9c58fde31a4f.png)

- 삭제하는 색인을 기준으로 뒤의 값들을 한칸씩 떙김
- 시간 복잡도 : O(n)

<br>

---

### 배열의 검색, 배열의 접근

#### 배열의 검색

![20221128_155129](https://user-images.githubusercontent.com/37941513/204212517-4a2bc1ce-65be-44b5-9137-8699c9a4442c.png)

- 배열 속 요소들을 처음부터 차례로 방문하며, 찾고자 하는 값이 있는 지 확인
  - 있으면 해당 색인 반환
  - 없으면 -1을 반환

![20221128_155245](https://user-images.githubusercontent.com/37941513/204212719-d88e64f0-908d-4a39-8c46-dc3b2fda2efb.png)

- 시간 복잡도 : O(n)

<br>

---

#### 배열의 접근

![20221128_155335](https://user-images.githubusercontent.com/37941513/204212881-64c71163-7d68-4a37-91c5-54e860596f90.png)

- 이미 색인을 알고 있다면 곧바로 접근 가능
- 시간 복잡도 : O(n)

<br>

---

### 스택(stack)

- 자료의 삽입과 삭제에 대한 규칙이 있는 자료구조 중 하나

- 가장 먼저 자료구조에 삽입(push)된 데이터가 제일 마지막에 삭제(pop)됨.

#### 스택을 선입후출 또는 후입선출이라고 함

- 가장 먼저 넣은 값이 가장 나중에 삭제
- 이를 4자로 줄여서 선입 후출(FILO)
- 혹은 가장 나중에 넣은 값이 가장 먼저 삭제되어 후입 선출이라고 한다.(LIFO)

##### 스택은 중간에 있는 자료를 제거할 수 없다. 언제나 맨 위에 있는 자료만 제거가능. 즉 중간에 있는 데이터만 제거가 안됨.

#### 스택 메모리와 개념이 같다.

- 스택 메모리도 같은 개념
- 데이터가 쌓여감에 따라 주소가 감소하므로 반대로 그릴뿐

![20221128_161128](https://user-images.githubusercontent.com/37941513/204215861-e56cfd3b-4b63-4182-b57b-7e2136e4ce82.png)

- 배열로 쉽게 가능
- 그냥 배열의 앞부터 데이터를 추가
- 마지막 요소의 위치를 스택의 제일 위(top)이라고 생각하면 됨.

<br>

---

### 스택의 삽입

#### 스택의 삽입 예

![20221128_162036](https://user-images.githubusercontent.com/37941513/204217283-876099a7-d694-46d5-81fd-d1df89b429b0.png)

#### 스택 삽입코드 예시

![20221128_170342](https://user-images.githubusercontent.com/37941513/204224983-1c67fa51-2396-4730-a9f2-80d5c5b80161.png)

#### 스택의 삽입

- 보통 푸시(push)라고 함

  - 제일 위에 밀어넣는다고 해서

- 시간 복잡도 : O(1)

<br>

---

#### 스택의 제거

- 비어있냐 아니냐 먼저 검사. 비어있는데 빼면 이상한 일 발생

![20221128_171142](https://user-images.githubusercontent.com/37941513/204226383-96bd730d-d14b-4e20-812c-4ed46efed050.png)

- 스택에서 뽑아낸다고 해서 pop이라고 함
- 시간 복잡도 : O(1)

<br>

---

#### 스택의 검색

- 시간 복잡도 : O(n)
- 제일 위부터 찾을 떄 까지 뒤져야 함
- 보통 push()와 pop만 허용하므로 임의의 요소에 접근할 방법이 없다.

  - 그럼 검색은..?

#### 전부 다 뽑고 확인 후 다시 넣어야한다.

- 모든 요소 다 제거 후 원상 복구 해야한다.

![20221128_171400](https://user-images.githubusercontent.com/37941513/204226851-53d8b3d7-42b4-44c3-a95c-ed83b6b14ac6.png)

#### 스택 검색의 시간 복잡도

- 모든 요소 제거 후 다시 원상 복구 해야함
- 그래서 제거에 O(n)+ 복구에 O(n)이 필요
- 따라서 O(2n)이지만 이건 그냥 O(n)이라 말함.

<br>

---

#### 스택의 용도

- 일련의 자료들의 순서를 뒤집는 데 사용
- 왜 뒤집는지

  - 현재 데이터의 순서대로 연산하는 것이 적합하지 않은 경우

- 생각보다 스택이 유용한 곳이 매우 많다.

#### 스택으로 자료순서 뒤집기

- 스택 요소 뽑아서 배열에 저장후 뒤집기

![20221128_173341](https://user-images.githubusercontent.com/37941513/204230788-3dd047bb-d37e-466c-b5cb-1ce8b42d9ecb.png)
![20221128_173358](https://user-images.githubusercontent.com/37941513/204230791-65f337c8-1616-4131-9e50-0ffe1c6a6516.png)

#### 컴퓨터 연산 순서에 맞게 자료 재정리

- 다음과 같은식(문자열로 들어옴)을 평가하는 계산기를 만들면?

```
2*(4+5) -15 /3
```

![20221128_173520](https://user-images.githubusercontent.com/37941513/204231225-1fedce8c-f7eb-4ac5-a312-d276e2eb3967.png)

- 이걸 중위 표기법이라 함(infix)
- 사람들에게 매우 익숙
- 그러나 순서대로 읽으면 평가 불가

<br>

---

- 이걸 후위 표기법(postfix)로 바꾸면 컴퓨터로 연산이 쉽다

![20221128_173719](https://user-images.githubusercontent.com/37941513/204231461-ac5c8be9-f2e8-4f6b-b026-d31c544d3c65.png)

- 중위 ->후위로 바꾸는 것도 스택으로 가능은 함

- 후위 표기법으로 적힌 식은 간단히 스택 이용해서 계산 가능

<br>

---

#### 계산 로직

1 . 한 글자를 읽는다

2 . 글자 읽는데 성공시

- 피 연산자면 스택에 넣는다
- 연산자면, 피 연산자 둘을 스택에 꺼내 연산자로 계산 후 그 결과를 다시 스택에 넣는다.
- 1로 돌아감

3 . 글자 읽는데 실패시(마지막)

- 스택에서 꺼내면 그게 결과

![20221128_174611](https://user-images.githubusercontent.com/37941513/204233136-c179757e-b996-440a-b4de-22f8ba5f8f94.png)

<br>

---

#### 재귀함수 제거에도 용이함

- 재귀함수는 함수 호출트리를 이용
- 함수는 각 호출마다 새로 스택프레임을 만들어서 중간 결과를 저장
- 따라서 스택 자료구조를 이용하면 꽤 많은 재귀함수를 재귀없이 반복문으로 구현 가능

<br>

---

### 큐(Queue)

- 스택과 마찬가지로 자료의 삽입과 삭제에 대한 규칙이 있는 자료구조 중 하나

- 가장 먼저 자료구조에 삽입 된 데이터(enqueue)가 제일 처음에 삭제(dequeue)됨.

![20221128_191102](https://user-images.githubusercontent.com/37941513/204251452-ec2ebb0e-ce27-417b-9f63-020c312d0f95.png)

#### 큐 역시 임의 접근은 안됨

- 언제나 제일 처음에 있는 자료만 제거 가능
- 중간 자료로 임의 접근 안됨

![20221128_191148](https://user-images.githubusercontent.com/37941513/204251604-a0820418-1f14-4089-999f-0e4840c10fc4.png)

#### 큐의 비 효율적인 구현

- 그냥 배열 사용시 큐를 구현할 수는 있다
- enqueue하면 그냥 제일 뒤에 추가 O(1)

![20221128_191248](https://user-images.githubusercontent.com/37941513/204251839-9054556e-c3f1-489d-aa5f-26e24e73ff1b.png)

- dequeue하면 그냥 제일 앞에서 삭제 O(n)

![20221128_191439](https://user-images.githubusercontent.com/37941513/204252224-1ab2c79d-97eb-4b76-a5a3-ca3b988fddd5.png)

##### 근데 큐의 삭제도 O(1)아닌가?

#### 큐의 삭제를 O(1)로 만들려면

- 내부적으로 배열 사용하되, 원형 버퍼(ring buffer)의 개념을 이해하면 가능

  - 어느 위치든 시작과 끝이 될 수 있다.

![20221128_191550](https://user-images.githubusercontent.com/37941513/204252451-bf269156-e84b-47dd-a266-56d4aa288e73.png)

<br>

---
