---
title: "[C] C lang 자료구조
"
layout: post
subtitle: C
date: "2022-03-23-08:42:51 +0900"

categories: study
tags: C
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---

### 자료구조 기초

#### 자료구조란

- 컴퓨터에서 여러 자료들을 조직적, 체계적으로 저장하는 방법.
- 보통 동일한 자료형을 여런 저장하는 구조를 의미

- 자료구조에 따라 요소들 사이의 관계를 정의하는 규칙이 있음
- 다음 요인에 따라 상황마다 보다 효율적인 자료구조가 존재

  - 데이터에 접근하는 빈도
  - 데이터에 접근하는 방법

#### 자료구조의 효율성

- 효율성은 주로 시간복잡도를 말함
- 공간 복잡도를 포함하는 경우도 있음
- 따라서 빅오 표기법을 주로 사용

- 보통 효율성을 논할 시 하드웨어 최적화를 고려 안한 이론이 전부

  - 대용량 데이터 사용시 그래도 맞음
  - 적은 용량 데이터는 그렇지 않을 수도 있음.

![20221128_125651](https://user-images.githubusercontent.com/37941513/204190943-42691256-b8b5-48bb-9c62-0b3402415aaa.png)

#### C에서 자료구조를 배우는 이유

- 배열을 제외한 자료구조는 하드웨어 위에서 프로그래머가 만든 개념
- 유수의 석박사들이 만듬
- 우리도 만들줄 알아야함

- 다른 언어에서는 이런 자료구조를 라이브러리로 줘서 직접 구현해가며 배울기회가 적다
- 자칫하면 추상적으로 이해해서 그냥 라이브러리만 쓸 걸 방지
- 포인터 연습하기에도 매우 좋은 기회

<br>

---

#### 자료구조의 시간 복잡도

![20221128_132028](https://user-images.githubusercontent.com/37941513/204193353-1aa94e17-e9d5-4226-8a2c-b1957b7e66ab.png)

<br>

---

### 배열(array)

- 이미 수도 없이 사용함.
- 메모리 한 덩이를 표현하기 위한 가장 간단한 구조
- 여러 자료들을 그 메모리 덩이에 줄줄이 세워놓는 구조
- 각 자료는 색인(index)으로 접근

  - 연속된 메모리니 각 요소의 실제 메모리 상의 위치를 알 수 있음.

  - 위치 = 시작 주소 + sizeof(자료형) \* 색인

#### 배열의 삽입 예

![20221128_132501](https://user-images.githubusercontent.com/37941513/204193829-4f25466d-a93c-47b9-8124-c4b8b57609cb.png)

<br>

---

![20221128_132815](https://user-images.githubusercontent.com/37941513/204194155-ce8fa50a-3e48-48d6-8471-0e3564c9eac3.png)

- 새로운 데이터 들어올 때마다 기존 요소들이 뒤로 밀림.

- 이 다음에 0번째에 데이터를 넣으면 기존 0,1에 있던 값이 1,2로 이동

![20221128_133042](https://user-images.githubusercontent.com/37941513/204194454-a04741c7-9cac-4ef2-a19a-0f1640d798a8.png)

<br>

---

#### 마지막 삽입

![20221128_133144](https://user-images.githubusercontent.com/37941513/204194533-53637888-f9d7-45e7-9ad2-a4b26b680b1a.png)

<br>

---

#### 배열의 삽입

- 배열 맨 뒤에 넣으면 간단히 삽입하고 끝
- 그 외 경우에는 삽입하려는 위치의 요소부터 마지막 요소를 모두 뒤로 한칸 씩 민 뒤에 삽입.

![20221128_133940](https://user-images.githubusercontent.com/37941513/204195361-a1c408bf-a5be-46b7-8466-7780be904994.png)

<br>

---

### 배열의 삭제

![20221128_134402](https://user-images.githubusercontent.com/37941513/204195743-87256408-b43a-4d90-aa94-0244921d4343.png)

![20221128_134448](https://user-images.githubusercontent.com/37941513/204195847-d87dda4d-39ff-407a-8256-8eb0c5de70b4.png)

뒤에 있던 걸 앞으로 복사해오면서 땡겨온다.
결과적으로는 삭제된 부분부터 전체적으로 한칸씩 앞으로 이동.

![20221128_152755](https://user-images.githubusercontent.com/37941513/204208702-7e39ef73-a7e7-4068-82cb-9c58fde31a4f.png)

- 삭제하는 색인을 기준으로 뒤의 값들을 한칸씩 떙김
- 시간 복잡도 : O(n)

<br>

---

### 배열의 검색, 배열의 접근

#### 배열의 검색

![20221128_155129](https://user-images.githubusercontent.com/37941513/204212517-4a2bc1ce-65be-44b5-9137-8699c9a4442c.png)

- 배열 속 요소들을 처음부터 차례로 방문하며, 찾고자 하는 값이 있는 지 확인
  - 있으면 해당 색인 반환
  - 없으면 -1을 반환

![20221128_155245](https://user-images.githubusercontent.com/37941513/204212719-d88e64f0-908d-4a39-8c46-dc3b2fda2efb.png)

- 시간 복잡도 : O(n)

<br>

---

#### 배열의 접근

![20221128_155335](https://user-images.githubusercontent.com/37941513/204212881-64c71163-7d68-4a37-91c5-54e860596f90.png)

- 이미 색인을 알고 있다면 곧바로 접근 가능
- 시간 복잡도 : O(n)

<br>

---

### 스택(stack)

- 자료의 삽입과 삭제에 대한 규칙이 있는 자료구조 중 하나

- 가장 먼저 자료구조에 삽입(push)된 데이터가 제일 마지막에 삭제(pop)됨.

#### 스택을 선입후출 또는 후입선출이라고 함

- 가장 먼저 넣은 값이 가장 나중에 삭제
- 이를 4자로 줄여서 선입 후출(FILO)
- 혹은 가장 나중에 넣은 값이 가장 먼저 삭제되어 후입 선출이라고 한다.(LIFO)

##### 스택은 중간에 있는 자료를 제거할 수 없다. 언제나 맨 위에 있는 자료만 제거가능. 즉 중간에 있는 데이터만 제거가 안됨.

#### 스택 메모리와 개념이 같다.

- 스택 메모리도 같은 개념
- 데이터가 쌓여감에 따라 주소가 감소하므로 반대로 그릴뿐

![20221128_161128](https://user-images.githubusercontent.com/37941513/204215861-e56cfd3b-4b63-4182-b57b-7e2136e4ce82.png)

- 배열로 쉽게 가능
- 그냥 배열의 앞부터 데이터를 추가
- 마지막 요소의 위치를 스택의 제일 위(top)이라고 생각하면 됨.

<br>

---

### 스택의 삽입

#### 스택의 삽입 예

![20221128_162036](https://user-images.githubusercontent.com/37941513/204217283-876099a7-d694-46d5-81fd-d1df89b429b0.png)

#### 스택 삽입코드 예시

![20221128_170342](https://user-images.githubusercontent.com/37941513/204224983-1c67fa51-2396-4730-a9f2-80d5c5b80161.png)

#### 스택의 삽입

- 보통 푸시(push)라고 함

  - 제일 위에 밀어넣는다고 해서

- 시간 복잡도 : O(1)

<br>

---

#### 스택의 제거

- 비어있냐 아니냐 먼저 검사. 비어있는데 빼면 이상한 일 발생

![20221128_171142](https://user-images.githubusercontent.com/37941513/204226383-96bd730d-d14b-4e20-812c-4ed46efed050.png)

- 스택에서 뽑아낸다고 해서 pop이라고 함
- 시간 복잡도 : O(1)

<br>

---

#### 스택의 검색

- 시간 복잡도 : O(n)
- 제일 위부터 찾을 떄 까지 뒤져야 함
- 보통 push()와 pop만 허용하므로 임의의 요소에 접근할 방법이 없다.

  - 그럼 검색은..?

#### 전부 다 뽑고 확인 후 다시 넣어야한다.

- 모든 요소 다 제거 후 원상 복구 해야한다.

![20221128_171400](https://user-images.githubusercontent.com/37941513/204226851-53d8b3d7-42b4-44c3-a95c-ed83b6b14ac6.png)

#### 스택 검색의 시간 복잡도

- 모든 요소 제거 후 다시 원상 복구 해야함
- 그래서 제거에 O(n)+ 복구에 O(n)이 필요
- 따라서 O(2n)이지만 이건 그냥 O(n)이라 말함.

<br>

---

#### 스택의 용도

- 일련의 자료들의 순서를 뒤집는 데 사용
- 왜 뒤집는지

  - 현재 데이터의 순서대로 연산하는 것이 적합하지 않은 경우

- 생각보다 스택이 유용한 곳이 매우 많다.

#### 스택으로 자료순서 뒤집기

- 스택 요소 뽑아서 배열에 저장후 뒤집기

![20221128_173341](https://user-images.githubusercontent.com/37941513/204230788-3dd047bb-d37e-466c-b5cb-1ce8b42d9ecb.png)
![20221128_173358](https://user-images.githubusercontent.com/37941513/204230791-65f337c8-1616-4131-9e50-0ffe1c6a6516.png)

#### 컴퓨터 연산 순서에 맞게 자료 재정리

- 다음과 같은식(문자열로 들어옴)을 평가하는 계산기를 만들면?

```
2*(4+5) -15 /3
```

![20221128_173520](https://user-images.githubusercontent.com/37941513/204231225-1fedce8c-f7eb-4ac5-a312-d276e2eb3967.png)

- 이걸 중위 표기법이라 함(infix)
- 사람들에게 매우 익숙
- 그러나 순서대로 읽으면 평가 불가

<br>

---

- 이걸 후위 표기법(postfix)로 바꾸면 컴퓨터로 연산이 쉽다

![20221128_173719](https://user-images.githubusercontent.com/37941513/204231461-ac5c8be9-f2e8-4f6b-b026-d31c544d3c65.png)

- 중위 ->후위로 바꾸는 것도 스택으로 가능은 함

- 후위 표기법으로 적힌 식은 간단히 스택 이용해서 계산 가능

<br>

---

#### 계산 로직

1 . 한 글자를 읽는다

2 . 글자 읽는데 성공시

- 피 연산자면 스택에 넣는다
- 연산자면, 피 연산자 둘을 스택에 꺼내 연산자로 계산 후 그 결과를 다시 스택에 넣는다.
- 1로 돌아감

3 . 글자 읽는데 실패시(마지막)

- 스택에서 꺼내면 그게 결과

![20221128_174611](https://user-images.githubusercontent.com/37941513/204233136-c179757e-b996-440a-b4de-22f8ba5f8f94.png)

<br>

---

#### 재귀함수 제거에도 용이함

- 재귀함수는 함수 호출트리를 이용
- 함수는 각 호출마다 새로 스택프레임을 만들어서 중간 결과를 저장
- 따라서 스택 자료구조를 이용하면 꽤 많은 재귀함수를 재귀없이 반복문으로 구현 가능

<br>

---

### 큐(Queue)

- 스택과 마찬가지로 자료의 삽입과 삭제에 대한 규칙이 있는 자료구조 중 하나

- 가장 먼저 자료구조에 삽입 된 데이터(enqueue)가 제일 처음에 삭제(dequeue)됨.

![20221128_191102](https://user-images.githubusercontent.com/37941513/204251452-ec2ebb0e-ce27-417b-9f63-020c312d0f95.png)

#### 큐 역시 임의 접근은 안됨

- 언제나 제일 처음에 있는 자료만 제거 가능
- 중간 자료로 임의 접근 안됨

![20221128_191148](https://user-images.githubusercontent.com/37941513/204251604-a0820418-1f14-4089-999f-0e4840c10fc4.png)

#### 큐의 비 효율적인 구현

- 그냥 배열 사용시 큐를 구현할 수는 있다
- enqueue하면 그냥 제일 뒤에 추가 O(1)

![20221128_191248](https://user-images.githubusercontent.com/37941513/204251839-9054556e-c3f1-489d-aa5f-26e24e73ff1b.png)

- dequeue하면 그냥 제일 앞에서 삭제 O(n)

![20221128_191439](https://user-images.githubusercontent.com/37941513/204252224-1ab2c79d-97eb-4b76-a5a3-ca3b988fddd5.png)

##### 근데 큐의 삭제도 O(1)아닌가?

#### 큐의 삭제를 O(1)로 만들려면

- 내부적으로 배열 사용하되, 원형 버퍼(ring buffer)의 개념을 이해하면 가능

  - 어느 위치든 시작과 끝이 될 수 있다.

![20221128_191550](https://user-images.githubusercontent.com/37941513/204252451-bf269156-e84b-47dd-a266-56d4aa288e73.png)

<br>

---

### 큐의 삽입

#### 큐 삽입 예



![20221128_233052](https://user-images.githubusercontent.com/37941513/204308083-12d04f04-cb6d-422e-8253-b2006da1249c.png)


![20221128_235638](https://user-images.githubusercontent.com/37941513/204309106-24fce206-0d20-4fdf-babb-448b14bff796.png)


s_front, s_back, s_num_count는 0으로 시작

s_back은 되돌이 표 하는 연산

데이터 삽입하다 보면 보임.

![20221129_000035](https://user-images.githubusercontent.com/37941513/204310191-e996bb83-1992-4fbe-9817-d33df74383d8.png)


s_front와 s_back이 같은 배열 인덱스에 위치했다. 일직선이지만 원형으로 보면 됨.

s_back에서 집어넣는 걸 판단하고 현재 뺴야하는 위치 바꿈

#### 큐의 삽입


![20221129_002504](https://user-images.githubusercontent.com/37941513/204315699-e624756f-e6e5-45d0-a426-d27f24d04746.png)


- 보통 enqueue라고 함
  - 줄 제일 뒤에 세운다는 의미

- 시간 복잡도 : O(1)

<br>

----

### 큐의 삭제

#### 큐의 삭제 예

![20221129_002635](https://user-images.githubusercontent.com/37941513/204316102-aaf1c6a7-3b08-4898-8bca-4e0043503eeb.png)



<br>

-----

#### 큐 삭제 예시

![20221129_003156](https://user-images.githubusercontent.com/37941513/204317377-3b355324-a5d3-4d8a-a5ac-3588207b0434.png)


![20221129_003326](https://user-images.githubusercontent.com/37941513/204317724-6ae8779a-c67c-4c34-a860-9c14d870aafe.png)


5에서 4로 감소

리턴하면 10 반환하니 item도 10 


<br>

------

#### 큐의 제거

![20221129_003405](https://user-images.githubusercontent.com/37941513/204317878-04be1481-3113-4061-a902-6f288f941202.png)


- dequeue라고 함
  - 앞에서 하나 빼온다

- 시간 복잡도 : O(1)


<br>

-------


### 큐의 검색

- 시간 복잡도 : O(n)
- 제일 처음부터 찾을 떄까지 뒤져야 함
- 스택과 마찬가지로 보통 enqueue, dequeue만 허용하므로, 임의의 요소에 접근할 방법이 없다.

##### 큐도 다 뽑아서 확인해야 한다.
- 모든 요소 다 제거했다가 다시 원상복구 해야됨.

![20221129_004511](https://user-images.githubusercontent.com/37941513/204320495-561c9038-4d44-4a18-9a06-a5b7f49b608e.png)

![20221129_004530](https://user-images.githubusercontent.com/37941513/204320530-621e6857-842c-4644-b991-79c0814c66f6.png)



<br>

---------

#### 큐 검색의 시간 복잡도

- 스택과 똑같음
- 모든 요소를 다 제거했다가 원상복구 해야함
- 그래서 제거에 O(n)+ 복구하는데 O(n)이 필요

- 따라서 O(2n)이지만, 이건 그냥 O(n)이라고 말함.


<br>

----


#### 큐의 용도

- 현실 세계에서 대기줄이 필요한 경우에 다 가능
- 데이터 유입 속도가 소모속도보다 빠른 경우
- 데이터 제공자의 수가 소비자의 수와 다른 경우
  - 예: 은행 창구는 여럿인데 줄은 한줄로만 설 떄
  - 멀티 쓰레딩에서도 이런 일들을 함

- 입출력 스트림 버퍼링도 같은 개념

<br>

---- 

#### 연결 리스트, 연결 리스트의 삽입/제거/검색


- 면접시 자료구조 구현하라면 가장 많이 나오는 중 하나가 연결리스트

- 연결리스트, 해시맵, 해시테이블 이 3개가 가장 많이 묻는 질문.

- 기본기도 아님. 당연히 해야하는 것. 실력 좋은 프로그래머라면 당연히 안보고 할 수 있어야 하는 것 들 

<br>

--------


#### 지금까지 위의 자료구조들

- 여태껏 본 자료구조들은 메모리에서 연속된 저장 방법에 기초한다.

![20221129_010101](https://user-images.githubusercontent.com/37941513/204323997-0922b3c3-e309-44d6-a85d-5bbb828a6c75.png)


<br>

---------




#### 그러나 연결 리스트는 다름

- 여태껏 본 자료구조들은 메모리에서 연속 된 저장방법에 기초
- 연결 리스트는 그런 제약을 깸

<br>

----

#### 연결리스트(linked list)

- 자료들이 메모리에 이렇게 산재해있음
  - 연결 리스트의 각 자료를 노드(node)라 부름

![20221129_010629](https://user-images.githubusercontent.com/37941513/204325351-e517e939-a561-4773-a6e9-4f731e091a97.png)


- 자료형이 어떻게 산재할 수 있는지?
  - 동적 메모리 할당으로 필요에 따라 각 노드를 할당.

#### 근데 서로 어떻게 연결하는지

- 그 둘 사이의 선후 관계를 별도로 지정

  - 어떻게? 다음에 오는 노드 메모리의 주소를 기억
  - 어디에? 노드에 있는 포인터 변수에

  - 제일 마지막 노드는 다음에 올 노드가 없으니 널 포인터


![20221129_011958](https://user-images.githubusercontent.com/37941513/204328296-cb36ac80-9467-4e58-aee1-ec91e299376a.png)


- 노드는 서로 가리키는게 있다.

- 앞의 노드(데이터)에서 다음 노드가 있는 것의 주소를 가리킨다. 메모리 상 위치가 어디든 상관 없고 중요한 건 내 데이터의 다음 데이터를 가리키는 포인터가 있다는 점이 중요하다.

- 이 전체를 노드라고 한다. 이 노드 안에 있는것이 데이터. 

- 그리고 다음 노드로의 포인터, 다음 노드를 가리키는 포인터, 노드 기반 에디터와 같은 개념

- 처음은 아무도 처음 노드를 가리치지 않으므로 헤드라고 한다. 

- 마지막은 아무것도 가리키지 않으므로 널 포인터를 가지낟. 이걸 테일이라고 한다. 

<br>

----


#### 연결리스트는 어려울 수 있는 자료구조

- 연결리스트는 매우 훌륭한 면접문제
  - 메모리 관리 능력
  - 이중 포인터 사용 능력


- 여태까지 설레설레 자료구조 봤어도 이건 집중해서 봐야한다.

<br>

-----


#### 연결리스트의 삽입

- 이미 삽입할 위치를 알면 O(1)

10 다음 넣고 싶다. 10이 30의 주소(포인터로)를 가리키고 있는데 20으로 얘를 가리키게 한다. 

즉 10에 든 주소를 20으로 옮기고 20의 주소를 30으로 가리키게 한다. 그럼 노드의 순서가 변경된 것

삽입할 위치만 알면 포인터 2개만 바꾸면 되니까 O(1)이라는 것. 

- 밀고 당기고의 개념이 없다. 포인터로 다음 노드만 가리키면 됨

![20221129_012752](https://user-images.githubusercontent.com/37941513/204329918-fabbde15-f0a7-453a-b84d-bbccd30a7b4e.png)



<br>

----




#### 연결 리스트의 제거


30을 제거하고 싶은데 30을 뿅 제거하는게 아니라 30이 40을 가리키고 있었으니까 내 앞의 애가 30의 다음 애를 가리키게 하면 됨.

즉 30에 들어있던 주소값을 10 여기에 있는 주소값에 대입 시, 원래 30 가리키던 새로운 값이 대입 되니까 40을 가리키게 된다. 

그래서 다음 가리키는 애만 누군지 바꿔주는 것으로 10,40,NULL을 알 수 있게 된다.

#### 연결 리스트의 검색

- O(n)
- 제일 첫 노드부터 찾을 때 까지 찾아야 함
  - 보통 이 노드를 헤드라고 부름


- 색인으로 접근 불가능
- 이렇게 찾은 뒤 삽입을 하면 O(1)이 되는 것


![20221129_013146](https://user-images.githubusercontent.com/37941513/204330761-d160a83f-6535-48b3-8064-8a09eba5e807.png)


만약 찾으려면 색인 0,1,2이런 개념이 있으려면 배열의 주소가 있고 오프셋을 바로 계산할 수 있어야 하는데 이건 불가

- 워낙 메모리가 산재해 있으므로 하나씩 찾아가는 것


그럼 찾는 개념은 뭔가?

35보다(들어가는 값보다) 작은 값이면 다음으로 건너뛰어야 하고, 큰 값을 보면 전 것과 지금 사이에 넣어야 함


어쩄든 먼저 찾는 것은 O(n)

일단 찾는 위치만 결정하면 실제 삽입하는 건 O(1)

- 삽입한 뒤 데이터를 밀고 당기고 하는게 없기 떄문

![20221129_013146](https://user-images.githubusercontent.com/37941513/204332484-ff8348e6-f62c-4c53-8515-5d7db54a914b.png)


![20221129_014023](https://user-images.githubusercontent.com/37941513/204332591-8b7aac42-bd98-4c43-b571-9ce5d700f4db.png)


35를 넣으려면 헤드부터 찾고 30인 헤드면 다음부터 찾은 뒤 40을 찾고 40을 찾았으면 이 전에 넣어야 되는걸 알고 연결 시키면 된다. 

그래서 찾는 과정은 O(n)


<br>

------

#### 연결 리스트: 전체 출력 예 & 노드 메모리 해제 예, 헤드 노드

![20221129_014202](https://user-images.githubusercontent.com/37941513/204332965-ef9c8faa-df5c-4275-8c54-010e445a1602.png)

노드는 어떻게 만드나?

노드는 두가지 데이터를 담고 있다.
  - 실제 데이터와 다음 노드로의 주소

그래서 구조체 필요
처음은 값
두번쨰는 다음 노드로의 주소(다음 노드 가리키는 포인터)


그리고 이 연결리스트를 출력하려면?


링크드 리스트는 기본적으로 어떤 크기가 잡혀있는 리스트가 아니다.

그렇기 떄문에 이걸 함수로 만들어놔도 데이터는 자유롭게 추가가능하니까 어떤 크기용 전용 함수가 아니라서 전역변수를 쓸 일도 없고 편하다

이건 함수를 많이 만든다. 
다음에 이 노드 출력하고 그 다음 것 출력하고, 그다음 노드 출력하고,  그 다음 노드가 널 포인터면 마지막 노드다.


처음부터 끝까지 훑는 반복문. 그래서 p를 만들고 p에 헤드를 대입함.

즉, p로 다음노드 계속 가겠다는 의미(포인터로)

그럼 NULL이면 그냥 끝. NULL이 아니면 출력하라 하고 p->value를 출력.

출력한 뒤 나를 다음 노드로 옮기라는 걸 해줘야 됨.

  - p->next로 내 다음 주소를 다시 나한테 대입하라고 지시.

  - 그 순간 p는 다음노드를 가리키게 됨


<br>

-------

#### 헤드 노드

- 연결 리스트의 첫번쨰 노드를 가리키는 포인터

- 처음 시작할 때 값은 NULL
  - 아직 노드가 하나도 없기 때문
  - 여기다 새로운 노드를 동적 할당해서 대입해 줌

- 처음 시작시 헤드는 아무것도 가리키지 않음.

- 얘 포인터로 포현한 것


```
note * head = NULL;
```

![20221129_014916](https://user-images.githubusercontent.com/37941513/204335024-b1051685-711a-4ee1-b628-74d4ff0ca038.png)

- 만약 포인터가 아무것도 가리키지 않으면 사선 그어서 표현

<br>

----

##### 메모리를 동적할당하면 반드시 해야하는 일이 있다. - > free() 추가 


destroy()함수 추가

![20221129_015148](https://user-images.githubusercontent.com/37941513/204335503-6fcc0d57-cc81-4bcb-8e2b-096dfad0dde1.png)


추가도 하고 삭제도 마음 대로 하지만 head를 destroy함수를 만들어서 해줘야한다.

destroy호출하는 순간 헤드로 가서 처음 것 지우고, 두번쨰꺼 지우고 그런식으로 하는 것.

![20221129_020050](https://user-images.githubusercontent.com/37941513/204337395-9ef0b06e-fa93-4330-bec3-b85553b6da6c.png)



그림은 데이터 3개 삽입해놓은 연결 리스트. 이 데이터 3개. 주소들. 이들이 들어간 메모리는 동적 할당으로 만든 거다라고 가정.

즉, malloc()으로 만들어서 struct 크기 만큼 만든 뒤, 뭔가 한 것.
 

p에 헤드를 넣는다. 그럼 p라는 변수가 생김. 포인터 변수인데. head.
 
연결리스트는 가리킨다는 표현밖에 못 씀(주소 직접 쓰면 너무 복잡해지므로)

![20221129_020216](https://user-images.githubusercontent.com/37941513/204337719-9124bce6-b0bf-4107-a874-9609aba446a9.png)



p를 지운다(메모리 해제). 메모리 지우니까 1을 가리키는 것도 존재하지 않음. 그러나 헤드는 여전히 이 주소를 가리킴. 

지워진 애일 뿐이지 더이상 1을 사용하면 안 되는게 전부.

![20221129_020354](https://user-images.githubusercontent.com/37941513/204338067-425b12b6-d066-4557-b090-076fd6535d24.png)


그 다음 줄은 p가 next와 같아짐.

![20221129_020445](https://user-images.githubusercontent.com/37941513/204338214-19d24ac9-b137-4064-b05c-7328227c4261.png)



그리고 앞의 과정 반복.
p는 뭘 가리키지만 사용 안할거기 떄문에 상관 없고 p,next또 같아지고

그러다 next가 NULL이 되는 곳이 있다.

이제 p를 지워주고 p가 next와 같아짐. 

같아지면 p도 NULL이 됨.
p가 널이 되면 끝

![20221129_020633](https://user-images.githubusercontent.com/37941513/204338607-b7dd2211-fee0-417b-a33b-4d9e75ab1516.png)
![20221129_020644](https://user-images.githubusercontent.com/37941513/204338609-601704c3-ddf9-4978-94da-46d44f13d7ba.png)


<br>


그럼 헤드는 아직도 엉뚱한 애를 가리킴. 근데 얘는 일단 주소가 복사되서 온 거기도 하고 실제 이 데이터를 호출한 애가 헤드가 어떤 값을 가지고 있었음.


그럼 지운 뒤 호출자에서 헤드를 NULL로 대입해줘서 더 이상 사용 안한 다는 걸 표현하는 게 좀 더 안전하다.

그래서 코드 위에건  destory() 호출 후 헤드에 NULL을 대입하는 구문도 있었다.

<br>

------


