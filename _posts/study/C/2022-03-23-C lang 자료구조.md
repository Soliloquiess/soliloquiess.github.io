---
title: "[C] C lang 자료구조
"
layout: post
subtitle: C
date: "2022-03-23-08:42:51 +0900"

categories: study
tags: C
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---

### 자료구조 기초

#### 자료구조란

- 컴퓨터에서 여러 자료들을 조직적, 체계적으로 저장하는 방법.
- 보통 동일한 자료형을 여런 저장하는 구조를 의미

- 자료구조에 따라 요소들 사이의 관계를 정의하는 규칙이 있음
- 다음 요인에 따라 상황마다 보다 효율적인 자료구조가 존재

  - 데이터에 접근하는 빈도
  - 데이터에 접근하는 방법

#### 자료구조의 효율성

- 효율성은 주로 시간복잡도를 말함
- 공간 복잡도를 포함하는 경우도 있음
- 따라서 빅오 표기법을 주로 사용

- 보통 효율성을 논할 시 하드웨어 최적화를 고려 안한 이론이 전부

  - 대용량 데이터 사용시 그래도 맞음
  - 적은 용량 데이터는 그렇지 않을 수도 있음.

![20221128_125651](https://user-images.githubusercontent.com/37941513/204190943-42691256-b8b5-48bb-9c62-0b3402415aaa.png)

#### C에서 자료구조를 배우는 이유

- 배열을 제외한 자료구조는 하드웨어 위에서 프로그래머가 만든 개념
- 유수의 석박사들이 만듬
- 우리도 만들줄 알아야함

- 다른 언어에서는 이런 자료구조를 라이브러리로 줘서 직접 구현해가며 배울기회가 적다
- 자칫하면 추상적으로 이해해서 그냥 라이브러리만 쓸 걸 방지
- 포인터 연습하기에도 매우 좋은 기회

<br>

---

#### 자료구조의 시간 복잡도

![20221128_132028](https://user-images.githubusercontent.com/37941513/204193353-1aa94e17-e9d5-4226-8a2c-b1957b7e66ab.png)

<br>

---

### 배열(array)

- 이미 수도 없이 사용함.
- 메모리 한 덩이를 표현하기 위한 가장 간단한 구조
- 여러 자료들을 그 메모리 덩이에 줄줄이 세워놓는 구조
- 각 자료는 색인(index)으로 접근

  - 연속된 메모리니 각 요소의 실제 메모리 상의 위치를 알 수 있음.

  - 위치 = 시작 주소 + sizeof(자료형) \* 색인

#### 배열의 삽입 예

![20221128_132501](https://user-images.githubusercontent.com/37941513/204193829-4f25466d-a93c-47b9-8124-c4b8b57609cb.png)

<br>

---

![20221128_132815](https://user-images.githubusercontent.com/37941513/204194155-ce8fa50a-3e48-48d6-8471-0e3564c9eac3.png)

- 새로운 데이터 들어올 때마다 기존 요소들이 뒤로 밀림.

- 이 다음에 0번째에 데이터를 넣으면 기존 0,1에 있던 값이 1,2로 이동

![20221128_133042](https://user-images.githubusercontent.com/37941513/204194454-a04741c7-9cac-4ef2-a19a-0f1640d798a8.png)

<br>

---

#### 마지막 삽입

![20221128_133144](https://user-images.githubusercontent.com/37941513/204194533-53637888-f9d7-45e7-9ad2-a4b26b680b1a.png)

<br>

---

#### 배열의 삽입

- 배열 맨 뒤에 넣으면 간단히 삽입하고 끝
- 그 외 경우에는 삽입하려는 위치의 요소부터 마지막 요소를 모두 뒤로 한칸 씩 민 뒤에 삽입.

![20221128_133940](https://user-images.githubusercontent.com/37941513/204195361-a1c408bf-a5be-46b7-8466-7780be904994.png)

<br>

---

### 배열의 삭제

![20221128_134402](https://user-images.githubusercontent.com/37941513/204195743-87256408-b43a-4d90-aa94-0244921d4343.png)

![20221128_134448](https://user-images.githubusercontent.com/37941513/204195847-d87dda4d-39ff-407a-8256-8eb0c5de70b4.png)

뒤에 있던 걸 앞으로 복사해오면서 땡겨온다.
결과적으로는 삭제된 부분부터 전체적으로 한칸씩 앞으로 이동.

![20221128_152755](https://user-images.githubusercontent.com/37941513/204208702-7e39ef73-a7e7-4068-82cb-9c58fde31a4f.png)

- 삭제하는 색인을 기준으로 뒤의 값들을 한칸씩 떙김
- 시간 복잡도 : O(n)

<br>

---

### 배열의 검색, 배열의 접근

#### 배열의 검색

![20221128_155129](https://user-images.githubusercontent.com/37941513/204212517-4a2bc1ce-65be-44b5-9137-8699c9a4442c.png)

- 배열 속 요소들을 처음부터 차례로 방문하며, 찾고자 하는 값이 있는 지 확인
  - 있으면 해당 색인 반환
  - 없으면 -1을 반환

![20221128_155245](https://user-images.githubusercontent.com/37941513/204212719-d88e64f0-908d-4a39-8c46-dc3b2fda2efb.png)

- 시간 복잡도 : O(n)

<br>

---

#### 배열의 접근

![20221128_155335](https://user-images.githubusercontent.com/37941513/204212881-64c71163-7d68-4a37-91c5-54e860596f90.png)

- 이미 색인을 알고 있다면 곧바로 접근 가능
- 시간 복잡도 : O(n)

<br>

---

### 스택(stack)

- 자료의 삽입과 삭제에 대한 규칙이 있는 자료구조 중 하나

- 가장 먼저 자료구조에 삽입(push)된 데이터가 제일 마지막에 삭제(pop)됨.

#### 스택을 선입후출 또는 후입선출이라고 함

- 가장 먼저 넣은 값이 가장 나중에 삭제
- 이를 4자로 줄여서 선입 후출(FILO)
- 혹은 가장 나중에 넣은 값이 가장 먼저 삭제되어 후입 선출이라고 한다.(LIFO)

##### 스택은 중간에 있는 자료를 제거할 수 없다. 언제나 맨 위에 있는 자료만 제거가능. 즉 중간에 있는 데이터만 제거가 안됨.

#### 스택 메모리와 개념이 같다.

- 스택 메모리도 같은 개념
- 데이터가 쌓여감에 따라 주소가 감소하므로 반대로 그릴뿐

![20221128_161128](https://user-images.githubusercontent.com/37941513/204215861-e56cfd3b-4b63-4182-b57b-7e2136e4ce82.png)

- 배열로 쉽게 가능
- 그냥 배열의 앞부터 데이터를 추가
- 마지막 요소의 위치를 스택의 제일 위(top)이라고 생각하면 됨.

<br>

---

### 스택의 삽입

#### 스택의 삽입 예

![20221128_162036](https://user-images.githubusercontent.com/37941513/204217283-876099a7-d694-46d5-81fd-d1df89b429b0.png)

#### 스택 삽입코드 예시

![20221128_170342](https://user-images.githubusercontent.com/37941513/204224983-1c67fa51-2396-4730-a9f2-80d5c5b80161.png)

#### 스택의 삽입

- 보통 푸시(push)라고 함

  - 제일 위에 밀어넣는다고 해서

- 시간 복잡도 : O(1)

<br>

---

#### 스택의 제거

- 비어있냐 아니냐 먼저 검사. 비어있는데 빼면 이상한 일 발생

![20221128_171142](https://user-images.githubusercontent.com/37941513/204226383-96bd730d-d14b-4e20-812c-4ed46efed050.png)

- 스택에서 뽑아낸다고 해서 pop이라고 함
- 시간 복잡도 : O(1)

<br>

---

#### 스택의 검색

- 시간 복잡도 : O(n)
- 제일 위부터 찾을 떄 까지 뒤져야 함
- 보통 push()와 pop만 허용하므로 임의의 요소에 접근할 방법이 없다.

  - 그럼 검색은..?

#### 전부 다 뽑고 확인 후 다시 넣어야한다.

- 모든 요소 다 제거 후 원상 복구 해야한다.

![20221128_171400](https://user-images.githubusercontent.com/37941513/204226851-53d8b3d7-42b4-44c3-a95c-ed83b6b14ac6.png)

#### 스택 검색의 시간 복잡도

- 모든 요소 제거 후 다시 원상 복구 해야함
- 그래서 제거에 O(n)+ 복구에 O(n)이 필요
- 따라서 O(2n)이지만 이건 그냥 O(n)이라 말함.

<br>

---

#### 스택의 용도

- 일련의 자료들의 순서를 뒤집는 데 사용
- 왜 뒤집는지

  - 현재 데이터의 순서대로 연산하는 것이 적합하지 않은 경우

- 생각보다 스택이 유용한 곳이 매우 많다.

#### 스택으로 자료순서 뒤집기

- 스택 요소 뽑아서 배열에 저장후 뒤집기

![20221128_173341](https://user-images.githubusercontent.com/37941513/204230788-3dd047bb-d37e-466c-b5cb-1ce8b42d9ecb.png)
![20221128_173358](https://user-images.githubusercontent.com/37941513/204230791-65f337c8-1616-4131-9e50-0ffe1c6a6516.png)

#### 컴퓨터 연산 순서에 맞게 자료 재정리

- 다음과 같은식(문자열로 들어옴)을 평가하는 계산기를 만들면?

```
2*(4+5) -15 /3
```

![20221128_173520](https://user-images.githubusercontent.com/37941513/204231225-1fedce8c-f7eb-4ac5-a312-d276e2eb3967.png)

- 이걸 중위 표기법이라 함(infix)
- 사람들에게 매우 익숙
- 그러나 순서대로 읽으면 평가 불가

<br>

---

- 이걸 후위 표기법(postfix)로 바꾸면 컴퓨터로 연산이 쉽다

![20221128_173719](https://user-images.githubusercontent.com/37941513/204231461-ac5c8be9-f2e8-4f6b-b026-d31c544d3c65.png)

- 중위 ->후위로 바꾸는 것도 스택으로 가능은 함

- 후위 표기법으로 적힌 식은 간단히 스택 이용해서 계산 가능

<br>

---

#### 계산 로직

1 . 한 글자를 읽는다

2 . 글자 읽는데 성공시

- 피 연산자면 스택에 넣는다
- 연산자면, 피 연산자 둘을 스택에 꺼내 연산자로 계산 후 그 결과를 다시 스택에 넣는다.
- 1로 돌아감

3 . 글자 읽는데 실패시(마지막)

- 스택에서 꺼내면 그게 결과

![20221128_174611](https://user-images.githubusercontent.com/37941513/204233136-c179757e-b996-440a-b4de-22f8ba5f8f94.png)

<br>

---

#### 재귀함수 제거에도 용이함

- 재귀함수는 함수 호출트리를 이용
- 함수는 각 호출마다 새로 스택프레임을 만들어서 중간 결과를 저장
- 따라서 스택 자료구조를 이용하면 꽤 많은 재귀함수를 재귀없이 반복문으로 구현 가능

<br>

---

### 큐(Queue)

- 스택과 마찬가지로 자료의 삽입과 삭제에 대한 규칙이 있는 자료구조 중 하나

- 가장 먼저 자료구조에 삽입 된 데이터(enqueue)가 제일 처음에 삭제(dequeue)됨.

![20221128_191102](https://user-images.githubusercontent.com/37941513/204251452-ec2ebb0e-ce27-417b-9f63-020c312d0f95.png)

#### 큐 역시 임의 접근은 안됨

- 언제나 제일 처음에 있는 자료만 제거 가능
- 중간 자료로 임의 접근 안됨

![20221128_191148](https://user-images.githubusercontent.com/37941513/204251604-a0820418-1f14-4089-999f-0e4840c10fc4.png)

#### 큐의 비 효율적인 구현

- 그냥 배열 사용시 큐를 구현할 수는 있다
- enqueue하면 그냥 제일 뒤에 추가 O(1)

![20221128_191248](https://user-images.githubusercontent.com/37941513/204251839-9054556e-c3f1-489d-aa5f-26e24e73ff1b.png)

- dequeue하면 그냥 제일 앞에서 삭제 O(n)

![20221128_191439](https://user-images.githubusercontent.com/37941513/204252224-1ab2c79d-97eb-4b76-a5a3-ca3b988fddd5.png)

##### 근데 큐의 삭제도 O(1)아닌가?

#### 큐의 삭제를 O(1)로 만들려면

- 내부적으로 배열 사용하되, 원형 버퍼(ring buffer)의 개념을 이해하면 가능

  - 어느 위치든 시작과 끝이 될 수 있다.

![20221128_191550](https://user-images.githubusercontent.com/37941513/204252451-bf269156-e84b-47dd-a266-56d4aa288e73.png)

<br>

---

### 큐의 삽입

#### 큐 삽입 예



![20221128_233052](https://user-images.githubusercontent.com/37941513/204308083-12d04f04-cb6d-422e-8253-b2006da1249c.png)


![20221128_235638](https://user-images.githubusercontent.com/37941513/204309106-24fce206-0d20-4fdf-babb-448b14bff796.png)


s_front, s_back, s_num_count는 0으로 시작

s_back은 되돌이 표 하는 연산

데이터 삽입하다 보면 보임.

![20221129_000035](https://user-images.githubusercontent.com/37941513/204310191-e996bb83-1992-4fbe-9817-d33df74383d8.png)


s_front와 s_back이 같은 배열 인덱스에 위치했다. 일직선이지만 원형으로 보면 됨.

s_back에서 집어넣는 걸 판단하고 현재 뺴야하는 위치 바꿈

#### 큐의 삽입


![20221129_002504](https://user-images.githubusercontent.com/37941513/204315699-e624756f-e6e5-45d0-a426-d27f24d04746.png)


- 보통 enqueue라고 함
  - 줄 제일 뒤에 세운다는 의미

- 시간 복잡도 : O(1)

<br>

----

### 큐의 삭제

#### 큐의 삭제 예

![20221129_002635](https://user-images.githubusercontent.com/37941513/204316102-aaf1c6a7-3b08-4898-8bca-4e0043503eeb.png)



<br>

-----

#### 큐 삭제 예시

![20221129_003156](https://user-images.githubusercontent.com/37941513/204317377-3b355324-a5d3-4d8a-a5ac-3588207b0434.png)


![20221129_003326](https://user-images.githubusercontent.com/37941513/204317724-6ae8779a-c67c-4c34-a860-9c14d870aafe.png)


5에서 4로 감소

리턴하면 10 반환하니 item도 10 


<br>

------

#### 큐의 제거

![20221129_003405](https://user-images.githubusercontent.com/37941513/204317878-04be1481-3113-4061-a902-6f288f941202.png)


- dequeue라고 함
  - 앞에서 하나 빼온다

- 시간 복잡도 : O(1)


<br>

-------


### 큐의 검색

- 시간 복잡도 : O(n)
- 제일 처음부터 찾을 떄까지 뒤져야 함
- 스택과 마찬가지로 보통 enqueue, dequeue만 허용하므로, 임의의 요소에 접근할 방법이 없다.

##### 큐도 다 뽑아서 확인해야 한다.
- 모든 요소 다 제거했다가 다시 원상복구 해야됨.

![20221129_004511](https://user-images.githubusercontent.com/37941513/204320495-561c9038-4d44-4a18-9a06-a5b7f49b608e.png)

![20221129_004530](https://user-images.githubusercontent.com/37941513/204320530-621e6857-842c-4644-b991-79c0814c66f6.png)



<br>

---------

#### 큐 검색의 시간 복잡도

- 스택과 똑같음
- 모든 요소를 다 제거했다가 원상복구 해야함
- 그래서 제거에 O(n)+ 복구하는데 O(n)이 필요

- 따라서 O(2n)이지만, 이건 그냥 O(n)이라고 말함.


<br>

----


#### 큐의 용도

- 현실 세계에서 대기줄이 필요한 경우에 다 가능
- 데이터 유입 속도가 소모속도보다 빠른 경우
- 데이터 제공자의 수가 소비자의 수와 다른 경우
  - 예: 은행 창구는 여럿인데 줄은 한줄로만 설 떄
  - 멀티 쓰레딩에서도 이런 일들을 함

- 입출력 스트림 버퍼링도 같은 개념

<br>

---- 

#### 연결 리스트, 연결 리스트의 삽입/제거/검색


- 면접시 자료구조 구현하라면 가장 많이 나오는 중 하나가 연결리스트

- 연결리스트, 해시맵, 해시테이블 이 3개가 가장 많이 묻는 질문.

- 기본기도 아님. 당연히 해야하는 것. 실력 좋은 프로그래머라면 당연히 안보고 할 수 있어야 하는 것 들 

<br>

--------


#### 지금까지 위의 자료구조들

- 여태껏 본 자료구조들은 메모리에서 연속된 저장 방법에 기초한다.

![20221129_010101](https://user-images.githubusercontent.com/37941513/204323997-0922b3c3-e309-44d6-a85d-5bbb828a6c75.png)


<br>

---------




#### 그러나 연결 리스트는 다름

- 여태껏 본 자료구조들은 메모리에서 연속 된 저장방법에 기초
- 연결 리스트는 그런 제약을 깸

<br>

----

#### 연결리스트(linked list)

- 자료들이 메모리에 이렇게 산재해있음
  - 연결 리스트의 각 자료를 노드(node)라 부름

![20221129_010629](https://user-images.githubusercontent.com/37941513/204325351-e517e939-a561-4773-a6e9-4f731e091a97.png)


- 자료형이 어떻게 산재할 수 있는지?
  - 동적 메모리 할당으로 필요에 따라 각 노드를 할당.

#### 근데 서로 어떻게 연결하는지

- 그 둘 사이의 선후 관계를 별도로 지정

  - 어떻게? 다음에 오는 노드 메모리의 주소를 기억
  - 어디에? 노드에 있는 포인터 변수에

  - 제일 마지막 노드는 다음에 올 노드가 없으니 널 포인터


![20221129_011958](https://user-images.githubusercontent.com/37941513/204328296-cb36ac80-9467-4e58-aee1-ec91e299376a.png)


- 노드는 서로 가리키는게 있다.

- 앞의 노드(데이터)에서 다음 노드가 있는 것의 주소를 가리킨다. 메모리 상 위치가 어디든 상관 없고 중요한 건 내 데이터의 다음 데이터를 가리키는 포인터가 있다는 점이 중요하다.

- 이 전체를 노드라고 한다. 이 노드 안에 있는것이 데이터. 

- 그리고 다음 노드로의 포인터, 다음 노드를 가리키는 포인터, 노드 기반 에디터와 같은 개념

- 처음은 아무도 처음 노드를 가리치지 않으므로 헤드라고 한다. 

- 마지막은 아무것도 가리키지 않으므로 널 포인터를 가지낟. 이걸 테일이라고 한다. 

<br>

----


#### 연결리스트는 어려울 수 있는 자료구조

- 연결리스트는 매우 훌륭한 면접문제
  - 메모리 관리 능력
  - 이중 포인터 사용 능력


- 여태까지 설레설레 자료구조 봤어도 이건 집중해서 봐야한다.

<br>

-----


#### 연결리스트의 삽입

- 이미 삽입할 위치를 알면 O(1)

10 다음 넣고 싶다. 10이 30의 주소(포인터로)를 가리키고 있는데 20으로 얘를 가리키게 한다. 

즉 10에 든 주소를 20으로 옮기고 20의 주소를 30으로 가리키게 한다. 그럼 노드의 순서가 변경된 것

삽입할 위치만 알면 포인터 2개만 바꾸면 되니까 O(1)이라는 것. 

- 밀고 당기고의 개념이 없다. 포인터로 다음 노드만 가리키면 됨

![20221129_012752](https://user-images.githubusercontent.com/37941513/204329918-fabbde15-f0a7-453a-b84d-bbccd30a7b4e.png)



<br>

----




#### 연결 리스트의 제거


30을 제거하고 싶은데 30을 뿅 제거하는게 아니라 30이 40을 가리키고 있었으니까 내 앞의 애가 30의 다음 애를 가리키게 하면 됨.

즉 30에 들어있던 주소값을 10 여기에 있는 주소값에 대입 시, 원래 30 가리키던 새로운 값이 대입 되니까 40을 가리키게 된다. 

그래서 다음 가리키는 애만 누군지 바꿔주는 것으로 10,40,NULL을 알 수 있게 된다.

#### 연결 리스트의 검색

- O(n)
- 제일 첫 노드부터 찾을 때 까지 찾아야 함
  - 보통 이 노드를 헤드라고 부름


- 색인으로 접근 불가능
- 이렇게 찾은 뒤 삽입을 하면 O(1)이 되는 것


![20221129_013146](https://user-images.githubusercontent.com/37941513/204330761-d160a83f-6535-48b3-8064-8a09eba5e807.png)


만약 찾으려면 색인 0,1,2이런 개념이 있으려면 배열의 주소가 있고 오프셋을 바로 계산할 수 있어야 하는데 이건 불가

- 워낙 메모리가 산재해 있으므로 하나씩 찾아가는 것


그럼 찾는 개념은 뭔가?

35보다(들어가는 값보다) 작은 값이면 다음으로 건너뛰어야 하고, 큰 값을 보면 전 것과 지금 사이에 넣어야 함


어쩄든 먼저 찾는 것은 O(n)

일단 찾는 위치만 결정하면 실제 삽입하는 건 O(1)

- 삽입한 뒤 데이터를 밀고 당기고 하는게 없기 떄문

![20221129_013146](https://user-images.githubusercontent.com/37941513/204332484-ff8348e6-f62c-4c53-8515-5d7db54a914b.png)


![20221129_014023](https://user-images.githubusercontent.com/37941513/204332591-8b7aac42-bd98-4c43-b571-9ce5d700f4db.png)


35를 넣으려면 헤드부터 찾고 30인 헤드면 다음부터 찾은 뒤 40을 찾고 40을 찾았으면 이 전에 넣어야 되는걸 알고 연결 시키면 된다. 

그래서 찾는 과정은 O(n)


<br>

------

#### 연결 리스트: 전체 출력 예 & 노드 메모리 해제 예, 헤드 노드

![20221129_014202](https://user-images.githubusercontent.com/37941513/204332965-ef9c8faa-df5c-4275-8c54-010e445a1602.png)

노드는 어떻게 만드나?

노드는 두가지 데이터를 담고 있다.
  - 실제 데이터와 다음 노드로의 주소

그래서 구조체 필요
처음은 값
두번쨰는 다음 노드로의 주소(다음 노드 가리키는 포인터)


그리고 이 연결리스트를 출력하려면?


링크드 리스트는 기본적으로 어떤 크기가 잡혀있는 리스트가 아니다.

그렇기 떄문에 이걸 함수로 만들어놔도 데이터는 자유롭게 추가가능하니까 어떤 크기용 전용 함수가 아니라서 전역변수를 쓸 일도 없고 편하다

이건 함수를 많이 만든다. 
다음에 이 노드 출력하고 그 다음 것 출력하고, 그다음 노드 출력하고,  그 다음 노드가 널 포인터면 마지막 노드다.


처음부터 끝까지 훑는 반복문. 그래서 p를 만들고 p에 헤드를 대입함.

즉, p로 다음노드 계속 가겠다는 의미(포인터로)

그럼 NULL이면 그냥 끝. NULL이 아니면 출력하라 하고 p->value를 출력.

출력한 뒤 나를 다음 노드로 옮기라는 걸 해줘야 됨.

  - p->next로 내 다음 주소를 다시 나한테 대입하라고 지시.

  - 그 순간 p는 다음노드를 가리키게 됨


<br>

-------

#### 헤드 노드

- 연결 리스트의 첫번쨰 노드를 가리키는 포인터

- 처음 시작할 때 값은 NULL
  - 아직 노드가 하나도 없기 때문
  - 여기다 새로운 노드를 동적 할당해서 대입해 줌

- 처음 시작시 헤드는 아무것도 가리키지 않음.

- 얘 포인터로 포현한 것


```
note * head = NULL;
```

![20221129_014916](https://user-images.githubusercontent.com/37941513/204335024-b1051685-711a-4ee1-b628-74d4ff0ca038.png)

- 만약 포인터가 아무것도 가리키지 않으면 사선 그어서 표현

<br>

----

##### 메모리를 동적할당하면 반드시 해야하는 일이 있다. - > free() 추가 


destroy()함수 추가

![20221129_015148](https://user-images.githubusercontent.com/37941513/204335503-6fcc0d57-cc81-4bcb-8e2b-096dfad0dde1.png)


추가도 하고 삭제도 마음 대로 하지만 head를 destroy함수를 만들어서 해줘야한다.

destroy호출하는 순간 헤드로 가서 처음 것 지우고, 두번쨰꺼 지우고 그런식으로 하는 것.

![20221129_020050](https://user-images.githubusercontent.com/37941513/204337395-9ef0b06e-fa93-4330-bec3-b85553b6da6c.png)



그림은 데이터 3개 삽입해놓은 연결 리스트. 이 데이터 3개. 주소들. 이들이 들어간 메모리는 동적 할당으로 만든 거다라고 가정.

즉, malloc()으로 만들어서 struct 크기 만큼 만든 뒤, 뭔가 한 것.
 

p에 헤드를 넣는다. 그럼 p라는 변수가 생김. 포인터 변수인데. head.
 
연결리스트는 가리킨다는 표현밖에 못 씀(주소 직접 쓰면 너무 복잡해지므로)

![20221129_020216](https://user-images.githubusercontent.com/37941513/204337719-9124bce6-b0bf-4107-a874-9609aba446a9.png)



p를 지운다(메모리 해제). 메모리 지우니까 1을 가리키는 것도 존재하지 않음. 그러나 헤드는 여전히 이 주소를 가리킴. 

지워진 애일 뿐이지 더이상 1을 사용하면 안 되는게 전부.

![20221129_020354](https://user-images.githubusercontent.com/37941513/204338067-425b12b6-d066-4557-b090-076fd6535d24.png)


그 다음 줄은 p가 next와 같아짐.

![20221129_020445](https://user-images.githubusercontent.com/37941513/204338214-19d24ac9-b137-4064-b05c-7328227c4261.png)



그리고 앞의 과정 반복.
p는 뭘 가리키지만 사용 안할거기 떄문에 상관 없고 p,next또 같아지고

그러다 next가 NULL이 되는 곳이 있다.

이제 p를 지워주고 p가 next와 같아짐. 

같아지면 p도 NULL이 됨.
p가 널이 되면 끝

![20221129_020633](https://user-images.githubusercontent.com/37941513/204338607-b7dd2211-fee0-417b-a33b-4d9e75ab1516.png)
![20221129_020644](https://user-images.githubusercontent.com/37941513/204338609-601704c3-ddf9-4978-94da-46d44f13d7ba.png)


<br>


그럼 헤드는 아직도 엉뚱한 애를 가리킴. 근데 얘는 일단 주소가 복사되서 온 거기도 하고 실제 이 데이터를 호출한 애가 헤드가 어떤 값을 가지고 있었음.


그럼 지운 뒤 호출자에서 헤드를 NULL로 대입해줘서 더 이상 사용 안한 다는 걸 표현하는 게 좀 더 안전하다.

그래서 코드 위에건  destory() 호출 후 헤드에 NULL을 대입하는 구문도 있었다.

<br>

------


###   연결 리스트: 삽입하기 예

![20221129_204513](https://user-images.githubusercontent.com/37941513/204520752-98813217-7a7d-4503-9fc0-fd247e20b118.png)





#### 맨 앞에 삽입하는 코드 
![20221129_212900](https://user-images.githubusercontent.com/37941513/204529424-a219ef3c-a1ee-423c-81fc-0ef19c3cd9e5.png)


new_node->next
head의 주소는 NULL이라 가정하고 보자
연결리스트라 헤드는 널에서 시작


그리고 새 노드 만듬. 동적할당 node_t만큼의 크기로 만든다.

임시적으로 400이라는 주소에 만든다. 3을 대입하고 포인터로 new_node->next로 다음을 가리킨다. 



#### 최종형태

![20221129_213355](https://user-images.githubusercontent.com/37941513/204530420-37526047-a92c-4c1e-838e-e3a81aef8f4d.png)


3,5,2,0 순으로 삽입했는데 헤드 위치에 삽입 했기 떄문에.

근데 왜 insert_front()시 이중 포인터를 넣어줬나? 호출시 헤드를 그냥 대입 안해주고 그 헤드의 주소를 넣었나? 

헤드도 이미 포인터인데 걔를 왜 주소에 넣었냐는 소리.


<br>

----



만약 이중포인터가 아닌 일중 포인터면 head의 포인터 값 복사해감. 즉 NULL을 복사해가는 것. 

그럼 head는 원래 있고 메인함수에. 얘가 가리키고 있던 애를 phead로 복사한 것.

 phead는 원래 널이였다가 새로운 요소를 대입하면서 다음을 가리키게 됨. 새 노드를 대입하면서(insert) 다음을 가리켜 감. 

 ![20221129_213935](https://user-images.githubusercontent.com/37941513/204531639-81426640-857c-47aa-8232-d4311ae06584.png)


 그리고 함수 돌면 사라짐.

 그리고 헤드는 널인채로 남고 malloc한 것들은 free로 사라짐. 그럼 헤드가 다음 새노드를 못 가리키게 되고 메모리 누수가 발생 

 그래서 원본을 바꾸라면 값에 의한 복사가 아닌 참조에 의한 복사해야 하므로 이중 포인터.

 일중 포인터는 값에 의한 복사라 값을 못 바꾸게 됨.


![20221129_213952](https://user-images.githubusercontent.com/37941513/204531661-dffcff82-573f-4c7a-8472-a8b873d0c74b.png)


<br>

연결리스트 오름차순 삽입도 유사하다.

-------------

#### 연결 리스트: 노드 삭제

#### 삭제하는 코드

![20221201_213407](https://user-images.githubusercontent.com/37941513/205054216-070684fd-46fb-4786-b509-3b009f687208.png)


![20221201_214201](https://user-images.githubusercontent.com/37941513/205055618-91fd014b-abf3-40d4-8c69-d005e0b10969.png)


head는 다음 노드를 가리키고 있어서 NULL이 아님. 어떤 주소를 가리키고 있음.

그 뒤 while문으로 들어간다. 이게 pp로 간다 그리고 이게 가리키는 것의 값이 똑같은지 본다.

이 pp가 pp에 가고 tmp라는 변수에 주소를 저장한다. 

head가 가리키는 거나 tmp가 가리키는 거나 똑같이 되는 것.

![20221201_215046](https://user-images.githubusercontent.com/37941513/205057393-5203cd63-d370-4b98-b1f5-304fb1a6b80a.png)


![20221201_215143](https://user-images.githubusercontent.com/37941513/205057595-514e492d-0a2d-4964-934d-4c9f68c98363.png)

이제는 헤드가 2가 아닌 3을 가리키게 됨.

pp가 화살표 따라서 역참조 한다. 화살표 따라가고 next를 가져옴. 그 값을 헤드에 대입해주고, 결과적으로 전에 가리키던게 head가 가리키게 됨. 전에 가리키는 것은 끊어지게 된다.

중간 하나만 지우고 break 후 나오면 됨.


![20221202_013231](https://user-images.githubusercontent.com/37941513/205107801-a01dabd2-7853-48e0-ba74-632c151781d4.png)


맨 뒤를 지울 떄도 마찬가지 

그 전에 tmp만들어서 5를 기억한다. 왜냐면 이걸 기억 안 해두면 못 지우기 떄문.

지울 거니까 밑으로 빼주고 pp로 가서 (화살표 따라가서)지운 후  널이 되버리고 
그떄 끊어짐. 이떄 tmp가 없으면 주소가 없으니까 못 지움.


pp가 가리키는 곳을 들어간다, 화살표 따라간다 등을 잘 알아두자.



<br>

-------


####   연결 리스트의 용도


- 스택/큐와 같은 특성(삽입/삭제 방향) 떄문에 자주 쓰는 자료구조는 아님.
- 오히려 길이를 자유롭게 늘이거나 줄이기 떄문에 배열의 한계를 넘으려고 만든 자료구조
- 즉, 최대길이를 미리 특정할 수 없고 삽입/삭제가 빈번할 시 사용

<br>

- 오늘날 어플리케이션 프로그램에서 사용빈도는 많이 줄음
- 기본적으로 동적할당 배열을 더 흔히 사용
  - 캐시메모리에 들어갈 정도로 조그마하면 배열 쓰는게 좋긴 함.

  - C#에서 List도 연결리스트가 아니라 동적 할당 배열임
  - 최신 하드웨어 특징 상 배열이 보장하는 훌륭한 메모리 지역성(인접한 메모리를 사용)이 성능에 유리한 경우가 많기 때문
- 하지만 커널 모드 프로그래밍(예: 드라이버)에서는 여전히 많이 사용
  - 커널은 굉장히 빨라야함.
  - 배열은 땅기고 밀고 이러는게 굉장히 번거로움
  - 링크드리스트는 메모리 충분히 잡아두고 이건 잠시 뺴두고 쓸떄 가져오고 이러기가 가능
  - 어디에서 가져오든 다음 포인터 쓰다가 반납시 해제가 아닌 따로 관리해서 다음꺼 포인터 연결하다가 안쓰면 포인터 끊고 이럼. 이게 메모리풀

  - 동적 메모리 할당 안하고 자기 메모리 안에서 재빠르게 사용할 노드 뺴고 넣고 이러는 건 배열보다 빠르기 떄문.

  - 메모리 지역성을 해치지 않으면서도, 충분히 큰 메모리(ex: 4kb)를 미리 할당
  - 필요에 따라 그 메모리를 쪼개 연결리스트의 노드로 사용(예: 메모리풀)
- 참고로 배열다음으로 많이 사용하는 자료형은 해시맵.


<br>

#### 연결리스트에서 진화한 것들

- 단일 연결리스트
  - 우리가 살펴본 연결리스트의 형태
  - 다음 노드를 가리키는 포인터만 저장

- 그 전의 노드를 가리키는 포인터도 저장하는 이중 연결리스트도 있다.
- 이중 연결리스트는 보통 head외에 tail 포인터 변수도 가지고 있다.

![20221202_014730](https://user-images.githubusercontent.com/37941513/205111140-966a9b0a-f030-4c60-b701-10c333037a23.png)



<br>

--------


### 해시 테이블

- 자료구조 중 가장 중요한 둘 중 하나(하나는 배열, 하나는 해시테이블)

- 여태 자료형과 달리 해시테이블은 잘 사용하면 컴퓨터 공학에서 사용할 수 있는 곳이 매우 많다. 그래서 주니어 개발자들 뽑을 때 해시테이블을 잘 알고 있냐. 실제 구현할 수 있냐로 기본기를 판단하기도 한다.

- 다른언어에선 직접 쓸 일은 없다. 그래도 직접 만들수 있어야만 도움이 된다

![20221205_013431](https://user-images.githubusercontent.com/37941513/205503352-d53f7e4c-04ec-49cd-bf71-d0f89e7f3fa7.png)


배열이 O(n)인 이유나 스택에서도 검색이 O(n)일수 밖에 없는 이유를 알 수 있어야 한다.

삽입삭체는 정해진 위치에서 하니까 O(1)

큐도 마찬가지였고 스택과 큐는 속도 향상보다 데이터를 어떻게 모양을 잡아두느냐 그것에 따른 유용한 용도들, 알고리즘 같은데, 사용할 수 있는게 보임

연결리스트는 중간중간 필요에 따라 노드를 만들었으므로 동적 할당 같은게 많이 필요함.

그래서 삽입과 삭제 위치를 알면 O(1)으로 가능한 특별한 것.

- 근데 해시테이블은 동떨어져 있음. 

O(1)인데 최악은 O(n)
최악으로 가는 경우는 별로 없어서 보통으로 생각하긴 함

<br>

----------

O(1)이 가능하려면 어떤 메모리 주소에 어떤 데이터가 저장되어 있는지 한방에 알 수 있어야 한다

<br>

------

#### 무작위로 뽑은 10개를 저장하는 법

- 가장 흔하게 했던 건 크기 10인 배열에 차례로 저장시 O(n)으로 가능

![20221205_015341](https://user-images.githubusercontent.com/37941513/205504334-a9bc2467-14cd-40b7-b560-4f86464c033a.png)


이걸 O(1)으로 알 수 있을까(해시테이블을 모른다는 가정 하에)

<br>

----

#### 방법1 . 입력의 최대값을 배열 크기로

- 가장 단순무식한 방법

1 . 입력의 최대값 만큼 긴 배열을 만듬

2 . 배열[입력값]에 값이 있으면1, 없으면 0을 저장
  - 즉, 이 경우는 입력값이 배열의 색인

![20221205_020016](https://user-images.githubusercontent.com/37941513/205504616-e890cd3d-cedc-4aad-a191-62151d511910.png)


<br>

------

#### 방법 1의 문제

![20221205_020549](https://user-images.githubusercontent.com/37941513/205504896-3e713987-ea18-447c-8b38-bf7b30a6f35e.png)


- 입력값이 엄청 크다면?
  - 무작위로 뽑은게 23913456

- 배열의 크기를 무한히 늘릴수도 없다.

  - 2의 32승이면 4기가
  - 비효율의 극치

<br>

----------


#### 해시테이블의 크기는 2배 이상인 소수로



- 입력값이 10개면 배열이 좋다.
- 그러나 엄청나게 큰 입력값이면?

  - 크기만큼 배열값 잡으면 제대로 작동 안하고 0~끝까지 안 사용하는 데이터도 많다.

- 즉, 자료(입력)->색인(출력)으로 만드는 함수
- 단 출력값을 찾을 때 반복문 없이 O(1)이어야 한다

<br>

-----

#### 방법2의 문제
- 동일한 색인이 들어가는 데이터들이 생김
- 배열의 크기를 충분히 잡고 10이 아닌 20으로 나누면 겹칠 확률이 줄어둠

![20221205_021229](https://user-images.githubusercontent.com/37941513/205505215-c9da4a37-0145-43a7-b360-ec4e5374b21e.png)

<br>

-------

#### 배열의 크기를 두배로

- 겹치는 색인 아까보다 덜 생기나, 여전히 존재 

![20221205_021601](https://user-images.githubusercontent.com/37941513/205505389-54f900ae-ae7b-4226-bb02-a83a6c841754.png)


#### 방법 3의 보완: 가장 좋은 방법 -> 소수도 사용


![20221205_022518](https://user-images.githubusercontent.com/37941513/205505808-607d1a4b-8acd-448d-93e3-0cfaba209f98.png)


- 흔히 다음과 같이 하는게 좋다고 말함

1 . 배열의 크기는 최소 2배

2 . 크기에는 소수(prime number)사용


- 소수로 나눠야 동일한 색인이 안 나올 가능성이 높다.

  - 소수를 사용하는 이유는 배열의 크기만큼 나누기를 함. 그러면 어떤수로 나눠야 중복이 나올 가능성이 가장 적게 만들어 주는게 소수

  - 자연에서도 마찬가지 이유 소수가 많이 발견된다.

![20221205_022429](https://user-images.githubusercontent.com/37941513/205505799-0fae3058-5e0a-4e47-babe-fa64c59b36d0.png)


- 그래도 중복이 아예 없을 수는 없다.

- 그래서 색인시 중복을 줄이고 또 다른 해법을 찾아야 하는데 이 중복 색인을 해결하기 위해서는 뭘 해야하나.