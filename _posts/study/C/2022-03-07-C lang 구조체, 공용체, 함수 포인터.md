---
title: "[C] C lang 구조체, 공용체, 함수 포인터"
layout: post
subtitle: C
date: "2022-03-07-08:42:51 +0900"

categories: study
tags: C
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---


### 구조체, 구조체의 필요성

#### 구조체란(structure)

1 . 클래스를 배우러 가는 과정에서 여러가지 형의 데이터만 모아둔 아이

2 . 클래스를 배운 뒤, 참조형이 아닌 값형인 커스텀 데이터형

<br>

-------


#### C에서 구조체는 첫번쨰 개념과 같다.
- 데이터의 집합. 멤버함수는 없다
- 여러 자료형을 가진 변수들을 하나의 패키지로 만들어 둔 것.


<br>

------

#### 구조체는 참조형 아니면 값형?

- C에서는 모든 자료형이 값형(모든 데이터!)
- 하지만 주소 전달하면 참조형 처럼 사용 가능(참조형 처럼 쓰고 싶으면 주소 전달하면 됨)
- 즉, 주소를 전달하지 않는 한 값형
- 일관적이여서 좋은 언어

<br>

-------

#### 구조체의 필요성

1 . 사람은 세상을 바라볼 떄 물체 단위로 봄.

size_t hour = 2; 
size_te minutes = 39;


2 . 구조체를 사용시 실수도 막을 수 있다.

```
if(is_monday(2043,10,1)){
    run_format();
}
```

위 코드가 틀렸을수도 있다.

![20221108_002433](https://user-images.githubusercontent.com/37941513/200347577-fe5206f1-5417-45bf-8e39-ce695876ab50.png)



<br>

------

#### 컴파일러는 뭐가 틀렸는지 알 수 없음.

같은 형의 데이터 여러개를 매개변수로 받을 때 순서 바뀌면 컴파일러가 실수 찾을 방법이 없다.

![20221108_002815](https://user-images.githubusercontent.com/37941513/200348448-ed06d653-81c6-4a06-89a5-2455cfe814be.png)

<br>


#### 묵시적으로 변환 가능한 자료형이 여러개일 떄도 마찬가지.

- 매개변수 길어지면 마찬가지로 문제
- 그냥 눈으로 보면 실수를 놓치기 쉽다.
- 중간에 매개변수 바꿔도 문제.

![20221108_002734](https://user-images.githubusercontent.com/37941513/200348272-5d69c39d-2630-4716-bae4-acf6bfe96c61.png)

<br>

#### 실수 막으려 또 다른 실수 초래가능

![20221108_002857](https://user-images.githubusercontent.com/37941513/200348677-281f13e3-bc80-4253-b3cc-adb203672a46.png)


<br>

**실수를 줄이려면 원자성을 보장하는 연산(atomic operation)을 사용하는 게 좋다.

<br>

---------


### 구조체의 선언 및 사용


#### 실수 없이 한번에 구하려면 구조체


![20221108_003229](https://user-images.githubusercontent.com/37941513/200349448-834181f6-8de9-424c-97c4-660b1ca19c8c.png)


![20221108_003351](https://user-images.githubusercontent.com/37941513/200349956-21b357b1-5003-4dc1-bfbb-6bb5f7350a11.png)


#### 당연히 지역변수 선언시 0으로 초기화 안된다.

![20221108_003532](https://user-images.githubusercontent.com/37941513/200350172-e20df57b-4655-415a-9ac1-d9ca3f0e3536.png)


<br>

#### 너무 장황한 구조체의 데이터형
 
```
struct date date
```

date라는 이름의 나만의 자료형을 만들어 쓰는줄 알았는데..
- 기본 자료형은 자료형 + 변수명인데( int date)

- 왜 구조체(내가 만든 형은) struct date가 자료형인가?

<br>

------

###  typedef 이란?, typedef 사용법

#### typedef
```
typedef unsigned int size_t
```

- 이미 있는 자료형인 unsigned int에 새 별명 지어줌.
- 그 새로운 이름은 size_t
    - 근데 그냥 unsigned int 써도 전혀 상관 없음.
    - 서로 바꿔가며 써도 된다
- 물론 size_t의 경우는 각 구현마다 자료형이 달라질 수 있어서 typedef를 해놓은 것.

<br>

#### typedef 사용법

- 아무튼! 구조체 typedef를 쓰면 다른 자료형처럼 간결하게 변수 선언이 가능


![20221109_224233](https://user-images.githubusercontent.com/37941513/200853368-f567d9d2-dd95-4610-99ac-37c3f4ddea3b.png)


![20221109_224459](https://user-images.githubusercontent.com/37941513/200854451-51783859-c4db-4c5a-a5da-1a8166598510.png)


- 어느 방법을 써도 크게 상관 없음
- 참고로 C에서 _t로 끝나는 자료형은 보통 이렇게 Typedef 한 것들

#### enum도 마찬가지

![20221109_233118](https://user-images.githubusercontent.com/37941513/200857319-60dbc42d-827c-496a-ae0d-7e7cfce4587c.png)


game_role_t를 만들어주면 이걸 사용해서 변수 선언이 가능해진다.

공용체도 사실 같은 방식. 공용체 선언하고 만들떄 그대로 쓴다.

#### 코딩 표준 : 커스텀 자료형에 typedef를 쓰자.

- 가능하면 구조체, 열거형, 공용체에 typedef를 써서 제대로 된 자료형처럼 보이게 하자
- 강제사항은 아님.

<br>

----------


###  구조체 변수 초기화 하기


#### 구조체 변수 초기화하기

- 아까도 말했듯이 구조체 선언과 동시에 초기화 안 됨.
    - 스택에 남아 있는 데이터를 그대로 사용


![20221109_234839](https://user-images.githubusercontent.com/37941513/200861688-25f4eeac-efde-467e-8804-07375b96af60.png)


- 아까도 말했듯이 구조체 선언과 동시에 초기화 안 됨
    - 스택에 남아있는 데이터를 그대로 사용
- 그냥 구조체는 지역변수를 여러개를 따로따로 사용하는 것과 마찬가지라고 생각하자
    - 사실 기계는 구조체라는 개념 자체를 모른다.
    - 그냥 프로그래밍 언어가 프로그래머 편하고 실수하지 말라고 제공해준 개념이다.
    - 실제 하드웨어는 우측 기반으로 돈다(오른쪽 사진)

<br>


-----

#### 궁금하면 메모리/어셈블리 보면 됨

![20221110_002304](https://user-images.githubusercontent.com/37941513/200870434-ab3ac912-8507-48a2-bf88-f01c1cac02c8.png)

이 두개는 같은걸까?

![20221110_002602](https://user-images.githubusercontent.com/37941513/200870864-7022a498-56d3-411c-bd4e-0f4cd617e6b7.png)

#### 컴파일러 입장에선 똑같은 코드로 인식하고 스택에 다 넣어준다.

![20221110_003023](https://user-images.githubusercontent.com/37941513/200872793-9f57a6d7-07bb-44ba-b44c-de8a5ffd16e0.png)

<br>

-----


#### 또 다른 구조체 초기화 방법

```
date_t date = {0,};
```

- 아님 이렇게도 가능
- 배열 초기화 떄 썼던 방법
- 컴파일러 따라 그냥 date 가 차지하는 모든 메모리 공간을 0으로 채워주는 명령어로 바꿔줄 수도 있음.
    - memset()
    - 배열도 이렇게 초기화 되기도 한다.

<br>

-------

#### 요소 나열법으로 초기화


![20221110_003820](https://user-images.githubusercontent.com/37941513/200873943-7e7ecf3a-e9cd-48f4-962b-204f413dadfd.png)


- 근데 되도록이면 이 방법은 추천하지 않음
- 실수할 여지가 있다.

- 나중에 다른 프로그래머가 구조체 멤버변수 순서를 바꾸고 변수 초기화 목록을 안 고치면 문제가 됨

    - 그 버그가 생긴지도 모른 채 시간이 꽤 흐를 수 있다.

![20221110_004347](https://user-images.githubusercontent.com/37941513/200875311-188720e7-a6b5-4d94-acab-3c3334c56eb7.png)

#### 요소 나열법이 유용한 경우는 딱 한가지


- 멤버변수가 const일떄, 선언 시 초기화 안 하면 다시는 못함

![20221110_004607](https://user-images.githubusercontent.com/37941513/200875720-170a3313-a280-454b-97cb-7bacb4579115.png)


- 근데 const멤버 변수는 잘 쓰지도 않고 쓰지 말라는 게 업계 표준
    - const는 쓰는거 보다 안쓰는게 더 좋다(안 쓸때가 더 장점이 많다..)

<br>

------

### 구조체 매개변수

- 클래스랑 똑같네?

1년 더하는 코드(안됨)


![20221110_005944](https://user-images.githubusercontent.com/37941513/200879031-655ba329-fca8-4e70-a5a3-70bdadfef651.png)


#### 구조체는 값형이다

- 값형이다. 참조형이 아님
- C에서는 자료형은 전부 똑같이 작동함


#### 인자 전달도 기본 자료형과 똑같이 작동


![20221110_010630](https://user-images.githubusercontent.com/37941513/200880637-f59b03ba-c893-40ec-bd93-50753a14683c.png)

![20221110_010617](https://user-images.githubusercontent.com/37941513/200880686-eb6ca48a-c034-49f1-af70-8cb7456dd290.png)

![20221110_010841](https://user-images.githubusercontent.com/37941513/200881102-583ea53e-d582-4460-a4eb-cb73c937d40b.png)

- 완전히 똑같다.

#### 그럼 원본을 바꾸고 싶다면?

구조체의 '포인터'
```
date_t *date
```

#### 구조체 포인터에서 멤버의 값에 접근하기

```
void increase_year(date_t * date)
{
    (*date).year = (*date).year+1;
}
```

매개변수 주소로 받아옴(포인터로). 실제 호출할 떄 그 date라는 구조체가 있었다면, 호출자에, 변수가 있었다면, date라는 그 앞에 &를 넣어줘 갖고 주소 변환해서 넣어주면 된다.

그럼 주소니까 값 가져오고 구조체 안 멤버변수 접근해서 증가시켜줌. 근데 * 넣어주는 이유?
**연산자 우선순위** 떄문

- () 필요한 이유?
    - 연산자 우선순위 떄문
    - .연산자의 우선순위는 1, *연산자 우선순위는 2
- 고로 괄호가 없다면? *date.year-> *(date.year)

date주소에서 .year를 가져오려고 하는 것.
포인터인데 주소.이 어디있나 그래서 위처럼 작성해야 한다.



<br>

----


#### 근데 이러면 괄호떄문에 지저분해진다.

- 이걸 합친 간단한 연산자가 있다
- 화살표 연산자(->)
    - 우선순위는 1순위.

```
(*date).year= (*date).year+1;
date->year = date-> year+1;
date->year++;
```

.은 어떤 구조체의 변수의 멤버변수에 접근하는 것. 근데 그 구조체가 구조체로 직접 값으로 들어온 게 아니라 주소로 들어오면
그 주소가 가리키는 구조체에 접근을 해서 그 다음에 멤버 변수 불러와야 함.

즉, date가 포인터라면 화살표 써야하고 
date가 포인터가 아니라 값이라면 그냥 점(.)만 쓰는 것.


#### 구조체 매개변수 베스트 프렉티스

1 . 값으로 전달 vs 주소로 전달

- 기본 자료형 전달시는 간단했음
    - 기본 데이터 크기가 작으니 원본 바꿀 때만 주소로 전달하면 되었다.
- 구조체의 경우 데이터 크기가 클 수 있다.
    - 구조체 안에 int형 멤버변수가 5만개면 50000*4 = 200kb
    - 이럴 떄는 다 복사하는 게 성능이 느릴 수도 있다. - > 이럴떄 주소로 전달
    - 포인터에 const 포인터를 붙이면 원본도 못 바꾸니 안전하다.


![20221110_013255](https://user-images.githubusercontent.com/37941513/200886893-28b347cf-19d6-483b-8fe5-5361e654abab.png)

2 . 구조체 매개변수 vs 여러개의 개별 변수

- 딱히 정확한 규칙이 있지 않지만 보통 변수 많이 전달하는 대신, 구조체 하나 전달하라고 한다.
    - 엄밀한 규칙은 없다. 구조체 안쓰고 매개변수 10개 넘게 넘기는 사람들도 많다.
    - 근데 어떤 곳에서 4개까지는 괜찮고 5개가 넘어가면 그떄부터 구조체 만들라 하는 사람도 많다.
    - 이유는 다양 x64 함수 규약이라던가 이런 걸 보면 좀 더 빠르다던가 더 큰 문제는 실수를 줄이기 위함.
- 한 4개까지는 낱개 변수로 그 이후에는 구조체로 넘기라는 규칙을 쓰는 회사도 있다.
- 이유는 다양
    - 실수 줄이기 위해서도 있고
    - 성능 빠르게 하기 떄문도 있고(특히, 주소로 전달시)

![20221110_013607](https://user-images.githubusercontent.com/37941513/200887650-4876708b-224f-4fe4-94e3-089d24dcee2e.png)


<br>

------


### 함수 반환값으로서의 구조체, 구조체 배열

#### 함수 반환값으로서의 구조체

![20221110_014515](https://user-images.githubusercontent.com/37941513/200889879-8a76241f-a22c-4d2b-8bc8-8c38145ba441.png)

- 기본자료형이랑 똑같음(int 반환하면 int반환 되듯이 함수 반환하면 함수 반환)
    - 그래서 반환값이 2개면 return으로 반환 못하니까 out매개변수 만들어서 씀.
    - 근데 이걸 벗어나는게 return 구조체 만들어서 사용
    - 여러개의 반환값 넘겨주고 싶으면 구조체 사용
- int형 하나 반환하는 것과 마찬가지로 복사에 의해 반환
- C언어의 함수는 반환값이 하나라고 했음
- 이렇게 구조체를 반환하면 실질적으로 여러개의 값을 반환하는 격


그럼 

```
date = get_day()
```
가 되는 건 대입도 된다는 얘기인가?

#### 대입도 가능하다

- 개념상 그냥 각 멤버 변수를 돌아가며 하나씩 대입한다고 봐도 된다.
```
date_t date1; //{2043,10,1}
date_t date2; //{0,0,0}
date2= date1
```

![20221110_015355](https://user-images.githubusercontent.com/37941513/200891996-9380217f-292d-4374-b25c-99e5a97dd104.png)

- 어떤 컴파일러들은 메모리를 통쨰로 그냥 복사해줌
    - memcpy()라는 함수
    - 동적 메모리 사용시 많이 쓰임


![20221110_015502](https://user-images.githubusercontent.com/37941513/200892251-1c61080a-4963-49e5-8fbb-263493ad7e02.png)

<br>

-----

#### 구조체로 배열도 만들 수 있다.

- 정말 기본 자료형이랑 다르지 않다고 생각 하는게 편함
- 구조체마다 자료크기가 딱 정해져 있으니 컴파일러가 다른 변수와 똑같이 처리 가능

![20221110_015736](https://user-images.githubusercontent.com/37941513/200892861-5ce57f65-34c2-440a-9dd5-b6db65981fd4.png)


#### 가족 생일 저장하는 구조체 배열의 예


![20221110_015611](https://user-images.githubusercontent.com/37941513/200892486-1883042a-6fb4-4ef0-83d7-3cc6fb2806c9.png)


<br>

------

#### 각 요소가 몇 바이트씩 떨어져 있다

- 요소 하나의 크기
    - sizeof(int) + sizeof(int) + sizeof(int)  = 12

- 실제로 결과가 같은지 확인

![20221110_015956](https://user-images.githubusercontent.com/37941513/200893414-92248e3a-f3c2-45fb-a126-f2722520884a.png)

각 요소사이가 12바이트 떨어진 것도 확인

#### 실제 메모리

![20221110_020403](https://user-images.githubusercontent.com/37941513/200894254-00b0e65c-a2bd-43a0-8811-23870e9cfc86.png)

family_birthdates가 이런 데이터 가진거 보고 배열이 시작하는 위치로 메모리를 본거.
그리고 실제 값들이 올바르게 들어간건지 보는 것이다.
실제 메모리도 12바이트 단위로 내가 집어넣은 생일이 하나씩 들어간 점이 보인다.


#### 예시

```
typedef struct name {
char* lastname;
char* firstname;
} name_t;

char firstname[] = "Lulu";
char lastname[] = "Lee";

name_t name;
name_t clone;

name.lastname = lastname;
name.firstname = firstname;

clone = name;
name.lastname[0] = 'N';

printf("origin: %s %s\n", name.firstname, name.lastname);
printf("clone: %s %s\n", clone.firstname, clone.lastname);

```

-> origin :Lulu Nee
clone: Lulu Nee 출력

### 얕은 복사, 깊은 복사


위 코드에서 원본만 바꿨는데 복사본 까지 바꿔서 출력이 된다.

#### 포인터 변수에 대입한 값은 주소

- 변수를 그대로 대입했었다.

![20221110_111909](https://user-images.githubusercontent.com/37941513/200984406-91e1ee9e-fea7-469e-be5f-1d74ba7056a2.png)


- 포인터의 경우 주소**만** 복사




105라는 주소가 저장되어있고 뒤에 100 주소 저장 name에 있던 105가져오고 마찬가지로 100 저장

lastname은 뒤에 105 부분, firstname은 앞의 100 부분의 주소를 가리키고 있다.

![20221110_112458](https://user-images.githubusercontent.com/37941513/200984881-6b13cd0f-bc59-43ed-8928-e02ba4b4f09b.png)

<br>

같은 스타일 C 문자열을 가리키니 하나를 바꾸면 당연히 다른 것도 바뀐다.

```
name.lastname[0] ="N";
```

- 둘 다 같은 주소를 가리키고 있음, 즉 둘다 "NEE"를 가리킴

![20221110_112803](https://user-images.githubusercontent.com/37941513/200985324-59cae647-2b2a-470a-9139-32168f9516ec.png)


이렇게 실제 데이터가 아니라 주소를 복사하는 걸 **얕은 복사** 라고 한다

#### 깊은복사

- 이럴떈 깊은 복사를 하는게 맞는데 이건 대입만으로는 안 된다.
- 구조체 변수마다 독자적인 메모리 공간 만들어주고 거기에 문자열을 복사해야함.
    - 동적 메모리 관련

![20221110_113209](https://user-images.githubusercontent.com/37941513/200985843-dcb2d748-0b81-4d00-9110-45a3012744fe.png)


#### 파일 읽고 쓸 떄도 비슷한 문제 발생


먼저 구조체 만듬. 구조체의 배열 만들고 4개 저장하겠다고 선언.
처음 꺼에 teemo 이런식으로 쭉 선언

![20221110_113845](https://user-images.githubusercontent.com/37941513/200986760-dc29466e-dca9-4342-9403-745001950878.png)


nums_name만큼 이름 가지고 있다. 주소로 들어가고 이게 시작주소로 들어가고 바이트 수 알려준다.


#### 파일 읽고 쓸 떄도 비슷한 문제 발생

![20221110_114214](https://user-images.githubusercontent.com/37941513/200987280-4117f8eb-57bc-4437-bcf3-ae5f5db9f65a.png)


num_names가 2일꺼고 연 다음에 읽을거.

읽은 다음에 화면에 출력해보면 예외뜬다.(툴에서 띄울 듯 아마)


#### 이름 저장한게 아닌가? 뭘 저장한거지

![20221110_114343](https://user-images.githubusercontent.com/37941513/200987537-e4b8ce49-9040-40ba-8f46-2a313396e43e.png)


- 디버깅 하니 이상한 값들이 들어온다

![20221110_114354](https://user-images.githubusercontent.com/37941513/200987535-0f13eaff-e3bd-4b4f-9f18-46f6ef965dd9.png)


파일을 열어보니 생각한 값이 아닌 다른 값이 들어감.


아래는 아까 저장할 떄 보던 숫자인데..?

![20221110_114553](https://user-images.githubusercontent.com/37941513/200987816-db0bb4ce-90e5-43f9-a3e8-cb8e6835caa3.png)



#### 포인터는 주소를 저장. 그래서 주소가..

```
size_t size;
size = sizeof(name_t);
```

![20221110_114700](https://user-images.githubusercontent.com/37941513/200987960-532cb2b4-da5e-44f2-879a-aa25fc50e460.png)


- name_t의 크기를 보니 역시나 8바이트
- 즉. 주소 2개만 들어있음

- 파일에 저장할 떄 C는 문자열로 저장한 게 아니다.
- 그 문자열이 메모리 어느 주소에 있는데, 그 문자열이 메모리어느 주소에 있다. 그 주소를 저장한 것.
- 주소가 4바이트라면 8바이트를 데이터에 저장한 것.  그 주소 위치 였던 것임. 그랬을 떄 sizeof() 가 구조체하면 8바이트 밖에 안 나옴. 그래서 주소만 저장해 둠. 주소를 저장하면 주소를 프로그램 재 실행해서 주소를 읽어옴.

- 그럼 프로그램 재 실행 하면 문자열이 똑같은 위치에 들어가있는건가? 
    - 아니다. 프로그램 키고 끄는 순간 문자열은 다른 주소에 저장이 된다.
    - 그래서 파일에 이 주소에 그 떄 문자열이 있었는데라고 그 문자열 주소를 읽어왔는데 다시 가보면 그 문자열 주소가 엉뚱한 것일 수 있다. 혹은 읽으면 안되는 메모리 일수있다.

**주소라는 건 프로그램이 도는 순간 그때 그 순간에 어떤 위치에 그 문자열 배열이 들어가 있었을 뿐인 것이다.**

- 다음에 실행시 그 위치에 있다는 보장이 없다.
- 문제는 포인터. 포인터를 없애야 🤔. 포인터가 실수하기 쉽다는 게 이런 이유들 때문


<br>

---------

### 구조체 사용 시 포인터 저장의 문제

#### 포인터 변수 없는 name_t 크기는 64

![20221110_202823](https://user-images.githubusercontent.com/37941513/201079875-29dc1998-9dd8-4f16-8d61-dda5d899c738.png)

![20221110_205441](https://user-images.githubusercontent.com/37941513/201084614-fb462f3f-094b-45d5-8dd1-9b6c14d7f8f8.png)


함수의 인자로 전달해도 64 -> 배열을 복사하는 법을 발견?


![20221110_205703](https://user-images.githubusercontent.com/37941513/201084608-26c2959c-94ce-4148-a5b6-0a5ca9ad70a0.png)

![20221110_210212](https://user-images.githubusercontent.com/37941513/201088299-197163e9-9db2-459f-886c-b472c38f0b3d.png)

위처럼 바꾸고 실행해보면 잘 실행이 된다.

#### 포인터만 없으면 된다. 포인터만

- 반드시 그럴 수 없겠지만 
- 가능한 이렇게 한 덩어리 메모리에 모든 데이터가 들어가고 대입 가능한 구조체를 만드는 게 좋다.
- 즉, 포인터만 없으면 됨.
- 그래도 뭘 해야 편안

<br>


### 구조체를 다른 구조체의 멤버로 사용하기, 바이트 정렬



![20221110_212919](https://user-images.githubusercontent.com/37941513/201091863-ad1fa54d-66b3-4a3b-a486-07df7ff26fd3.png)


#### 홈 파일안에 몇 바이트가 쓰인건가

계산하면 76바이트가 들어가야 정상

![20221110_214833](https://user-images.githubusercontent.com/37941513/201096369-1db78b94-18ab-4c8e-910c-81590fd69a83.png)



![20221110_220518](https://user-images.githubusercontent.com/37941513/201099138-721a4b85-0e2d-46d9-8157-edc104d69cd2.png)


막상 계산 해보면 80바이트 출력

#### 위 예시에서 키 나이 저장하는 메모리는 아래와 같이 구성

![20221110_221749](https://user-images.githubusercontent.com/37941513/201102759-d5901a6c-0387-4443-a0dc-ca27141a1acb.png)

height, age도 2바이트 먹어야 하는데 4바이트

#### 바이트 정렬 요구사항 때문에 구멍이 생김.

 - 살펴보니 4바이트를 안 채운 애들이 공간을 먹음
 - 이건 각 시스템 마다 메모리에 접근할 때 사용하는 주소에 대한 요구사항이 다르기 때문
    - 시스템 상 제약이 있거나
    - 효율성 때문
- 패딩이라고 표현하기도 함.
- 어떤 시스템은 n 바이트배수인 시작 주소에서만 메모리 접근 가능
- x86 시스템은 4바이트(워드 경계) 에서 읽어오는 게 효율적
    - 이걸 4바이트 경계에 정렬된다(aligned)라고 한다.
- 따라서 컴파일러가 알아서 각 멤버의 시작위치를 경계에 맞춤.
- 그러기 위해 안 쓰는 바이트를 덧붙임(padding)
- 32비트 clang 윈도우는 4바이트 정렬을 하려고 함
- 따라서 어떤 아키텍쳐에서 저장한 파일을 다른 아키텍처에서 읽으면 잘못 읽힐 수도 있다.


#### 현실로 비교해보면 줄 세우는 것과 비슷

![20221110_224900](https://user-images.githubusercontent.com/37941513/201108808-c5c571d8-59fa-4a3b-b7ab-bb752d749829.png)


#### 패딩 줄이기

![20221110_224942](https://user-images.githubusercontent.com/37941513/201108946-994c5dc9-0f38-480d-b4f4-cdbc3695fd45.png)

- 이렇게 하는 것 만으로도 없어짐
- 크기도 76
- 2개의 short형 변수가 4바이트로 합체됨.

#### #pragma   pack 쓰는 방법도 있긴 함

![20221110_225533](https://user-images.githubusercontent.com/37941513/201110301-035852d9-3057-4dd2-8945-3eae8edc966e.png)


- 크기도 우리가 원하는 76
- 그러나 표준은 아님
- 요즘 컴파일러들이 잘 지원해주는 것 뿐..


#### 구조체 베스트 프렉티스

- 구조체를 파일이나 다른데 저장해야해서 바이트 크기가 정확히 맞아야 한다면?

    - 보통 assert()를 사용
    ```
    #include <assert.h>
    assert(sizeof(user_info_t)==76)
    ```

- 어쩔 수 없이 패딩이 생길거라면 구조체에 패딩을 명시적으로 넣기도 한다.

```
typedef struct{
    unsigned int id;
    name_t name;
    float weight;
    unsigned char height;
    unsigned char age;
    char unused[2];
}user_info_t
```

- 특히 데이터 전체 크기가 4바이트로 안 나눠 떨어질 때

<br>

--------


### 비트 필드

- 구조체는 여러 데이터를 한 곳에 모아두는 데 좋았다. 거기서 무슨 패딩이 들어가고 그런 문제를 잡기 위해서 여러가지 것들을 했다.  
- 근데 내가 정수형 데이터를 쓰는데 32비트가 필요가 없다. 그러면 뭐 16비트를 줄일 수도 있고, 8비트로 줄일수도 있고 이런 것들이 있다. 혹은 24비트 , 8바이트 이런식으로 나눈다던가.딱 8비트 16비트 정해져서 나눠지는 게 아니라 내가 표현하는 값은 6비트에 딱 들어간다. 그럼 6비트에 들어가고 4비트에 4비트 넣고 표현하고. 그리고 모든 변수를 4,6비트, 이런거 합쳐서 하나의 구조체로 만드는 것. 그게 바로 비트필드.


<br>

-----

#### 비트필드는 비트 플래그 개념과 유사하다.

##### 비트플래그 : bool 여럿을 효율적으로 저장

![20221111_183216](https://user-images.githubusercontent.com/37941513/201310316-588b45c8-2acd-49c4-9c7c-6ce4bf677489.png)


- 8개 이하의 bool 값을 하나의 byte에 저장하는 방법
    - C#에는 bool형이 있다.
    - C는 없어서 int형

- 원래는 8*4 바이트 = 32바이트 
- 근데 한 byte만 사용하니까 이득