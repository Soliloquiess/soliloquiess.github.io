---
title: "[C] C lang 구조체, 공용체, 함수 포인터"
layout: post
subtitle: C
date: "2022-03-07-08:42:51 +0900"

categories: study
tags: C
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---


### 구조체, 구조체의 필요성

#### 구조체란(structure)

1 . 클래스를 배우러 가는 과정에서 여러가지 형의 데이터만 모아둔 아이

2 . 클래스를 배운 뒤, 참조형이 아닌 값형인 커스텀 데이터형

<br>

-------


#### C에서 구조체는 첫번쨰 개념과 같다.
- 데이터의 집합. 멤버함수는 없다
- 여러 자료형을 가진 변수들을 하나의 패키지로 만들어 둔 것.


<br>

------

#### 구조체는 참조형 아니면 값형?

- C에서는 모든 자료형이 값형(모든 데이터!)
- 하지만 주소 전달하면 참조형 처럼 사용 가능(참조형 처럼 쓰고 싶으면 주소 전달하면 됨)
- 즉, 주소를 전달하지 않는 한 값형
- 일관적이여서 좋은 언어

<br>

-------

#### 구조체의 필요성

1 . 사람은 세상을 바라볼 떄 물체 단위로 봄.

size_t hour = 2; 
size_te minutes = 39;


2 . 구조체를 사용시 실수도 막을 수 있다.

```
if(is_monday(2043,10,1)){
    run_format();
}
```

위 코드가 틀렸을수도 있다.

![20221108_002433](https://user-images.githubusercontent.com/37941513/200347577-fe5206f1-5417-45bf-8e39-ce695876ab50.png)



<br>

------

#### 컴파일러는 뭐가 틀렸는지 알 수 없음.

같은 형의 데이터 여러개를 매개변수로 받을 때 순서 바뀌면 컴파일러가 실수 찾을 방법이 없다.

![20221108_002815](https://user-images.githubusercontent.com/37941513/200348448-ed06d653-81c6-4a06-89a5-2455cfe814be.png)

<br>


#### 묵시적으로 변환 가능한 자료형이 여러개일 떄도 마찬가지.

- 매개변수 길어지면 마찬가지로 문제
- 그냥 눈으로 보면 실수를 놓치기 쉽다.
- 중간에 매개변수 바꿔도 문제.

![20221108_002734](https://user-images.githubusercontent.com/37941513/200348272-5d69c39d-2630-4716-bae4-acf6bfe96c61.png)

<br>

#### 실수 막으려 또 다른 실수 초래가능

![20221108_002857](https://user-images.githubusercontent.com/37941513/200348677-281f13e3-bc80-4253-b3cc-adb203672a46.png)


<br>

**실수를 줄이려면 원자성을 보장하는 연산(atomic operation)을 사용하는 게 좋다.

<br>

---------


### 구조체의 선언 및 사용


#### 실수 없이 한번에 구하려면 구조체


![20221108_003229](https://user-images.githubusercontent.com/37941513/200349448-834181f6-8de9-424c-97c4-660b1ca19c8c.png)


![20221108_003351](https://user-images.githubusercontent.com/37941513/200349956-21b357b1-5003-4dc1-bfbb-6bb5f7350a11.png)


#### 당연히 지역변수 선언시 0으로 초기화 안된다.

![20221108_003532](https://user-images.githubusercontent.com/37941513/200350172-e20df57b-4655-415a-9ac1-d9ca3f0e3536.png)


<br>

#### 너무 장황한 구조체의 데이터형
 
```
struct date date
```

date라는 이름의 나만의 자료형을 만들어 쓰는줄 알았는데..
- 기본 자료형은 자료형 + 변수명인데( int date)

- 왜 구조체(내가 만든 형은) struct date가 자료형인가?

<br>

------

###  typedef 이란?, typedef 사용법

#### typedef
```
typedef unsigned int size_t
```

- 이미 있는 자료형인 unsigned int에 새 별명 지어줌.
- 그 새로운 이름은 size_t
    - 근데 그냥 unsigned int 써도 전혀 상관 없음.
    - 서로 바꿔가며 써도 된다
- 물론 size_t의 경우는 각 구현마다 자료형이 달라질 수 있어서 typedef를 해놓은 것.

<br>

#### typedef 사용법

- 아무튼! 구조체 typedef를 쓰면 다른 자료형처럼 간결하게 변수 선언이 가능


![20221109_224233](https://user-images.githubusercontent.com/37941513/200853368-f567d9d2-dd95-4610-99ac-37c3f4ddea3b.png)


![20221109_224459](https://user-images.githubusercontent.com/37941513/200854451-51783859-c4db-4c5a-a5da-1a8166598510.png)


- 어느 방법을 써도 크게 상관 없음
- 참고로 C에서 _t로 끝나는 자료형은 보통 이렇게 Typedef 한 것들

#### enum도 마찬가지

![20221109_233118](https://user-images.githubusercontent.com/37941513/200857319-60dbc42d-827c-496a-ae0d-7e7cfce4587c.png)


game_role_t를 만들어주면 이걸 사용해서 변수 선언이 가능해진다.

공용체도 사실 같은 방식. 공용체 선언하고 만들떄 그대로 쓴다.

#### 코딩 표준 : 커스텀 자료형에 typedef를 쓰자.

- 가능하면 구조체, 열거형, 공용체에 typedef를 써서 제대로 된 자료형처럼 보이게 하자
- 강제사항은 아님.

<br>

----------


###  구조체 변수 초기화 하기


#### 구조체 변수 초기화하기

- 아까도 말했듯이 구조체 선언과 동시에 초기화 안 됨.
    - 스택에 남아 있는 데이터를 그대로 사용


![20221109_234839](https://user-images.githubusercontent.com/37941513/200861688-25f4eeac-efde-467e-8804-07375b96af60.png)


- 아까도 말했듯이 구조체 선언과 동시에 초기화 안 됨
    - 스택에 남아있는 데이터를 그대로 사용
- 그냥 구조체는 지역변수를 여러개를 따로따로 사용하는 것과 마찬가지라고 생각하자
    - 사실 기계는 구조체라는 개념 자체를 모른다.
    - 그냥 프로그래밍 언어가 프로그래머 편하고 실수하지 말라고 제공해준 개념이다.
    - 실제 하드웨어는 우측 기반으로 돈다(오른쪽 사진)

<br>


-----

#### 궁금하면 메모리/어셈블리 보면 됨

![20221110_002304](https://user-images.githubusercontent.com/37941513/200870434-ab3ac912-8507-48a2-bf88-f01c1cac02c8.png)

이 두개는 같은걸까?

![20221110_002602](https://user-images.githubusercontent.com/37941513/200870864-7022a498-56d3-411c-bd4e-0f4cd617e6b7.png)

#### 컴파일러 입장에선 똑같은 코드로 인식하고 스택에 다 넣어준다.

![20221110_003023](https://user-images.githubusercontent.com/37941513/200872793-9f57a6d7-07bb-44ba-b44c-de8a5ffd16e0.png)

<br>

-----


#### 또 다른 구조체 초기화 방법

```
date_t date = {0,};
```

- 아님 이렇게도 가능
- 배열 초기화 떄 썼던 방법
- 컴파일러 따라 그냥 date 가 차지하는 모든 메모리 공간을 0으로 채워주는 명령어로 바꿔줄 수도 있음.
    - memset()
    - 배열도 이렇게 초기화 되기도 한다.

<br>

-------

#### 요소 나열법으로 초기화


![20221110_003820](https://user-images.githubusercontent.com/37941513/200873943-7e7ecf3a-e9cd-48f4-962b-204f413dadfd.png)


- 근데 되도록이면 이 방법은 추천하지 않음
- 실수할 여지가 있다.

- 나중에 다른 프로그래머가 구조체 멤버변수 순서를 바꾸고 변수 초기화 목록을 안 고치면 문제가 됨

    - 그 버그가 생긴지도 모른 채 시간이 꽤 흐를 수 있다.

![20221110_004347](https://user-images.githubusercontent.com/37941513/200875311-188720e7-a6b5-4d94-acab-3c3334c56eb7.png)

#### 요소 나열법이 유용한 경우는 딱 한가지


- 멤버변수가 const일떄, 선언 시 초기화 안 하면 다시는 못함

![20221110_004607](https://user-images.githubusercontent.com/37941513/200875720-170a3313-a280-454b-97cb-7bacb4579115.png)


- 근데 const멤버 변수는 잘 쓰지도 않고 쓰지 말라는 게 업계 표준
    - const는 쓰는거 보다 안쓰는게 더 좋다(안 쓸때가 더 장점이 많다..)

<br>

------

### 구조체 매개변수

- 클래스랑 똑같네?

1년 더하는 코드(안됨)


![20221110_005944](https://user-images.githubusercontent.com/37941513/200879031-655ba329-fca8-4e70-a5a3-70bdadfef651.png)


#### 구조체는 값형이다

- 값형이다. 참조형이 아님
- C에서는 자료형은 전부 똑같이 작동함


#### 인자 전달도 기본 자료형과 똑같이 작동


![20221110_010630](https://user-images.githubusercontent.com/37941513/200880637-f59b03ba-c893-40ec-bd93-50753a14683c.png)

![20221110_010617](https://user-images.githubusercontent.com/37941513/200880686-eb6ca48a-c034-49f1-af70-8cb7456dd290.png)

![20221110_010841](https://user-images.githubusercontent.com/37941513/200881102-583ea53e-d582-4460-a4eb-cb73c937d40b.png)

- 완전히 똑같다.

#### 그럼 원본을 바꾸고 싶다면?

구조체의 '포인터'
```
date_t *date
```

#### 구조체 포인터에서 멤버의 값에 접근하기

```
void increase_year(date_t * date)
{
    (*date).year = (*date).year+1;
}
```

매개변수 주소로 받아옴(포인터로). 실제 호출할 떄 그 date라는 구조체가 있었다면, 호출자에, 변수가 있었다면, date라는 그 앞에 &를 넣어줘 갖고 주소 변환해서 넣어주면 된다.

그럼 주소니까 값 가져오고 구조체 안 멤버변수 접근해서 증가시켜줌. 근데 * 넣어주는 이유?
**연산자 우선순위** 떄문

- () 필요한 이유?
    - 연산자 우선순위 떄문
    - .연산자의 우선순위는 1, *연산자 우선순위는 2
- 고로 괄호가 없다면? *date.year-> *(date.year)

date주소에서 .year를 가져오려고 하는 것.
포인터인데 주소.이 어디있나 그래서 위처럼 작성해야 한다.



<br>

----


#### 근데 이러면 괄호떄문에 지저분해진다.

- 이걸 합친 간단한 연산자가 있다
- 화살표 연산자(->)
    - 우선순위는 1순위.

```
(*date).year= (*date).year+1;
date->year = date-> year+1;
date->year++;
```

.은 어떤 구조체의 변수의 멤버변수에 접근하는 것. 근데 그 구조체가 구조체로 직접 값으로 들어온 게 아니라 주소로 들어오면
그 주소가 가리키는 구조체에 접근을 해서 그 다음에 멤버 변수 불러와야 함.

즉, date가 포인터라면 화살표 써야하고 
date가 포인터가 아니라 값이라면 그냥 점(.)만 쓰는 것.


#### 구조체 매개변수 베스트 프렉티스

1 . 값으로 전달 vs 주소로 전달

- 기본 자료형 전달시는 간단했음
    - 기본 데이터 크기가 작으니 원본 바꿀 때만 주소로 전달하면 되었다.
- 구조체의 경우 데이터 크기가 클 수 있다.
    - 구조체 안에 int형 멤버변수가 5만개면 50000*4 = 200kb
    - 이럴 떄는 다 복사하는 게 성능이 느릴 수도 있다. - > 이럴떄 주소로 전달
    - 포인터에 const 포인터를 붙이면 원본도 못 바꾸니 안전하다.


![20221110_013255](https://user-images.githubusercontent.com/37941513/200886893-28b347cf-19d6-483b-8fe5-5361e654abab.png)

2 . 구조체 매개변수 vs 여러개의 개별 변수

- 딱히 정확한 규칙이 있지 않지만 보통 변수 많이 전달하는 대신, 구조체 하나 전달하라고 한다.
    - 엄밀한 규칙은 없다. 구조체 안쓰고 매개변수 10개 넘게 넘기는 사람들도 많다.
    - 근데 어떤 곳에서 4개까지는 괜찮고 5개가 넘어가면 그떄부터 구조체 만들라 하는 사람도 많다.
    - 이유는 다양 x64 함수 규약이라던가 이런 걸 보면 좀 더 빠르다던가 더 큰 문제는 실수를 줄이기 위함.
- 한 4개까지는 낱개 변수로 그 이후에는 구조체로 넘기라는 규칙을 쓰는 회사도 있다.
- 이유는 다양
    - 실수 줄이기 위해서도 있고
    - 성능 빠르게 하기 떄문도 있고(특히, 주소로 전달시)

![20221110_013607](https://user-images.githubusercontent.com/37941513/200887650-4876708b-224f-4fe4-94e3-089d24dcee2e.png)
