---
layout: post
title: "기말고사 대비"
subtitle: "etc"

date: "2023-03-01-17:26:51 +0900"
categories: etc
tags: etc
comments: true
---

## 재귀 함수

### 재귀 함수(recursive function)

- 이미 해결한 작은 문제에 얹어서 더 큰 문제를 해결하는 방법
    - 예) 1에서 5까지의 합을 구하려는거는 뭔가
        - 이미 1~4 더한 결과가 10임을 알고 있음
        - 그러면 여기에 5만 더하면 15가 된다.

- 프로그래밍에서 함수 A가 매개변수만 바꿔 다시 함수A를 호출하는 방법으로 구현

- 호출과정

![image](https://user-images.githubusercontent.com/37941513/222087536-5fa7d368-24c8-4287-8461-9081e1bd1b01.png)

### 재귀 함수의 구성 요소

#### 종료 조건 (ending condition , base case)
- 더 이상 재귀 함수를 호출하지 않고, 값을 반환하는 조건
- 매우 간단히 함수의 반환 값을 찾을 수 있는 경우
- 이것을 없으면, 함수를 무한히 재귀적으로 호출

#### 재귀적 함수 호출
- 종료 조건이 아닌 경우
- 함수의 인자를 바꿔 스스로를 다시 호출
- 이 때, 함수의 인자는 현재 문제보다 작은 문제를 대표해야 함
- 즉, 동일한 동작을 보다 작은 문제에 적용

--------

### 일반적으로는 반복문이 더 쉽다

![image](https://user-images.githubusercontent.com/37941513/222088599-e74b3acd-11aa-4c79-8ce4-7442d2a31ea5.png)


### 반복문을 그냥 쓰면 안되나?

- 사실 모든 재귀함수는 반복문으로 해결 가능
- 그러나 복잡한 문제일 수록 재귀함수가 훨씬 편해진다

    - 이진 검색
    - 트리 구조
    - 퀵 정렬
    - 하노이의 탑
    - 어떤 폴더 아래 있는 모든 파일 목록 구하기


### 재귀함수 예 - 피보나치 수열
- 제 0 항은 0, 제 1항은 1이며, 그 뒤의 모든 항은 앞 두항의 합인 수열. 
- 0 1 1 2 3 5 8 13 21 34 55
- F0=0 , F1=1, F(n)= F(n-1) + F(n-2);


```
using System;
class FiboTest
{
 static long fibo(int value)
 { 
  if (value == 0)
  {
    return 0;
  }
  if (value == 1 || value == 2)
  {
   return 1;
  }
  
  return fibo(value-1) + fibo(value-2);
 }
 static void Main(string[] args)
 {
  if (args.Length < 1)
  {
   Console.WriteLine("인자의 수가 부족합니다...");
   Console.WriteLine("Usage : FiboTst1 Arg1");
   return;
  }
  
  int toValue = Convert.ToInt32(args[0]);
  for(int i=1; i <= toValue; i++)
  {
   Console.Write("{0} ", fibo(i));
  }
 }
}
 
```
#### 호출 과정

![image](https://user-images.githubusercontent.com/37941513/222090899-078af08d-6513-4c8b-9753-21ee5cbf626e.png)


- 함수는 신뢰의 문제
- 재귀 함수는 더 큰 신뢰 요구
- Fibanocci(4) 를 구하려 할때
    - Fibonacci(2), Fibonacci(3) 반드시 올바른 값을 반환한다 믿어야 한다
    - 왜냐면 수학적 귀납법이기 때문
    - 다른말로 Fibonacci(0), Fibonacci(1)은 반드시 1을 반환
    - 그 후의 수는 위 종료 조건에 기초하여 값을 계산할 수 있음.


##### 반복문이 더 쉬운건 수학적 귀납법이 익숙치 않기 때문


### 복잡한 내용의 함수인 경우 재귀문이 더 쉽다

![image](https://user-images.githubusercontent.com/37941513/222102995-c276380c-350b-478d-b0ac-c4c8bce9ca1b.png)




### 재귀적 해결법 = 논리력

- 프로그래머의 논리력을 평가하기 적합
- 매우 큰 문제를 작게 쪼개서 증명할 수 있나
    - 절대 틀릴 수 없는 최소한의 문제를 품
    - 최소한의 문제 해법에 의존하여 그 보다 더 큰 문제를 해결
    - 그 과정을 반복하면 논리적으로 최종 문제까지 해결
- 수학적 귀납법과 매우 밀접

### 수학적 귀납법 예시

![image](https://user-images.githubusercontent.com/37941513/222106056-f368ca7a-3789-4ccd-a980-45bd3df5c216.png)


### 재귀함수의 장점

- 개념적으로 매우 훌륭하다.
- 증명이 가능하다

### 재귀함수의 단점 - 효율성이 떨어진다. 🤔

![image](https://user-images.githubusercontent.com/37941513/222107578-717ea39f-9977-4ebd-9eae-75081e670c46.png)

- 반복문은 그런 문제가 없다.
- 이전 연산 결과를 저장(캐싱) 하기 떄문(캐시에 저장)



![image](https://user-images.githubusercontent.com/37941513/222108733-7e41a282-6824-4f78-bd29-548bdb82b844.png)


### 재귀함수의 단점 - 스택 오버플로우

![image](https://user-images.githubusercontent.com/37941513/222110422-7d3a1d58-8082-4037-8ca3-634d6ca1f48b.png)

- 함수 호출깊이엔 제한 존재


### 언제 써야 하는가

- 캐싱 없이 간단한 반복문으로 작성 가능한 문제는 반복문으로
    - 1부터 N까지 합 구하기

- 그 외에는 재귀함수로 우선 작성
    - 설계가 용이하기 떄문

- 다음의 경우는 반복문으로 코드 리팩토링
    - 함수의 호출 최대 깊이를 확정할 수 없음
    - 또는 성능상 문제 발경
    - 코드 리팩토링 : 코드 실행결과를 유지하며 코드의 구조를 재조정.

##### 재귀함수 실전에서 정말 많이 쓰인데. 다만 이슈가 있을 경우 코드 리팩토링 하는 거


#### 문제

![image](https://user-images.githubusercontent.com/37941513/222112129-7ac02d43-66e2-4e84-998f-041166060ae0.png)

![image](https://user-images.githubusercontent.com/37941513/222112315-ae1e5f9a-45a6-44dc-9f8c-9e06152b2855.png)

-------


### 재귀함수 이용 예시

#### 재귀함수 쓰기전 간단한 가위바위보

![image](https://user-images.githubusercontent.com/37941513/222114055-137f0dd5-dfa9-4462-a538-58f09f806ea2.png)

무조건 플레이어가 이기는 경우. 이런 경우 두 판 이상가면 질림

------


### 랜덤 수 생성 (random number generation)

- 난수 생성이라고도 함
- 언제나 예측 가능했던 컴퓨터였으나 난수 생성이 가능해짐
- 이 덕에 게임이 나옴
- 거의 모든 프로그래밍 언어에 존재하는 개념

![image](https://user-images.githubusercontent.com/37941513/222118662-1a97fad5-5f10-4865-af8e-64c8121cf2c3.png)


### Random 클래스와 개체 생성


![image](https://user-images.githubusercontent.com/37941513/222119006-a32b68e1-8ccf-4219-80ea-89a8a17f7c3d.png)

```
Random random = new Random()
```
- 랜덤 생성기를 만들어 random이라는 변수에 대입
- random은 변수명이므로 다른 단어를 써도 무방

```
Random luck = new Random(); //OK
```

- 클래스 : 여러개의 함수가 뭉쳐있는 집합
- 개체 : 클래스 안에 있는 함수를 사용하려면 필요하다.


#### 난수 생성기


![image](https://user-images.githubusercontent.com/37941513/222119243-3213c648-e2d9-40d7-b8dc-525bf555f40c.png)

```
Random random = new Random () ; //반드시 필요한 코드
int number1 = random.Next(3);
int number2 = random.Next(1,10);
```

<변수명>.Next(<최대값>)
- 0 이상 최대값 미만 수 중 하나를 무작위로 뽑아줌 => [0, 최대값]


<변수명>.Next(<최소값>, <최대값>)
- 최소값 이상 최대값 미만의 수 중 하나를 무작위로 뽑아줌 => [최솟값, 최댓값]

------

### 수정한 가위,바위,보 게임


![image](https://user-images.githubusercontent.com/37941513/222125718-8f248f79-9821-4655-b821-f3fde046d11c.png)


근데 계속 같은 결과가 나온다. 


```
using System;

namespace EMode
{
    class Program
    {
        enum EShape
        {
            Rock = 0,
            Paper = 1,
            Scissor = 2
        };
        static void Main(string[] args)
        {
 //           Random random = new Random();   
            
            Random random = new Random(0);   //매개변수로 0 들어감

            while(true)
            {
                EShape computer = (EShape)random.Next(3);

                Console.WriteLine("Rock Scissor paper");
                EShape user = (EShape)int.Parse(Console.ReadLine());
                if (computer == user)
                {
                    Console.WriteLine($"[Draw]\nYou({user}), Computer({computer})");
                }
                else if ((computer == EShape.Rock && user == EShape.Scissor)
                    || (computer == EShape.Paper && user == EShape.Rock)
                    || (computer == EShape.Scissor && user == EShape.Paper))
                {
                    Console.WriteLine($"[Lose]\nYou({user}), Computer({computer})");
                }
                else if ((computer == EShape.Rock && user == EShape.Paper)
                        || (computer == EShape.Paper && user == EShape.Scissor)
                        || (computer == EShape.Scissor && user == EShape.Rock))
                {
                    Console.WriteLine($"[Win]\nYou({user}), Computer({computer})");
                }
                else
                {
                    Console.WriteLine($"Wrong input!");
                }
            }
        }
    }
}
```
![image](https://user-images.githubusercontent.com/37941513/222128874-605a0676-310a-4e80-ada6-ea24dbc1fe41.png)

- 위 코드로 실행하면 계속해서 실행했을 떄 같은 값이 나온다.
    - 왜?

-----

### 의사 랜덤(pseudo random)

- 대부분 언어에서 지원하는 랜덤은 진정한 랜덤이 아님
    - 진짜 랜덤을 만드는 건 정말 어려운 일
    - 알고리즘의 효율성은 난수의 분포로 결정
- 시드 값을 (seed) 초기 입력값으로 하여 알고리즘을 통해 난수를 만들어내는 함수
- 그 결과는 다시 랜덤 입력값이 됨.
- 이 말은 시드가 같으면 언제나 생성된 난수의 순서가 동일


### 랜덤 함수도 마찬가지

![image](https://user-images.githubusercontent.com/37941513/222172004-058e3ace-d6cd-458f-80ee-29be7f027745.png)


- 랜덤함수는 최초(시드)를 제외하고 본인 스스로가 반환한 값을 다시 입력으로 사용.

#### 그렇기 때문에 시드가 같으면 늘 같은 결과가 나온다

![image](https://user-images.githubusercontent.com/37941513/222176070-db2bd0cc-cf7f-4ca7-9eab-1c76002158d0.png)

#### 위에서는 매번 같은 결과가 나온 것도 시드가 0일 떄의 랜덤 값이 계속 나온 것이다.

![image](https://user-images.githubusercontent.com/37941513/222181231-983ad03d-79f0-4a6d-b791-416635591de4.png)

### new Random()은 괜찮았는데?
- 이런 문제를 해결하기 위해 컴퓨터에 달린 시계를 시드값으로 사용
- new Random()도 내부적으로 그렇다
- 이걸 직접 안 해주는 언어는 시간을 직접 읽어서 시드값으로 넣어준다.


### 그럼 고정된 시드값은 쓸모가 없는가?

- 시드값을 고정시키면 좋은 경우가 있다
- 랜덤 수에 기초한 프로그램 로직에서 문제가 발생한 경우
    - 똑같은 시드값을 넣고 개발자 기계에서 실행하면 그대로 문제 재현

- 네트워크로 연결된 두 사용자가 게임을 할 때
    - 동일한 시드값을 각 컴퓨터에 넣어주고 난수를 동일한 횟수만큼 생성
    - 그러면 난수에 의해 바뀌는 게임 속 로직도 두 컴퓨터에서 동일


#### 숫자 섞기 예제

```
using System;

namespace EMode
{
    class Program
    {
       
        static void Main(string[] args)
        {
            const int SEED = 0; //시드 정의 . 무슨 값이든 올 수 있음. 시드 넣으면 결과값 언제나 똑같이 나온다.
            int[] numbers = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };
            Console.WriteLine($"Before Shuffling");
            Console.WriteLine($"[{string.Join(",",numbers)}]"); //이쁘게 보여주기 위함
            
            //Random random = new Random();
            Random random = new Random(SEED); //시드 넣으면 결과값 언제나 똑같이 나온다.
            
            for (int i = numbers.Length -1; i > 0; i--)     //뒤에서 앞으로 돈다(여태껏 앞에서 뒤로 돌았는데). 이거의 문제는 첫번쨰 숫자는 방문 안함.
                                                            //왜 그런가?(많이들 실수함). 두번쨰 종료조건을 조금만 바꾸면 처음 요소도 방문한다.)

            {
                int j = random.Next(0,i);   //0부터 i까지 난수 생성
                int temp = numbers[j];
                numbers[j] = numbers[i];
                numbers[i] = temp;
            }
            Console.WriteLine($"After Shuffling");
            Console.WriteLine($"[{string.Join(",", numbers)}]");
        }
    }
}
```

- SEED 값을 설정해서 실행 반복할떄마다 같은 결과값이 나온다.

문제

![image](https://user-images.githubusercontent.com/37941513/222185161-66d8a205-d1a2-4cf9-9b9d-b88518006e9d.png)
![image](https://user-images.githubusercontent.com/37941513/222185285-f36b6aa4-8e04-47c4-ad44-d9a7628f29ce.png)


- 재귀함수에서는 프로그래머의 논리를 판단하는 부분
    - 면접관이 질문을 많이 할 수밖에 없다.
    - 왜냐면 큰 문제를 작게 쪼개서 볼 수 있는지 확인하기 위함.
- 실용적인 부분에서는 재귀함수일떄 코드를 보기가 좀 더 쉽다.

- 폴더 탐색같은 경우 계속 뻗어나가는데 그럴떄마다 변수나 기타 로직 만드는 거보다 재귀를 이용해 함수 만들면 좀 더 용이함
- 그러나 함수호출을 여러번 하거나 깊게해서 스택 오버플로우가 날 경우가 있다.
    - 이런 경우는 반복문에 기초해서 변환 해야할 수도 있다.

- 랜덤 수는 게임이나 이런게 들어가고 그걸 재밌게 만들어줌.

------------

## 배열 안의 배열

### 2D배열의 문제

- 직사각형의 데이터만 지원 가능
![image](https://user-images.githubusercontent.com/37941513/222440393-85946d36-c9c9-4d93-b7bd-303342ecc8b2.png)


- 하지만 각 행마다 열 수가 달라져야 한다면?
- 1D 배열에는 없는 문제
    - 행이 한개이므로 원하는 열의 개수를 적용 가능


### 해결 방법 - 배열 안의 배열

- 바깥 배열(다른 배열을 포함하는 배열)
    - 1D 배열
    - 각 요소형은 다시 1D 배열(안 쪽 배열)
- 안 쪽 배열
    - 1D 배열
    - 각 요소의 형은 실제 자료형

### 바깥 배열을 만드는 법

![image](https://user-images.githubusercontent.com/37941513/222446742-71aee473-a3b5-4848-8aff-083c5a846d55.png)

![image](https://user-images.githubusercontent.com/37941513/222447494-e54314a1-d9b0-4c3f-b727-d85b3e9edaa3.png)

![image](https://user-images.githubusercontent.com/37941513/222449040-73b96bd5-6aa8-406e-bc7a-8dc8b11c06a6.png)

- Null 출력


- 아무것도 없음 : NULL

![image](https://user-images.githubusercontent.com/37941513/222449375-4acf0ae4-cc6a-4261-a67e-919c90497edf.png)
```
String [][] classrooms = new string [CLASS_COUNT][];
```

- CLASS_COUNT 수 만큼 문자열 배열을 담을 공간을 만드는 게 전부다.
 
### 안 쪽 배열 만들기 예제

![image](https://user-images.githubusercontent.com/37941513/222450347-f49f1535-1cd0-4030-abc6-ad074761716c.png)


### 안 쪽 배열에 접근하는 법

![image](https://user-images.githubusercontent.com/37941513/222452667-00489668-0381-47d7-a3ff-93fa339c8023.png)

![image](https://user-images.githubusercontent.com/37941513/222453445-5bd59a2c-62a6-40ca-847b-0f878be52a49.png)


### 원본이 바뀐다?

- 값에 의한 전달이 아니라 참조에 의한 전달이였던건가?

```
string[] studentNames = classrooms[classIndex];
studentNames[studentIndex] = "Severus";
```

![image](https://user-images.githubusercontent.com/37941513/222454198-ee0cb0fd-96a7-4337-9f65-8f99b20b3a4d.png)

```
using System;

namespace EMode
{
    class Program
    {
       
        static void Main(string[] args)
        {
            const int CLASS_COUNT = 3;
            int[] STUDENT_COUNT_PER_CLASS = { 3, 2, 5 };
            string[][] classrooms = new string[CLASS_COUNT][]; 
            for (int i = 0; i<CLASS_COUNT; i++) 
            {
                classrooms[i] = new string[STUDENT_COUNT_PER_CLASS[i]];
            }
            int classIndex = 0; //1반
            int studentIndex = 0; //첫번쨰 학생

            string[] studentNames = classrooms[classIndex];
            studentNames[studentIndex] = "Severus";

            Console.WriteLine($"Class 1 - Student 1: {classrooms[classIndex][studentIndex]}");
        }
    }
}
```

![image](https://user-images.githubusercontent.com/37941513/222455096-98bbd659-094c-4f72-98f9-84575f124ee4.png)

결과를 보면 바뀌어 있다.


### 왜?
```
int num1 = 20;
int num2 = num1;
num2 = 10;
```

하면 그대로 20이고 10으로 안 바뀌고 변수 다 그런데 왜 studentNames[0]은 바뀌었나?


일반적인 값들은 다 값에 의한 전달이지만 **new로 만든 것들은 원본이 바뀐다**.

**즉, new로 만든 건 기본적으로 그 데이터 자체가 참조형 데이터다.**

참조형이기 떄문에 이제 원본이 다 바뀐다.

문제

![image](https://user-images.githubusercontent.com/37941513/222458712-08d5c9f9-8301-4c98-b595-d03153a5ef59.png)

![image](https://user-images.githubusercontent.com/37941513/222458627-3409241a-ff4f-43fd-ae5c-ea33defd3d76.png)

### 안쪽 배열을 늘리는 법

```
string[][] classrooms = new string[CLASS_COUNT][];

classrooms[0] = new string[3];
classrooms[1] = new string[2];
classrooms[2] = new string[5];
```

- 안쪽 배열은 여전히 1D배열 -> 추가 인원을 받지 못함
    - 배열의 크기가 2에서 3으로 늘 수 없다는 의미

- 방법은 오직 하나 뿐

    1 . 크기가 3인 배열을 새로 만든다

    2 . for문을 이용해 기존의 배열 데이터를 새 배열로 복사한다.

    3 . 새 배열을 바깥 배열에 대입한다.

### for문으로 배열 복사하기

![image](https://user-images.githubusercontent.com/37941513/222464101-d4fdd7b6-c95f-4838-beb9-74cfc346033e.png)

```
string [][] classrooms = new string[CLASS_COUNT][];
// 학생들 이름을 넣는 코드는 생략
string[] classroom2 = classrooms[1];

string[] newClassroom2 = new string[classroom2.Length+1];
for (int i = 0l i < classroom2.Length ; ++i)
{
    newClassroom2[i] = classroom2[i];
}
newClassroom2[newClassroom2.Length -1] = "Leanne";
classrooms[1] = newClassroom2;
```

### Array.Copy()를 이용한 배열 복사

- for 문 쓰는게 면접 더 나오고 이러지만 실무에선 이렇게 간단하게도 많이 쓴다. 단, 이거만 쓴다고 for문 쓰는 거 까먹었다는 건 말이 안 됨.

![image](https://user-images.githubusercontent.com/37941513/222465606-0ed13000-2203-44d8-8408-e174622456f8.png)

```
string [][] classrooms = new string[CLASS_COUNT][];
// 학생들 이름을 넣는 코드는 생략
string[] classroom2 = classrooms[1];

string[] newClassroom2 = new string[classroom2.Length+1];

Array.Copy(classroom2, newClassroom2, classroom2.Length);
newClassroom2[newClassroom2.Length-1]="leanne";
classrooms[1] = newClassroom2;
```

- classroom2 내용을 newClassroom2으로 복사하는 것(첫 번쨰 요소를 두 번째 요소로 복사)

### Array.Copy()

![image](https://user-images.githubusercontent.com/37941513/222465918-e05b848a-0861-4c20-b833-5304306158a9.png)


### 2D 배열 vs 배열의 배열

![image](https://user-images.githubusercontent.com/37941513/222467014-e62cf27e-267e-4905-8015-77177dcd59a2.png)


#### 사실 배열의 배열은 2차원 배열을 요소로 가질 수 있다.

![image](https://user-images.githubusercontent.com/37941513/222467249-c715330b-6201-4b1d-9ac5-08a3e1cea4a8.png)


문제

![image](https://user-images.githubusercontent.com/37941513/222469306-4c5986a5-e093-4b5e-b0df-16109756cca2.png)

```
using System;

namespace EMode
{
    class Program
    {
       
        static void Main(string[] args)
        {
            int[] STUDENT_COUNT_PER_CLASS = { 10, 15, 21 };
            int classCount = STUDENT_COUNT_PER_CLASS.Length;
            string[] STUDENT_NAMES = { "john", "Pope", "Bob" };

            string[][] classrooms = new string[classCount][];
            for (int i = 0; i < classCount; ++i)
            {
                classrooms[i] = new string[STUDENT_COUNT_PER_CLASS[i]];
            }

            for (int classIndex = 0; classIndex< classCount; ++classIndex) 
            {
                string[] studentNames = classrooms[classIndex]; 

                for (int studentIndex = 0; studentIndex < studentNames.Length; ++studentIndex) 
                {
                    studentNames[studentIndex] = STUDENT_NAMES[studentIndex % 3];
                }
            }
            string[] classroom2 = classrooms[1];
            string[] newClassroom2 = new string[classroom2.Length +1];

            for(int i = 0; i < classroom2.Length; ++i) 
            {
                newClassroom2[i] = classroom2[i];
            }
            newClassroom2[newClassroom2.Length -1] = "Leanne";
            classrooms[1] = newClassroom2;
        }
    }
}
```


![image](https://user-images.githubusercontent.com/37941513/222469971-642d5859-1bfe-4261-bb9a-f481032411da.png)
![image](https://user-images.githubusercontent.com/37941513/222470026-d1c3cdc7-bcac-443e-9752-e99fdcb94ae6.png)


![image](https://user-images.githubusercontent.com/37941513/222469714-3b9cafe9-0149-416b-b0ef-a2058d326a22.png)

--------

### 배열의 배열 예제

```
using System;

namespace ArrayOfArrays
{
    class Program   //간단한 캘린더 프로그램
    {
        static void Main(string[] args)
        {
            const int MONTHS_IN_A_YEAR = 12;
            int[] daysInEachMonth = new int[MONTHS_IN_A_YEAR] { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

            string[][] calendar = new string[MONTHS_IN_A_YEAR][]; //calendar는 문자열 배열을 포함하는 배열이 될 것

            for (int i = 0; i<MONTHS_IN_A_YEAR; i++) 
            {
                calendar[i] = new string[daysInEachMonth[i]];   //바깥 배열의 각 요소를 문자열 배열로 초기화
            }
            while(true)
            {
                Console.Write("Enter the Month (1-12): ");
                string monthString = Console.ReadLine();
                int month = int.Parse(monthString);
                if (0>=month || month >12) 
                {
                    Console.WriteLine("Invalid range of month. Terminating program");
                    break;
                }
                Console.WriteLine($"enter the day(1-{calendar[month -1].Length}):"); //날을 입력. 몇월인지에 따라 날짜 범위는 1~28, 1~30, 1~31 중 하나가 됨.
                string dayString = Console.ReadLine();

                int day = int.Parse(dayString);
                if(0>= day || day > calendar[month-1].Length)
                {
                    Console.WriteLine("Invalid range of month. Terminating program");
                    break;
                }
                Console.WriteLine("Enter your schedule:");
                string schedule = Console.ReadLine();

                calendar[month - 1][day - 1] = schedule;
                Console.WriteLine("---------------------");

                for(int i = 0; i<MONTHS_IN_A_YEAR- 1; i++) 
                {
                    for (int j = 0; j < calendar[i].Length; j++)
                    {
                        if (!string.IsNullOrEmpty(calendar[i][j]))  //calendar[i][j]가 비어있거나 널이 아니면
                        {
                            Console.WriteLine($"{i + 1}/{j + 1}:{calendar[i][j]}"); //그날의 스케줄 출력
                        }
                    }
                }

                Console.WriteLine("---------------------");
            }
        }
    }
}

```


----------------


## 문자열 분할


![image](https://user-images.githubusercontent.com/37941513/222711106-e1464398-6847-4f33-b490-9e30a90b4a1e.png)

![image](https://user-images.githubusercontent.com/37941513/222759305-3e1a5d45-3065-4645-a95c-f6d0a94ea75c.png)

![image](https://user-images.githubusercontent.com/37941513/222759364-c433c2e3-4836-48e1-8aaf-93dfef8a0c71.png)


![image](https://user-images.githubusercontent.com/37941513/222759437-adef21f8-9117-4d2b-a621-9fec82b98975.png)

![image](https://user-images.githubusercontent.com/37941513/222759520-7ac82cc1-8270-4c6a-98ab-eaf2b52c985a.png)

![image](https://user-images.githubusercontent.com/37941513/222771931-8fc8ca29-7773-4d0c-8c17-b8ff56c1c126.png)

![image](https://user-images.githubusercontent.com/37941513/222774071-4b9b2bed-0bad-4e22-9e9f-7afe79110747.png)

### 토큰을 읽어오는 법

- 토큰 : 연속된 데이터에서 쪼갤 수 있는 가장 작은 단위
![image](https://user-images.githubusercontent.com/37941513/222774398-f75aa7c4-8f6e-4e19-9741-2035773d81db.png)

- 별도의 for문이 필요
- string의 IndexOf(), Substring()등의 함수 또는 첨자 연산자([])를 이용해서 구분 가능

### IndexOf()

![image](https://user-images.githubusercontent.com/37941513/222774522-a3b7ed21-f2b2-4b7b-a7d2-47376dc092e4.png)

```
string nameMessage = "C# is very fun";
int index = message.IndexOf('v'); //6반환
```

- char의 위치를 찾아서 색인을 반환하는 함수
    - 문자가 문자열에 여러번 나타나면 가장 처음에 나타난 곳의 색인 반환
    - 찾는 문자가 문자열에 없다면 -1을 반환

- 다양한 버전의 IndexOf() 함수가 존재함


### Substring()

![image](https://user-images.githubusercontent.com/37941513/222776141-e1960d88-8c19-4b43-81f0-3709074a5830.png)

```
string nameMessage = "name: Pokemon";
string name = nameMessage.Substring(6); //"pokemon"반환
```
- 지정된 문자 위치(색인)에서부터 문자열을 반환하는 함수

- 마찬가지로 다양한 버전의 Substring() 함수가 존재한다.

### 첨자 연산자

![image](https://user-images.githubusercontent.com/37941513/222776585-9f76bfc4-c0c9-422d-89fc-0e6481e82b64.png)

```
string HPMessage = "HP:100";
char ch = HPMessage[4]; //'1';
```

<문자열 변수 이름>[<색인>];

- <색인>위치에 있는 문자 하나를 반환

### 토큰을 읽어 오는 법

![image](https://user-images.githubusercontent.com/37941513/222781520-d89de93d-bafd-48f6-8d70-bac90973acc0.png)

- 이런 정형화 된 데이터를 쉽게 읽어오는 함수가 존재한다
    - 문자열 토크나이저


### 문자열 토크나이저 - Split()

![image](https://user-images.githubusercontent.com/37941513/222786058-3393e96c-8e51-445b-8520-d3cb3663a754.png)

```
string text = "pokemon,1,10000"
string[] tokens = text.Split(','); //"pokemon","1","10000
```

<문자열 변수 이름>.Split(char)
- char는 문자열 쪼갤 떄 사용할 구분 문자
- 원본 문자열은 변경없이 그대로 유지
- 쪼갠 문자열을 문자열 배열로 반환
- 여러버전의 Split()가 존재함

### 여러 개의 구분 문자가 문자열에 있는 경우

![image](https://user-images.githubusercontent.com/37941513/222787613-83594893-7e78-4014-af66-01793b113be9.png)

```
string text = "pokemon,1:10000"

char [] delimiters = {',',':'};
string [] tokens = text.Split(delimiters); //{"pokemon","1","10000"}
```
<문자열 변수 이름>.Split(char[]);

- 문자열 배열 (char[])에 여러개의 구분 문자를 대입

 ### 구분 문자 사이가 비어있다면

 - 문자열을 쪼개면 빈 문자열이 나옴
![image](https://user-images.githubusercontent.com/37941513/222789173-0c9042ff-3602-47b3-91a0-f6b1af1781d8.png)
 ```
string text = "pokemon,1,10000:,10,1000:LopeMon,100,100";

char [] delimiters = {',',':'};
string [] tokens = text.Split(delimiters); 
//{"pokemon","1","10000","","10","1000","LopeMon","100","100"}
 ```


 
 ### 구분 문자 사이가 비어있다면 - 해결법

![image](https://user-images.githubusercontent.com/37941513/222790737-b79cf99f-4982-4b89-bac9-5f97a29d4160.png)

 - StringSPlitOptions.RemoveEmptyEntries를 사용

 ```
string text = "pokemon,1,10000:,10,1000:LopeMon,100,100";

char [] delimiters = {',',':'};
string [] tokens = text.Split(delimiters, StringSPlitOptions.RemoveEmptyEntries); 
//{"pokemon","1","10000","","10","1000","LopeMon","100","100"}
 ```


 ----------

 ### 불필요한 공백 지우기

 ![image](https://user-images.githubusercontent.com/37941513/222791306-f0e64993-ebba-43e1-b116-96acd19be70c.png)

 ```
string firstName = "    Leon";
string lastName = "Kim      ";
string trimmedFirstName = firstName.Trim(); //"Leon";
string trimmedLastName = lastName.Trim(); //"kim";
 ```
 <문자열 변수 이름>.Trim()

 - 문자열 앞뒤로 있는 공백을 없앤 후 문자열을 반환
 - 원본 문자열은 변경 없이 그대로 유지

 ### 불필요한 공백 지우기 - TrimStart()

 ![image](https://user-images.githubusercontent.com/37941513/222794428-6df61233-a0d8-4f4d-b5bc-ec55a5bd0994.png)

 ### 불필요한 공백 지우기 - TrimEnd()

![image](https://user-images.githubusercontent.com/37941513/222794489-a152b6c3-0445-4108-af63-0323f925769c.png)

### 정리

 - 배열의 배열은 2D배열과 다름.
 - 배열의 배열은 만약 학교에 반마다 학생이 다른데 이런 경우 사용 가능(그와 비슷하거나)
 - 2D배열은 추가시 크기가 고정되서 추가하기 불가능 하나, 단 더 큰 배열 만들고 배열 복사해두고 새로운 거 추가하는 식으로 가능.

 - 문자열 분할은 컴퓨터 공학에서 중요하진 않을 수도 있긴 함
 - 어떤 특정한 분리문자를 써서 단어들을 뗴온다.
 - 이 외 string을 다루다 보니 안에 함수들도 있다. 이런거 알아두자.
 