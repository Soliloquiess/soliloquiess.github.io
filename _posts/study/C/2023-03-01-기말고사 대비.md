---
layout: post
title: "기말고사 대비"
subtitle: "etc"

date: "2023-03-01-17:26:51 +0900"
categories: etc
tags: etc
comments: true
---

## 재귀 함수

### 재귀 함수(recursive function)

- 이미 해결한 작은 문제에 얹어서 더 큰 문제를 해결하는 방법

  - 예) 1에서 5까지의 합을 구하려는거는 뭔가
    - 이미 1~4 더한 결과가 10임을 알고 있음
    - 그러면 여기에 5만 더하면 15가 된다.

- 프로그래밍에서 함수 A가 매개변수만 바꿔 다시 함수A를 호출하는 방법으로 구현

- 호출과정

![image](https://user-images.githubusercontent.com/37941513/222087536-5fa7d368-24c8-4287-8461-9081e1bd1b01.png)

### 재귀 함수의 구성 요소

#### 종료 조건 (ending condition , base case)

- 더 이상 재귀 함수를 호출하지 않고, 값을 반환하는 조건
- 매우 간단히 함수의 반환 값을 찾을 수 있는 경우
- 이것을 없으면, 함수를 무한히 재귀적으로 호출

#### 재귀적 함수 호출

- 종료 조건이 아닌 경우
- 함수의 인자를 바꿔 스스로를 다시 호출
- 이 때, 함수의 인자는 현재 문제보다 작은 문제를 대표해야 함
- 즉, 동일한 동작을 보다 작은 문제에 적용

---

### 일반적으로는 반복문이 더 쉽다

![image](https://user-images.githubusercontent.com/37941513/222088599-e74b3acd-11aa-4c79-8ce4-7442d2a31ea5.png)

### 반복문을 그냥 쓰면 안되나?

- 사실 모든 재귀함수는 반복문으로 해결 가능
- 그러나 복잡한 문제일 수록 재귀함수가 훨씬 편해진다

  - 이진 검색
  - 트리 구조
  - 퀵 정렬
  - 하노이의 탑
  - 어떤 폴더 아래 있는 모든 파일 목록 구하기

### 재귀함수 예 - 피보나치 수열

- 제 0 항은 0, 제 1항은 1이며, 그 뒤의 모든 항은 앞 두항의 합인 수열.
- 0 1 1 2 3 5 8 13 21 34 55
- F0=0 , F1=1, F(n)= F(n-1) + F(n-2);

```
using System;
class FiboTest
{
 static long fibo(int value)
 {
  if (value == 0)
  {
    return 0;
  }
  if (value == 1 || value == 2)
  {
   return 1;
  }

  return fibo(value-1) + fibo(value-2);
 }
 static void Main(string[] args)
 {
  if (args.Length < 1)
  {
   Console.WriteLine("인자의 수가 부족합니다...");
   Console.WriteLine("Usage : FiboTst1 Arg1");
   return;
  }

  int toValue = Convert.ToInt32(args[0]);
  for(int i=1; i <= toValue; i++)
  {
   Console.Write("{0} ", fibo(i));
  }
 }
}

```

#### 호출 과정

![image](https://user-images.githubusercontent.com/37941513/222090899-078af08d-6513-4c8b-9753-21ee5cbf626e.png)

- 함수는 신뢰의 문제
- 재귀 함수는 더 큰 신뢰 요구
- Fibanocci(4) 를 구하려 할때
  - Fibonacci(2), Fibonacci(3) 반드시 올바른 값을 반환한다 믿어야 한다
  - 왜냐면 수학적 귀납법이기 때문
  - 다른말로 Fibonacci(0), Fibonacci(1)은 반드시 1을 반환
  - 그 후의 수는 위 종료 조건에 기초하여 값을 계산할 수 있음.

##### 반복문이 더 쉬운건 수학적 귀납법이 익숙치 않기 때문

### 복잡한 내용의 함수인 경우 재귀문이 더 쉽다

![image](https://user-images.githubusercontent.com/37941513/222102995-c276380c-350b-478d-b0ac-c4c8bce9ca1b.png)

### 재귀적 해결법 = 논리력

- 프로그래머의 논리력을 평가하기 적합
- 매우 큰 문제를 작게 쪼개서 증명할 수 있나
  - 절대 틀릴 수 없는 최소한의 문제를 품
  - 최소한의 문제 해법에 의존하여 그 보다 더 큰 문제를 해결
  - 그 과정을 반복하면 논리적으로 최종 문제까지 해결
- 수학적 귀납법과 매우 밀접

### 수학적 귀납법 예시

![image](https://user-images.githubusercontent.com/37941513/222106056-f368ca7a-3789-4ccd-a980-45bd3df5c216.png)

### 재귀함수의 장점

- 개념적으로 매우 훌륭하다.
- 증명이 가능하다

### 재귀함수의 단점 - 효율성이 떨어진다. 🤔

![image](https://user-images.githubusercontent.com/37941513/222107578-717ea39f-9977-4ebd-9eae-75081e670c46.png)

- 반복문은 그런 문제가 없다.
- 이전 연산 결과를 저장(캐싱) 하기 떄문(캐시에 저장)

![image](https://user-images.githubusercontent.com/37941513/222108733-7e41a282-6824-4f78-bd29-548bdb82b844.png)

### 재귀함수의 단점 - 스택 오버플로우

![image](https://user-images.githubusercontent.com/37941513/222110422-7d3a1d58-8082-4037-8ca3-634d6ca1f48b.png)

- 함수 호출깊이엔 제한 존재

### 언제 써야 하는가

- 캐싱 없이 간단한 반복문으로 작성 가능한 문제는 반복문으로

  - 1부터 N까지 합 구하기

- 그 외에는 재귀함수로 우선 작성

  - 설계가 용이하기 떄문

- 다음의 경우는 반복문으로 코드 리팩토링
  - 함수의 호출 최대 깊이를 확정할 수 없음
  - 또는 성능상 문제 발경
  - 코드 리팩토링 : 코드 실행결과를 유지하며 코드의 구조를 재조정.

##### 재귀함수 실전에서 정말 많이 쓰인데. 다만 이슈가 있을 경우 코드 리팩토링 하는 거

#### 문제

![image](https://user-images.githubusercontent.com/37941513/222112129-7ac02d43-66e2-4e84-998f-041166060ae0.png)

![image](https://user-images.githubusercontent.com/37941513/222112315-ae1e5f9a-45a6-44dc-9f8c-9e06152b2855.png)

---

### 재귀함수 이용 예시

#### 재귀함수 쓰기전 간단한 가위바위보

![image](https://user-images.githubusercontent.com/37941513/222114055-137f0dd5-dfa9-4462-a538-58f09f806ea2.png)

무조건 플레이어가 이기는 경우. 이런 경우 두 판 이상가면 질림

---

### 랜덤 수 생성 (random number generation)

- 난수 생성이라고도 함
- 언제나 예측 가능했던 컴퓨터였으나 난수 생성이 가능해짐
- 이 덕에 게임이 나옴
- 거의 모든 프로그래밍 언어에 존재하는 개념

![image](https://user-images.githubusercontent.com/37941513/222118662-1a97fad5-5f10-4865-af8e-64c8121cf2c3.png)

### Random 클래스와 개체 생성

![image](https://user-images.githubusercontent.com/37941513/222119006-a32b68e1-8ccf-4219-80ea-89a8a17f7c3d.png)

```
Random random = new Random()
```

- 랜덤 생성기를 만들어 random이라는 변수에 대입
- random은 변수명이므로 다른 단어를 써도 무방

```
Random luck = new Random(); //OK
```

- 클래스 : 여러개의 함수가 뭉쳐있는 집합
- 개체 : 클래스 안에 있는 함수를 사용하려면 필요하다.

#### 난수 생성기

![image](https://user-images.githubusercontent.com/37941513/222119243-3213c648-e2d9-40d7-b8dc-525bf555f40c.png)

```
Random random = new Random () ; //반드시 필요한 코드
int number1 = random.Next(3);
int number2 = random.Next(1,10);
```

```
<변수명>.Next(<최대값>)
- 0 이상 최대값 미만 수 중 하나를 무작위로 뽑아줌 => [0, 최대값]


<변수명>.Next(<최소값>, <최대값>)
- 최소값 이상 최대값 미만의 수 중 하나를 무작위로 뽑아줌 => [최솟값, 최댓값]
```

---

### 수정한 가위,바위,보 게임

![image](https://user-images.githubusercontent.com/37941513/222125718-8f248f79-9821-4655-b821-f3fde046d11c.png)

근데 계속 같은 결과가 나온다.

```
using System;

namespace EMode
{
    class Program
    {
        enum EShape
        {
            Rock = 0,
            Paper = 1,
            Scissor = 2
        };
        static void Main(string[] args)
        {
 //           Random random = new Random();

            Random random = new Random(0);   //매개변수로 0 들어감

            while(true)
            {
                EShape computer = (EShape)random.Next(3);

                Console.WriteLine("Rock Scissor paper");
                EShape user = (EShape)int.Parse(Console.ReadLine());
                if (computer == user)
                {
                    Console.WriteLine($"[Draw]\nYou({user}), Computer({computer})");
                }
                else if ((computer == EShape.Rock && user == EShape.Scissor)
                    || (computer == EShape.Paper && user == EShape.Rock)
                    || (computer == EShape.Scissor && user == EShape.Paper))
                {
                    Console.WriteLine($"[Lose]\nYou({user}), Computer({computer})");
                }
                else if ((computer == EShape.Rock && user == EShape.Paper)
                        || (computer == EShape.Paper && user == EShape.Scissor)
                        || (computer == EShape.Scissor && user == EShape.Rock))
                {
                    Console.WriteLine($"[Win]\nYou({user}), Computer({computer})");
                }
                else
                {
                    Console.WriteLine($"Wrong input!");
                }
            }
        }
    }
}
```

![image](https://user-images.githubusercontent.com/37941513/222128874-605a0676-310a-4e80-ada6-ea24dbc1fe41.png)

- 위 코드로 실행하면 계속해서 실행했을 떄 같은 값이 나온다.
  - 왜?

---

### 의사 랜덤(pseudo random)

- 대부분 언어에서 지원하는 랜덤은 진정한 랜덤이 아님
  - 진짜 랜덤을 만드는 건 정말 어려운 일
  - 알고리즘의 효율성은 난수의 분포로 결정
- 시드 값을 (seed) 초기 입력값으로 하여 알고리즘을 통해 난수를 만들어내는 함수
- 그 결과는 다시 랜덤 입력값이 됨.
- 이 말은 시드가 같으면 언제나 생성된 난수의 순서가 동일

### 랜덤 함수도 마찬가지

![image](https://user-images.githubusercontent.com/37941513/222172004-058e3ace-d6cd-458f-80ee-29be7f027745.png)

- 랜덤함수는 최초(시드)를 제외하고 본인 스스로가 반환한 값을 다시 입력으로 사용.

#### 그렇기 때문에 시드가 같으면 늘 같은 결과가 나온다

![image](https://user-images.githubusercontent.com/37941513/222176070-db2bd0cc-cf7f-4ca7-9eab-1c76002158d0.png)

#### 위에서는 매번 같은 결과가 나온 것도 시드가 0일 떄의 랜덤 값이 계속 나온 것이다.

![image](https://user-images.githubusercontent.com/37941513/222181231-983ad03d-79f0-4a6d-b791-416635591de4.png)

### new Random()은 괜찮았는데?

- 이런 문제를 해결하기 위해 컴퓨터에 달린 시계를 시드값으로 사용
- new Random()도 내부적으로 그렇다
- 이걸 직접 안 해주는 언어는 시간을 직접 읽어서 시드값으로 넣어준다.

### 그럼 고정된 시드값은 쓸모가 없는가?

- 시드값을 고정시키면 좋은 경우가 있다
- 랜덤 수에 기초한 프로그램 로직에서 문제가 발생한 경우

  - 똑같은 시드값을 넣고 개발자 기계에서 실행하면 그대로 문제 재현

- 네트워크로 연결된 두 사용자가 게임을 할 때
  - 동일한 시드값을 각 컴퓨터에 넣어주고 난수를 동일한 횟수만큼 생성
  - 그러면 난수에 의해 바뀌는 게임 속 로직도 두 컴퓨터에서 동일

#### 숫자 섞기 예제

```
using System;

namespace EMode
{
    class Program
    {

        static void Main(string[] args)
        {
            const int SEED = 0; //시드 정의 . 무슨 값이든 올 수 있음. 시드 넣으면 결과값 언제나 똑같이 나온다.
            int[] numbers = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };
            Console.WriteLine($"Before Shuffling");
            Console.WriteLine($"[{string.Join(",",numbers)}]"); //이쁘게 보여주기 위함

            //Random random = new Random();
            Random random = new Random(SEED); //시드 넣으면 결과값 언제나 똑같이 나온다.

            for (int i = numbers.Length -1; i > 0; i--)     //뒤에서 앞으로 돈다(여태껏 앞에서 뒤로 돌았는데). 이거의 문제는 첫번쨰 숫자는 방문 안함.
                                                            //왜 그런가?(많이들 실수함). 두번쨰 종료조건을 조금만 바꾸면 처음 요소도 방문한다.)

            {
                int j = random.Next(0,i);   //0부터 i까지 난수 생성
                int temp = numbers[j];
                numbers[j] = numbers[i];
                numbers[i] = temp;
            }
            Console.WriteLine($"After Shuffling");
            Console.WriteLine($"[{string.Join(",", numbers)}]");
        }
    }
}
```

- SEED 값을 설정해서 실행 반복할떄마다 같은 결과값이 나온다.

문제

![image](https://user-images.githubusercontent.com/37941513/222185161-66d8a205-d1a2-4cf9-9b9d-b88518006e9d.png)
![image](https://user-images.githubusercontent.com/37941513/222185285-f36b6aa4-8e04-47c4-ad44-d9a7628f29ce.png)

- 재귀함수에서는 프로그래머의 논리를 판단하는 부분
  - 면접관이 질문을 많이 할 수밖에 없다.
  - 왜냐면 큰 문제를 작게 쪼개서 볼 수 있는지 확인하기 위함.
- 실용적인 부분에서는 재귀함수일떄 코드를 보기가 좀 더 쉽다.

- 폴더 탐색같은 경우 계속 뻗어나가는데 그럴떄마다 변수나 기타 로직 만드는 거보다 재귀를 이용해 함수 만들면 좀 더 용이함
- 그러나 함수호출을 여러번 하거나 깊게해서 스택 오버플로우가 날 경우가 있다.

  - 이런 경우는 반복문에 기초해서 변환 해야할 수도 있다.

- 랜덤 수는 게임이나 이런게 들어가고 그걸 재밌게 만들어줌.

---

## 배열 안의 배열

### 2D배열의 문제

- 직사각형의 데이터만 지원 가능
  ![image](https://user-images.githubusercontent.com/37941513/222440393-85946d36-c9c9-4d93-b7bd-303342ecc8b2.png)

- 하지만 각 행마다 열 수가 달라져야 한다면?
- 1D 배열에는 없는 문제
  - 행이 한개이므로 원하는 열의 개수를 적용 가능

### 해결 방법 - 배열 안의 배열

- 바깥 배열(다른 배열을 포함하는 배열)
  - 1D 배열
  - 각 요소형은 다시 1D 배열(안 쪽 배열)
- 안 쪽 배열
  - 1D 배열
  - 각 요소의 형은 실제 자료형

### 바깥 배열을 만드는 법

![image](https://user-images.githubusercontent.com/37941513/222446742-71aee473-a3b5-4848-8aff-083c5a846d55.png)

![image](https://user-images.githubusercontent.com/37941513/222447494-e54314a1-d9b0-4c3f-b727-d85b3e9edaa3.png)

![image](https://user-images.githubusercontent.com/37941513/222449040-73b96bd5-6aa8-406e-bc7a-8dc8b11c06a6.png)

- Null 출력

- 아무것도 없음 : NULL

![image](https://user-images.githubusercontent.com/37941513/222449375-4acf0ae4-cc6a-4261-a67e-919c90497edf.png)

```
String [][] classrooms = new string [CLASS_COUNT][];
```

- CLASS_COUNT 수 만큼 문자열 배열을 담을 공간을 만드는 게 전부다.

### 안 쪽 배열 만들기 예제

![image](https://user-images.githubusercontent.com/37941513/222450347-f49f1535-1cd0-4030-abc6-ad074761716c.png)

### 안 쪽 배열에 접근하는 법

![image](https://user-images.githubusercontent.com/37941513/222452667-00489668-0381-47d7-a3ff-93fa339c8023.png)

![image](https://user-images.githubusercontent.com/37941513/222453445-5bd59a2c-62a6-40ca-847b-0f878be52a49.png)

### 원본이 바뀐다?

- 값에 의한 전달이 아니라 참조에 의한 전달이였던건가?

```
string[] studentNames = classrooms[classIndex];
studentNames[studentIndex] = "Severus";
```

![image](https://user-images.githubusercontent.com/37941513/222454198-ee0cb0fd-96a7-4337-9f65-8f99b20b3a4d.png)

```
using System;

namespace EMode
{
    class Program
    {

        static void Main(string[] args)
        {
            const int CLASS_COUNT = 3;
            int[] STUDENT_COUNT_PER_CLASS = { 3, 2, 5 };
            string[][] classrooms = new string[CLASS_COUNT][];
            for (int i = 0; i<CLASS_COUNT; i++)
            {
                classrooms[i] = new string[STUDENT_COUNT_PER_CLASS[i]];
            }
            int classIndex = 0; //1반
            int studentIndex = 0; //첫번쨰 학생

            string[] studentNames = classrooms[classIndex];
            studentNames[studentIndex] = "Severus";

            Console.WriteLine($"Class 1 - Student 1: {classrooms[classIndex][studentIndex]}");
        }
    }
}
```

![image](https://user-images.githubusercontent.com/37941513/222455096-98bbd659-094c-4f72-98f9-84575f124ee4.png)

결과를 보면 바뀌어 있다.

### 왜?

```
int num1 = 20;
int num2 = num1;
num2 = 10;
```

하면 그대로 20이고 10으로 안 바뀌고 변수 다 그런데 왜 studentNames[0]은 바뀌었나?

일반적인 값들은 다 값에 의한 전달이지만 **new로 만든 것들은 원본이 바뀐다**.

**즉, new로 만든 건 기본적으로 그 데이터 자체가 참조형 데이터다.**

참조형이기 떄문에 이제 원본이 다 바뀐다.

문제

![image](https://user-images.githubusercontent.com/37941513/222458712-08d5c9f9-8301-4c98-b595-d03153a5ef59.png)

![image](https://user-images.githubusercontent.com/37941513/222458627-3409241a-ff4f-43fd-ae5c-ea33defd3d76.png)

### 안쪽 배열을 늘리는 법

```
string[][] classrooms = new string[CLASS_COUNT][];

classrooms[0] = new string[3];
classrooms[1] = new string[2];
classrooms[2] = new string[5];
```

- 안쪽 배열은 여전히 1D배열 -> 추가 인원을 받지 못함

  - 배열의 크기가 2에서 3으로 늘 수 없다는 의미

- 방법은 오직 하나 뿐

  1 . 크기가 3인 배열을 새로 만든다

  2 . for문을 이용해 기존의 배열 데이터를 새 배열로 복사한다.

  3 . 새 배열을 바깥 배열에 대입한다.

### for문으로 배열 복사하기

![image](https://user-images.githubusercontent.com/37941513/222464101-d4fdd7b6-c95f-4838-beb9-74cfc346033e.png)

```
string [][] classrooms = new string[CLASS_COUNT][];
// 학생들 이름을 넣는 코드는 생략
string[] classroom2 = classrooms[1];

string[] newClassroom2 = new string[classroom2.Length+1];
for (int i = 0l i < classroom2.Length ; ++i)
{
    newClassroom2[i] = classroom2[i];
}
newClassroom2[newClassroom2.Length -1] = "Leanne";
classrooms[1] = newClassroom2;
```

### Array.Copy()를 이용한 배열 복사

- for 문 쓰는게 면접 더 나오고 이러지만 실무에선 이렇게 간단하게도 많이 쓴다. 단, 이거만 쓴다고 for문 쓰는 거 까먹었다는 건 말이 안 됨.

![image](https://user-images.githubusercontent.com/37941513/222465606-0ed13000-2203-44d8-8408-e174622456f8.png)

```
string [][] classrooms = new string[CLASS_COUNT][];
// 학생들 이름을 넣는 코드는 생략
string[] classroom2 = classrooms[1];

string[] newClassroom2 = new string[classroom2.Length+1];

Array.Copy(classroom2, newClassroom2, classroom2.Length);
newClassroom2[newClassroom2.Length-1]="leanne";
classrooms[1] = newClassroom2;
```

- classroom2 내용을 newClassroom2으로 복사하는 것(첫 번쨰 요소를 두 번째 요소로 복사)

### Array.Copy()

![image](https://user-images.githubusercontent.com/37941513/222465918-e05b848a-0861-4c20-b833-5304306158a9.png)

### 2D 배열 vs 배열의 배열

![image](https://user-images.githubusercontent.com/37941513/222467014-e62cf27e-267e-4905-8015-77177dcd59a2.png)

#### 사실 배열의 배열은 2차원 배열을 요소로 가질 수 있다.

![image](https://user-images.githubusercontent.com/37941513/222467249-c715330b-6201-4b1d-9ac5-08a3e1cea4a8.png)

문제

![image](https://user-images.githubusercontent.com/37941513/222469306-4c5986a5-e093-4b5e-b0df-16109756cca2.png)

```
using System;

namespace EMode
{
    class Program
    {

        static void Main(string[] args)
        {
            int[] STUDENT_COUNT_PER_CLASS = { 10, 15, 21 };
            int classCount = STUDENT_COUNT_PER_CLASS.Length;
            string[] STUDENT_NAMES = { "john", "Pope", "Bob" };

            string[][] classrooms = new string[classCount][];
            for (int i = 0; i < classCount; ++i)
            {
                classrooms[i] = new string[STUDENT_COUNT_PER_CLASS[i]];
            }

            for (int classIndex = 0; classIndex< classCount; ++classIndex)
            {
                string[] studentNames = classrooms[classIndex];

                for (int studentIndex = 0; studentIndex < studentNames.Length; ++studentIndex)
                {
                    studentNames[studentIndex] = STUDENT_NAMES[studentIndex % 3];
                }
            }
            string[] classroom2 = classrooms[1];
            string[] newClassroom2 = new string[classroom2.Length +1];

            for(int i = 0; i < classroom2.Length; ++i)
            {
                newClassroom2[i] = classroom2[i];
            }
            newClassroom2[newClassroom2.Length -1] = "Leanne";
            classrooms[1] = newClassroom2;
        }
    }
}
```

![image](https://user-images.githubusercontent.com/37941513/222469971-642d5859-1bfe-4261-bb9a-f481032411da.png)
![image](https://user-images.githubusercontent.com/37941513/222470026-d1c3cdc7-bcac-443e-9752-e99fdcb94ae6.png)

![image](https://user-images.githubusercontent.com/37941513/222469714-3b9cafe9-0149-416b-b0ef-a2058d326a22.png)

---

### 배열의 배열 예제

```
using System;

namespace ArrayOfArrays
{
    class Program   //간단한 캘린더 프로그램
    {
        static void Main(string[] args)
        {
            const int MONTHS_IN_A_YEAR = 12;
            int[] daysInEachMonth = new int[MONTHS_IN_A_YEAR] { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

            string[][] calendar = new string[MONTHS_IN_A_YEAR][]; //calendar는 문자열 배열을 포함하는 배열이 될 것

            for (int i = 0; i<MONTHS_IN_A_YEAR; i++)
            {
                calendar[i] = new string[daysInEachMonth[i]];   //바깥 배열의 각 요소를 문자열 배열로 초기화
            }
            while(true)
            {
                Console.Write("Enter the Month (1-12): ");
                string monthString = Console.ReadLine();
                int month = int.Parse(monthString);
                if (0>=month || month >12)
                {
                    Console.WriteLine("Invalid range of month. Terminating program");
                    break;
                }
                Console.WriteLine($"enter the day(1-{calendar[month -1].Length}):"); //날을 입력. 몇월인지에 따라 날짜 범위는 1~28, 1~30, 1~31 중 하나가 됨.
                string dayString = Console.ReadLine();

                int day = int.Parse(dayString);
                if(0>= day || day > calendar[month-1].Length)
                {
                    Console.WriteLine("Invalid range of month. Terminating program");
                    break;
                }
                Console.WriteLine("Enter your schedule:");
                string schedule = Console.ReadLine();

                calendar[month - 1][day - 1] = schedule;
                Console.WriteLine("---------------------");

                for(int i = 0; i<MONTHS_IN_A_YEAR- 1; i++)
                {
                    for (int j = 0; j < calendar[i].Length; j++)
                    {
                        if (!string.IsNullOrEmpty(calendar[i][j]))  //calendar[i][j]가 비어있거나 널이 아니면
                        {
                            Console.WriteLine($"{i + 1}/{j + 1}:{calendar[i][j]}"); //그날의 스케줄 출력
                        }
                    }
                }

                Console.WriteLine("---------------------");
            }
        }
    }
}

```

---

## 문자열 분할

![image](https://user-images.githubusercontent.com/37941513/222711106-e1464398-6847-4f33-b490-9e30a90b4a1e.png)

![image](https://user-images.githubusercontent.com/37941513/222759305-3e1a5d45-3065-4645-a95c-f6d0a94ea75c.png)

![image](https://user-images.githubusercontent.com/37941513/222759364-c433c2e3-4836-48e1-8aaf-93dfef8a0c71.png)

![image](https://user-images.githubusercontent.com/37941513/222759437-adef21f8-9117-4d2b-a621-9fec82b98975.png)

![image](https://user-images.githubusercontent.com/37941513/222759520-7ac82cc1-8270-4c6a-98ab-eaf2b52c985a.png)

![image](https://user-images.githubusercontent.com/37941513/222771931-8fc8ca29-7773-4d0c-8c17-b8ff56c1c126.png)

![image](https://user-images.githubusercontent.com/37941513/222774071-4b9b2bed-0bad-4e22-9e9f-7afe79110747.png)

### 토큰을 읽어오는 법

- 토큰 : 연속된 데이터에서 쪼갤 수 있는 가장 작은 단위
  ![image](https://user-images.githubusercontent.com/37941513/222774398-f75aa7c4-8f6e-4e19-9741-2035773d81db.png)

- 별도의 for문이 필요
- string의 IndexOf(), Substring()등의 함수 또는 첨자 연산자([])를 이용해서 구분 가능

### IndexOf()

![image](https://user-images.githubusercontent.com/37941513/222774522-a3b7ed21-f2b2-4b7b-a7d2-47376dc092e4.png)

```
string nameMessage = "C# is very fun";
int index = message.IndexOf('v'); //6반환
```

- char의 위치를 찾아서 색인을 반환하는 함수

  - 문자가 문자열에 여러번 나타나면 가장 처음에 나타난 곳의 색인 반환
  - 찾는 문자가 문자열에 없다면 -1을 반환

- 다양한 버전의 IndexOf() 함수가 존재함

### Substring()

![image](https://user-images.githubusercontent.com/37941513/222776141-e1960d88-8c19-4b43-81f0-3709074a5830.png)

```
string nameMessage = "name: Pokemon";
string name = nameMessage.Substring(6); //"pokemon"반환
```

- 지정된 문자 위치(색인)에서부터 문자열을 반환하는 함수

- 마찬가지로 다양한 버전의 Substring() 함수가 존재한다.

### 첨자 연산자

![image](https://user-images.githubusercontent.com/37941513/222776585-9f76bfc4-c0c9-422d-89fc-0e6481e82b64.png)

```
string HPMessage = "HP:100";
char ch = HPMessage[4]; //'1';
```

문자열 변수 이름[<색인>];

- <색인>위치에 있는 문자 하나를 반환

### 토큰을 읽어 오는 법

![image](https://user-images.githubusercontent.com/37941513/222781520-d89de93d-bafd-48f6-8d70-bac90973acc0.png)

- 이런 정형화 된 데이터를 쉽게 읽어오는 함수가 존재한다
  - 문자열 토크나이저

### 문자열 토크나이저 - Split()

![image](https://user-images.githubusercontent.com/37941513/222786058-3393e96c-8e51-445b-8520-d3cb3663a754.png)

```
string text = "pokemon,1,10000"
string[] tokens = text.Split(','); //"pokemon","1","10000
```

문자열 변수 이름.Split(char)

- char는 문자열 쪼갤 떄 사용할 구분 문자
- 원본 문자열은 변경없이 그대로 유지
- 쪼갠 문자열을 문자열 배열로 반환
- 여러버전의 Split()가 존재함

### 여러 개의 구분 문자가 문자열에 있는 경우

![image](https://user-images.githubusercontent.com/37941513/222787613-83594893-7e78-4014-af66-01793b113be9.png)

```
string text = "pokemon,1:10000"

char [] delimiters = {',',':'};
string [] tokens = text.Split(delimiters); //{"pokemon","1","10000"}
```

문자열 변수 이름.Split(char[]);

- 문자열 배열 (char[])에 여러개의 구분 문자를 대입

### 구분 문자 사이가 비어있다면

- 문자열을 쪼개면 빈 문자열이 나옴
  ![image](https://user-images.githubusercontent.com/37941513/222789173-0c9042ff-3602-47b3-91a0-f6b1af1781d8.png)

```
string text = "pokemon,1,10000:,10,1000:LopeMon,100,100";

char [] delimiters = {',',':'};
string [] tokens = text.Split(delimiters);
//{"pokemon","1","10000","","10","1000","LopeMon","100","100"}
```

### 구분 문자 사이가 비어있다면 - 해결법

![image](https://user-images.githubusercontent.com/37941513/222790737-b79cf99f-4982-4b89-bac9-5f97a29d4160.png)

- StringSPlitOptions.RemoveEmptyEntries를 사용

```
string text = "pokemon,1,10000:,10,1000:LopeMon,100,100";

char [] delimiters = {',',':'};
string [] tokens = text.Split(delimiters, StringSPlitOptions.RemoveEmptyEntries);
//{"pokemon","1","10000","","10","1000","LopeMon","100","100"}
```

---

### 불필요한 공백 지우기

![image](https://user-images.githubusercontent.com/37941513/222791306-f0e64993-ebba-43e1-b116-96acd19be70c.png)

```
string firstName = "    Leon";
string lastName = "Kim      ";
string trimmedFirstName = firstName.Trim(); //"Leon";
string trimmedLastName = lastName.Trim(); //"kim";
```

문자열 변수 이름.Trim()

- 문자열 앞뒤로 있는 공백을 없앤 후 문자열을 반환
- 원본 문자열은 변경 없이 그대로 유지

### 불필요한 공백 지우기 - TrimStart()

![image](https://user-images.githubusercontent.com/37941513/222794428-6df61233-a0d8-4f4d-b5bc-ec55a5bd0994.png)

### 불필요한 공백 지우기 - TrimEnd()

![image](https://user-images.githubusercontent.com/37941513/222794489-a152b6c3-0445-4108-af63-0323f925769c.png)

### 정리

- 배열의 배열은 2D배열과 다름.
- 배열의 배열은 만약 학교에 반마다 학생이 다른데 이런 경우 사용 가능(그와 비슷하거나)
- 2D배열은 추가시 크기가 고정되서 추가하기 불가능 하나, 단 더 큰 배열 만들고 배열 복사해두고 새로운 거 추가하는 식으로 가능.

- 문자열 분할은 컴퓨터 공학에서 중요하진 않을 수도 있긴 함
- 어떤 특정한 분리문자를 써서 단어들을 뗴온다.
- 이 외 string을 다루다 보니 안에 함수들도 있다. 이런거 알아두자.

---

### 함수 오버로딩

```
static float AverageFromInts(int[] scores)// 함수 바디 생략
static float AverageFloat(float[] floats) //함수 바디 생략
```

- FromInts, FromFloats이 없어도 이미 매개변수 형에서 유추 가능
- 같은 형이 아니면 호출 자체가 불가능
- 동일한 이름 사용 할 수 있을까?

```
static float Average(int[] scores)// 함수 바디 생략
static float Average(float[] floats) //함수 바디 생략
```

- 있다. 이를 함수 오버로딩이라고 부른다.

### 함수 오버로딩

![image](https://user-images.githubusercontent.com/37941513/222871568-76efb0d9-7b81-43c2-9ca4-97de9f99bc14.png)

- 동일한 이름을 가진 함수 구현을 허용하는 기능
- 단, 매개변수의 목록이 달라야 한다
- 함수의 이름 + 매개변수가 함수의 시그니처라 했다.
- 반환형은 일부가 아님.

- 매개변수 목록을 제외하고는 모든게 동일
- 반환형은 상관 없음

![image](https://user-images.githubusercontent.com/37941513/222871987-7d348b9b-03b4-46d6-bae0-44afd24e426b.png)

### 모든 걸 함수 오버로딩으로?

- 잘못된 함수 호출이 일어날 수 있음

```
static string[] GetStudents(float height);
static string[] GetStudents(int age);

int height = 178;
Getstudent(height);
Getstudent(178);
```

- 동일한 매개변수 함수가 없다면, 승격(promotion)/묵시적 형변환을 통해 일치하는 함수를 찾는다.

```
static string[] GetStudents(float height) //함수 바디 생략

//메인 함수
int age = 17;
Getstudent(17);
Getstudent(17);
```

- 따라서 이런 경우 오버로딩을 안 쓰는게 낫다

![image](https://user-images.githubusercontent.com/37941513/222872507-70cf10c6-5740-4f86-830d-4be65188850a.png)

### 코딩 표준 : 함수 오버로딩

1 . 매개변수가 다른 경우 = 오버로딩
2 . 승격/묵시적 변환을 해도 상관 없는 경우 -> 오버로딩

```
static double Sqrt(double num) //함수 바디 생략
static int Sqrt(int num)//함수바디 생략

//메인함수
Sqrt(10.0f); //double형을 호출해도 그닥 문제는 없다.
```

- 실제 C# 의 Math 라이브러리도 float보단 double을 더 많이 지원함
  - float 지원 함수 : Abs(), Clamp(), Max(), Min(), Sign()
  - float 미지원 함수 : Ceiling(), Cos(), Floor(), Log(), Pow(), Round() 등

3 . 매개변수가 아예 승격이 불가능한 경우 -> 오버로딩
(예: string <-> int 혹은 string[] <-> int[])

```
static string[] GetStudent(string name);
static string[] GetStudent(int age);

```

4 . 그런 게 아니라면 함수 오버로딩 보다는 다른 이름을 쓸 것

---

### 기본값 인자

#### 약간만 차이나는 함수라면?

//좋은 예는 아님

```
static string GetFullAddress(string street, string city);
static string GetFullAddress(string street, string city, string state);
```

- 두 코드의 차이는 string state 뿐
- 이 처럼 함수 간 중복된 매개변수가 많을 경우 어떻게 해야하나?

  - 함수를 계속 오버로딩하면?
  - 도시개념이 없는 나라를 고려해야하면?

```
static string GetFullAddress(string street); 를 추가?
```

### 기본값 인자(default parameter)

```
static string GetFullAddress(string street, string city, string state = "")
static float GetHP(int level, int mapID, int difficulty = 0)

//메인함수
GetFullAddress("123 Main street", "Big City", "Big state");
GetFullAddress("456 jido-daero", "Seul"); //OK

GetHP(1,1234,10); //OK
GetHP(1,1234); //OK
GetHP(1,1234,0); //OK

```

- 매개변수 선언시 미리 기본값 설정해 둘 수 있다.
- 하나 이상 가능

```
//컴파일 오류
static string GetHP(int level, int mapID, int difficulty = 0, string name);
//OK
static float GetHP(int level, int mapID, string name int difficulty = 0 );

```

- 매개변수 목록 중간에 기본값 인자가 아닌 것이 오면 안 된다.

---

### 기본값 인자의 문제점 1

- 나중에 누군가 기본값 인자를 중간에 추가할 시 이상한 일이 일어날 수 있다.

```
static float GetHP(int level, int mapID, int difficuilty = 0)

static float GetHP(int level, int mapID, int decimalPoint = 1, int difficuilty = 0)
```

- 기본값 인자가 도중에 변경될 경우 기존 사용 코드에서 문제 발생할 수 있다.

```
static float GetHP(int level, int mapID, int difficuilty = 0)

static float GetHP(int level, int mapID, int difficuilty = 1)
```

### 코드 표준 : 기본 인자값

- 새 기본 매개변수는 언제나 뒤에 둘 것

  - 즉, 중간에 끼우지 말 것

- 기본값은 언제나 0으로 할 것

  - 0이 아니면 기본 매개변수로 하지 말 것

- 함수 오버로딩 대신 실제 함수 이름을 제대로 써주는 게 더 좋을 떄도 있다는 것을 기억할 것

- 매개변수 직접 넣어 줄 것

---

### out 매개변수

#### 나누기 함수 개선

```
static bool TryDivide(float numerator, float denominator, ref float result)
{
if(denominator == 0.0f)
{
return false;
}
result = numerator / denominator;

 return true;

}

static void Main (string[] args)
{
float result1= 0.0f;
bool bSuccess 1= TryDivide(10.0f, 0.0f, ref result1);
float result2= 0.0f;
bool bSuccess2= TryDivide(10.0f, 5.0f, ref result1);

}
```

### Out 매개변수

- 함수 안에서 대입 안하면 컴파일 오류

```
//컴파일 오류
static bool TryAdd(float num1, float num2, out float result)
{
    return false;
}
//OK
static bool TryAdd(float num1, float num2, out float result)
{
    result = 0.0f;
    return false;
}

```

### 키보드 입력에서 숫자 이외 값을 넣음

```
int num = int.Parse(Console.ReadLine());
```

- 문제점: 숫자 이외 값을 넣으면 예외 발생
- 해결법 : TryParse();

```
int num;
bool bSuccess = int.TryParse(Console.ReadLine(), out num);
//bSuccess에 따라 코드 작성
```

- TryParse()는 예외처리 없이 예외 상황을 처리할 수 있는 방법
  - int로 변환 시도해서 성공하면 true, 실패시 false
- 함수가 반환형을 두개 가질 수 있다면 이 문제가 없을 수도 있다.

---

## 문자열 빌더

### 문자열 합치기는 느릴 수 있다.

- 임시로 만들고 버리는 문자열이 너무 많기 때문

![image](https://user-images.githubusercontent.com/37941513/222877707-244089b3-d77b-478d-8e6a-90c2129b9b06.png)

```
for (int i = 0; i<=100 ; i++)
{
    ++result;
    message = message + result + " ";
}
```

### 가비지 수집기(garbage collector, GC)

- 새로 만들어진 문자열들은 언젠가 지워져야 함
- C#에서는 그걸 가비지 수집기라는 시스템이 자동으로 해줌
- 다만, 쓰레기 문자열이 넘쳐나면 GC의 성능 저하가 올 수 있음

### 해결법

- 임시 문자열 수를 줄이면 됨
- 그러나 문자열 합치기는 매우 자주하는 연산
- 따라서 최적화 하기위한 라이브러리 존재

**그게 StringBuilder**

### StringBuilder 라이브러리

- 문자열을 효율적으로 만들어주는 라이브러리
- 대략적인 동작 방법

  - 긴 문자열을 담을 수 있는 충분한 공간을 미리 확보
  - 추가되는 문자열들로 그 공간을 차례로 채워나감
  - 모든것이 준비되면 최종적으로 문자열을 만들어서 반환

```
using System;
using System.Text; //문자열 빌더 사용하기 위해 using

namespace StringBuilderExample
{
    class Program   //간단한 캘린더 프로그램
    {
        static void Main(string[] args)
        {
            StringBuilder builder = new StringBuilder(4096);
            builder.AppendLine("Hello Pope");
            builder.AppendLine("Give me");
            builder.Append(2);
            builder.AppendLine("  dollars");

            string greetings = builder.ToString();
            Console.WriteLine(greetings);
        }
    }
}

```

### StringBuilder 생성하기

![image](https://user-images.githubusercontent.com/37941513/222878447-f4ea835d-ebbb-4a50-878c-1650ea234efc.png)

```

using System.Text; //문자열 빌더 사용하기 위해 using
//함수 안에서
StringBuilder builder = new StringBuilder(4096);
```

StringBuilder <변수명> = new StringBuilder(int maxCharCount);

- 총 용량이 maxCharCount 인 StringBuilder 생성
  - string은 내부적으로 char[]와 다르지 않다.
  - 큰 char[]를 확보해 둔다 생각하면 좋다.

### 문자열 추가

![image](https://user-images.githubusercontent.com/37941513/222878544-b584ba23-8e96-4028-bf79-44007c0e6cde.png)

- StringBuilder의 내부 문자열에 문자열을 추가
- 여러 오버로드 함수들 존재

### 문자열 아닌 것도 합치기 가능하다

![image](https://user-images.githubusercontent.com/37941513/222878615-6b45f9a7-6228-4035-aca1-d23bb5814128.png)

- 기존의 문자열 합치기(+ 연산자 ) 처럼 StringBuilder 또한 다양한 자료형을 문자열에 합칠 수 있다.

### 배열의 총 용량과 사용 중인 길이 얻기

![image](https://user-images.githubusercontent.com/37941513/222878750-acfb72b9-9ca9-4ca3-a94e-2dc2e395d921.png)

- 각각 내부 배열의 총 용량과 길이 값을 가지고 있음

- 함수 아님

### 추가 공간 확보

![image](https://user-images.githubusercontent.com/37941513/222879000-174bbfb2-2449-4a1d-891c-95fdff396376.png)

### StringBuilder - 최종 문자열 얻어오기

```
StringBuilder builder = new StringBuilder(4096);
//문자열 추가 코드 생략

string greetings = builder.ToString();
```

![image](https://user-images.githubusercontent.com/37941513/222879083-2c7afcbd-8a9b-4581-bede-0fde6ee94848.png)

### 임시 문자열은 몇개인가

![image](https://user-images.githubusercontent.com/37941513/222879210-22b22a75-7c3f-40c7-b87c-8b200d190f22.png)

### 처음 확보해 둔 공간을 다 쓰면?

- 아무 문제 없다
- 전에 배열의 배열에서 학생을 추가했듯이 StringBuilder가 자동적으로 내부 공간을 늘린 뒤 모든 데이터를 복사

![image](https://user-images.githubusercontent.com/37941513/222879305-76a327ba-52ad-4a65-b662-6db930028dd0.png)

```
StringBuilder builder = new StringBuilder(10);
builder.Append("Hello ");
builder.AppendLine(" human");
```

---

### StringBuilder의 기타함수

- Insert()
- Replace()
- Remove()
- Clear()

### Insert()

```
StringBUilder builder = new StringBuilder(4096);
builder.AppendLine("Hello ");
builder.Insdert(6,"and bye");
```

![image](https://user-images.githubusercontent.com/37941513/222879457-27b969b1-996c-49a6-930a-799d0f5faceb.png)

- StringBUilder의 내부 배열 중간(int index)에 새로운 문자열(string text)를 삽입.
- 여러가지 오버로드 함수 존재
  - Append()와 마찬가지로 다양한 매개변수 형 지원

### Replace()

![image](https://user-images.githubusercontent.com/37941513/222879471-fa95a29e-a2ae-4a82-9ec3-9cc8e8d082cc.png)

### Remove()

![image](https://user-images.githubusercontent.com/37941513/222879503-31966dd9-76a3-49f8-b1ed-2bdc5a36ee2e.png)

### Clear()

![image](https://user-images.githubusercontent.com/37941513/222879547-be41c296-58e3-49bd-832f-35284b0d0a30.png)

- 임시 문자열을 제거하는 함수
- 이 함수를 호출 후 길이 확인하면 0

### StringBuilder vs 문자열 합치기

- 합칠 문자열이 몇개 없다면 StringBuilder를 쓸 이유가 크게 없음
  - 쓰는게 귀찮기도 함
- 대여섯개 합치면 그때부터 StringBuilder를 고려
- 수십개면 당연히 써야한다

---

<br>

## decimal 형

### 부동 소수점의 정밀도 문제

![image](https://user-images.githubusercontent.com/37941513/222880981-9475719d-aaa4-4aa7-8a9e-ed5d14547fa6.png)

- 지수에 따라 소수점이 둥둥 떠다니는 자료형

- 비트 수는 정해져있는데 표현해야 할 숫자가 너무 많다
  - 0부터 0.00000000000001씩 더해 1까지 가는 과정을 정확히 출력 가능한가
    - 불가능. 이미 32개 비트만으로 표현할 수 있는 수의 개수를 넘어감
    - 1을 출력하기 전 많은 수들이 정확하지 않게 출력
  - 정수에 이런 문제가 없는 이유는 사실상 열거형이기 때문
  - 따라서 부동소수점에서 근접한 두 수는 같은 값이 될 수도 있음

**부동소수점형 값은 언제나 근사값이다**

### 은행에서 쓰기 적합한가?

![image](https://user-images.githubusercontent.com/37941513/222881174-f5a593b4-18d4-4825-b2f6-bc6ed7fc0c7d.png)

- 정밀도 때문에 불가능

### 그럼에도 쓰는 이유?

![image](https://user-images.githubusercontent.com/37941513/222881202-3065bf45-5628-4120-a7b6-c02add7d9c01.png)

- 다른 곳에서는 크게 문제 없기 떄문

### 해결책 1: 정수로 변환해서 쓰기

![image](https://user-images.githubusercontent.com/37941513/222881303-835a365c-ceb8-463c-b066-9792e1ac48b3.png)

- 달러의 경우 , 금액에 100 곱함
  - 예: $10.10 + $0.01 = $10.11 ->1010+1=1011
- 화면에 보여줄때는 100으로 나누고 반올림 해서 보여줌
- 더하기 빼기에만 올바른 방법
  - 달러를 곱할 일이 있나?
- 정수가 표현할 수 있는 범위까지만 표현 가능
  - 32비트 정수에서는 문제(0~4,294,967,295)
  - 64비트 정수에서는 크게 문제가 아님(0~9,223,372,036,854,775,807)
  - 단, 소수점 9자리까지 계산해야한다면?

### 해결책 2: 문자열 사용

![image](https://user-images.githubusercontent.com/37941513/222881331-b56cc0ed-e540-4d44-bd2a-844ad55524de.png)

1 . 문자열은 무한의 길이를 가지니 숫자가 아닌 문자열로 저장 - ex ) '10.01' + '0.01'

2 . 그리고 두 숫자를 계산시 문자열에서 각 자리의 문자를 숫자로 바꾼 뒤 한 자리씩 계산

### 해결책 3: decimal 자료형 사용

![image](https://user-images.githubusercontent.com/37941513/222881416-fb42d5f4-8e3c-4f48-8196-dec273140c99.png)

- CPU(기계) 자체에서 지원하는 형은 아님
- 금융권에서 돈 계산에 쓰기 적합
- 일부 언어에도 비슷한 해결책 존재
  - java의 BigDecimal

### decimal 자료형 사용하기

![image](https://user-images.githubusercontent.com/37941513/222881464-9cc0731a-4f93-48ac-b08d-3f637f51c926.png)

- 접미사 'm' 사용

  - 정수일 때는 안 붙여도 됨(묵시적 변환 허용, 단, 그 반대는 안 됨)
  - 부동소수점일 시, 반드시 붙여야 함

### decimal 자료형과 다른 자료형간의 변환

![image](https://user-images.githubusercontent.com/37941513/222881509-67ad703a-2c04-42a6-b1d5-9018056f481b.png)

---

<br>

## 컬렉션

### 컬렉션 정의

![image](https://user-images.githubusercontent.com/37941513/222882116-a4c7ac75-b0fc-46f3-bc6d-74be2ac3f3fc.png)

- 동일한 형의 여러 자료를 저장하는 공간
- 자료구조의 일부
- 다른 언어에서는 컨테이너라 부름

### 배열 vs 컬렉션

| 배열                     | 컬렉션                        |
| ------------------------ | ----------------------------- |
| 자료 구조                | 자료 구조                     |
| 요소의 수를 바꿀 수 없음 | 요소의 수를 바꿀 수 있음      |
| 유용한 함수 제공 안함    | 유용한 함수를 기본적으로 제공 |

### 컬렉션 종류

- 단순한 컬렉션 : 길이가 바뀔 수 있는 배열
- 복잡한 컬렉션 : 자유로운 길이 + 다양한 요소 접근 방법

![image](https://user-images.githubusercontent.com/37941513/222882246-bb188613-42f9-41b3-bb0f-21be897e1426.png)

### 가장 많이 쓰는 컬렉션

- List
- Dictionary
- HashSet

그 외에 Stack, Queue, LinkedList 등

멀티 쓰레드 환경에도 안전한 컬렉션들도 있다. - System.Collections.Concurrent 네임스페이스를 볼 것

### 리스트

- 배열과 거의 비슷
- 색인(0부터 n)을 통해 데이터에 접근
- 그러나 배열의 길이(담을 수 있는 최대 요소 수)를 언제든 바꿀 수 있다.

![image](https://user-images.githubusercontent.com/37941513/222882671-830e6e4d-d74e-4892-abe9-ead6111b36a3.png)
![image](https://user-images.githubusercontent.com/37941513/222882683-2b9cd3a1-da5f-4978-91bd-ba267d815bd3.png)
![image](https://user-images.githubusercontent.com/37941513/222882733-0d6229e8-0030-4d2d-8237-9900ed656293.png)
![image](https://user-images.githubusercontent.com/37941513/222882874-b1610673-24fc-43d4-91ba-3de4b68c508e.png)

![image](https://user-images.githubusercontent.com/37941513/222882952-69e8dd80-d5e2-4a85-becf-2a3635227d6c.png)
![image](https://user-images.githubusercontent.com/37941513/222883120-8d799653-d971-4830-9ebe-c23c0c2e3331.png)
![image](https://user-images.githubusercontent.com/37941513/222883178-96fdbc02-1f56-48b2-a0e3-4dca5d90f630.png)
![image](https://user-images.githubusercontent.com/37941513/222883388-cfe63d1b-c720-4251-bfa2-4b7f65c2c9f2.png)
![image](https://user-images.githubusercontent.com/37941513/222883407-0754e2de-96b9-4db2-999d-59111bc8610a.png)
![image](https://user-images.githubusercontent.com/37941513/222883432-7e867c86-2a85-4a37-8417-3a9fb3763a91.png)
![image](https://user-images.githubusercontent.com/37941513/222883453-46687c02-95ff-4071-a006-fd461decb8b6.png)
![image](https://user-images.githubusercontent.com/37941513/222883481-96d3333b-a82d-4814-930c-a99a26fb30ba.png)
![image](https://user-images.githubusercontent.com/37941513/222883511-ae52c696-2169-43d5-9a6b-140a30765f23.png)
![image](https://user-images.githubusercontent.com/37941513/222883522-598ea12d-6f75-4b24-aac1-0e2d7a179d74.png)

- 언제 쓰면 좋나?
  - 배열 사용 하는 곳에는 다 사용하기 좋다.

![image](https://user-images.githubusercontent.com/37941513/222893620-0ef95cbe-80cd-4129-8fee-8efecd04d982.png)

![image](https://user-images.githubusercontent.com/37941513/222893624-a9d88723-7a68-4ae8-a587-95217c8165ec.png)

---

### 딕셔너리

- List < T >와 다른 점은 색인이 0~n이 아니라 임의의 데이터 형

  - 이 임의의 데이터형을 키(key)라고 함
  - 실제 저장되는 값은 값(value)라고 함

- 실제로 사용하는 사전과 비슷하다.

- 배열에서 색인이 동일하면 같은 위치 가르켰듯이 키가 동일하면 같은 값을 가리킨다.

- 따라서 내부 데이터 저장은 배열처럼 연속된 메모리에 할 수 없다. -> 당연히 배열이 더 효율적

- 다른 언어에서는 딕셔너리 대신 맵이라 한다.

![image](https://user-images.githubusercontent.com/37941513/222894224-cac1bb17-544e-4a51-8125-1f84d5da66ec.png)

![image](https://user-images.githubusercontent.com/37941513/222894416-44af8627-9c08-4820-8dc6-f0efbc9f94ef.png)

![image](https://user-images.githubusercontent.com/37941513/222894436-d02bed61-7086-4598-93d3-8d1a6eb5993d.png)

![image](https://user-images.githubusercontent.com/37941513/222894445-498dbb43-3e00-48d2-93c1-6d6c2394dd7c.png)

![image](https://user-images.githubusercontent.com/37941513/222894528-8d0c9bbc-73f7-4747-a8ad-68320240e7cd.png)
![image](https://user-images.githubusercontent.com/37941513/222894540-dbb73fd2-4935-43f6-b22c-281c05a897a7.png)

![image](https://user-images.githubusercontent.com/37941513/222894557-49a3ad71-79a3-4476-92a6-85c76eedf47e.png)

![image](https://user-images.githubusercontent.com/37941513/222894695-0eb593cc-25da-4c0d-8f33-563d44119a4f.png)

![image](https://user-images.githubusercontent.com/37941513/222894730-720d0cfa-2e68-40fd-bd6a-5a9b84bc3fb5.png)

### 언제 사용하면 좋나?

- 배열처럼 0,1,2,3.. 이렇게 순서대로 저장하기 힘든 경우

  - 학번처럼 숫자가 커서 배열 색인으로 쓰기 힘들 떄

- 데이터 저장 공간이 크고, 배열 중간에 데이터를 삽입 및 삭제를 자주 해야할 경우

문제

![image](https://user-images.githubusercontent.com/37941513/222895628-18e73e7e-d47c-4965-9edd-da7320d7697e.png)
![image](https://user-images.githubusercontent.com/37941513/222895637-fd663faf-ed94-4390-bbfe-f32fd1047e4b.png)

---

### 해시셋

- 딕셔너리와 매우 비슷
- 리스트와 딕셔너리를 쓰는 경우가 거의 90%
- 나머지는 정말 특별한 경우 사용
- 해시셋은 딕셔너리와 매우 비슷
- 차이점은 해시셋은 키만 존재한다.

![image](https://user-images.githubusercontent.com/37941513/222895981-619c28bf-deea-4f1d-b845-36df84f2e4cf.png)
![image](https://user-images.githubusercontent.com/37941513/222896003-e012b955-7b73-4cbe-8ed9-20d63e59887d.png)
![image](https://user-images.githubusercontent.com/37941513/222896017-1dbec505-78bd-42a6-a511-d72e7e0a4d08.png)
![image](https://user-images.githubusercontent.com/37941513/222896033-eaf04c71-14ce-4cf1-8213-88dbda73b66d.png)

![image](https://user-images.githubusercontent.com/37941513/222896055-98ba46b6-5cb3-4c99-ae62-7a6286727caf.png)

### 언제 사용하면 좋나

- 중복 데이터 제거할 경우
  - 수학의 집합.
  - 똑같은 데이터 Add() 하면 아무 일도 일어나지 않으므로

문제

![image](https://user-images.githubusercontent.com/37941513/222896472-26c8e7ef-f1d0-4d9b-b5bc-f0c18a4f68bb.png)
![image](https://user-images.githubusercontent.com/37941513/222896478-65f06a1a-f5b2-401a-b82b-e351239cfcd4.png)

### 컬렉션과 같이 쓰면 좋은 것들

### 컬렉션의 순차적 요소 탐색

![image](https://user-images.githubusercontent.com/37941513/222896657-85c46d82-6193-48e6-a121-37f484215f31.png)

### 어떤 컬렉션이든 순회할 수 있는 방법 - foreach문

![image](https://user-images.githubusercontent.com/37941513/222896704-95b9e25e-3334-44f9-9b63-98c74a26d12d.png)
![image](https://user-images.githubusercontent.com/37941513/222896717-1901fa55-5ab6-454f-9d31-1ff2fef78061.png)
![image](https://user-images.githubusercontent.com/37941513/222896727-4b7ab89c-115f-4348-a8c8-2cc0673e83fb.png)
![image](https://user-images.githubusercontent.com/37941513/222896737-21afc139-681c-4086-8047-177de0c37de9.png)

### foreach문의 한계

1 . 방문하는 요소의 값을 바꿀 수 없다

![image](https://user-images.githubusercontent.com/37941513/222896754-21ee27b1-4543-4ef4-aaee-3704f4ea4e9f.png)

2 . 현재 방문중인 요소의 색인을 알 방법이 없다. - 알려면 별도의 변수를 foreach문 밖에서 선언 후 사용해야 한다.

![image](https://user-images.githubusercontent.com/37941513/222896773-ff92edd7-fa16-49fd-88b7-04c9c916f807.png)

3 . 컬렉션이나 배열을 거꾸로 탐색할 수 없다.

![image](https://user-images.githubusercontent.com/37941513/222896821-1aae4b1a-42d8-4449-b604-09ac806b7dfc.png)

![image](https://user-images.githubusercontent.com/37941513/222897202-b02adfcd-0a02-462b-b1c3-983641b1c633.png)
![image](https://user-images.githubusercontent.com/37941513/222897206-1b1dab1b-4bd8-4b8f-8185-72060c3390d6.png)

---

<br>

### var 키워드

### 딕셔너리 foreach문의 문제점

![image](https://user-images.githubusercontent.com/37941513/222897242-58eb0e9f-afb7-4036-821f-4428d0be47fc.png)

- 길다
- 매번 KeyValuePair<Tkey,Tvalue>를 써야한다.

![image](https://user-images.githubusercontent.com/37941513/222897254-8f61cf18-b98b-4a78-9c87-85d4dd89ccb6.png)

### var 키워드

![image](https://user-images.githubusercontent.com/37941513/222897279-a46b603d-ff05-4aca-a02b-e66bbfb7e21d.png)

- 묵시적 자료형
  - 컴파일러가 알아서 자료형 추론해줌
- 지역변수에서만 사용 가능
- C++은 auto라고 표현
- 긴 자료형을 짧게 줄여줌 -> 짱 편함
- 반드시 선언과 동시에 대입해야 함
  - 안 하면 컴파일 오류

### 코딩 표준 : 자료형이 뭔지 바로 알 수 있을 때만

![image](https://user-images.githubusercontent.com/37941513/222897333-e62e52c5-2d32-4b83-8cba-8c738a876cf1.png)

문제

![image](https://user-images.githubusercontent.com/37941513/222897336-4139bad2-ce88-4215-a5f7-5b6bcc242b4b.png)

![image](https://user-images.githubusercontent.com/37941513/222897349-3fc26098-0f7a-46ac-ae35-9312ab7b8bca.png)

![image](https://user-images.githubusercontent.com/37941513/222897356-207f6cc1-a6a8-40a5-9e84-f275e58e87b3.png)


-----------




## 개체지향 프로그래밍

### 절차적 언어의 아쉬운 점

1 . 데이터의 비 인간화
2 . 데이터가 많아지면 관리가 힘들어짐 -> 실수할 여지가 증가한다.

#### 절차적 언어의 아쉬운 점  - 보완책

- 데이터를 그룹으로 묶는 방법이 존재 => 구조체(struct)라 불림
  - 이 그룹을 마치 하나의 '변수' 처럼 사용
  - 생성과 동시에 그룹 안의 모든 데이터가 초기화

- 기계가 이해하는 데이터 형태는 아님. 컴파일러가 알아서 차례차례 그룹 내의 변수를 선언한다고 생각하면 됨

#### 절차적 언어의 아쉬운 점  - 보완책의 한계

- 여전히 데이터와 동작이 분리
- 어떤 구조체가 어떤 함수와 관련있는 지 찾기 힘듬
  - 함수까지 하나로 묶으면 되지 않나?

### 왜 함수까지 하나로 묶나?

- 사람들은 세상을 물체로 인지(object) => 직관적
- 물체는 상태와 동작이 한 곳에 . 이걸 프로그래밍에서는 객체라고 번역


### 사람을 나타내는 자료형 vs 사람 데이터

- int는 정수를 담는 자료형, age 변수에 넣는 15는 정수형 데이터

- 사람도 마찬가지로 자료형과 데이터가 필요

ex. <  사람을 나타내는 자료형 > human  = 데이터;


### 클래스

- 사람은 내부적으로 여러 데이터를 가지니 그것을 제대로 정의하는 자료형을 만들어야 한다

- 이렇게 커스텀하게 만드는 자료형을 클래스라고 한다.

- 게임에서 전사, 마법사, 성직자와 같은 직업군이라 생각하면 편함
  - 게임에서 직업군에 따라 결정되는 스킬과 스탯이 있다. 
  - 클래스도 마찬가지



### 개체 만들기

< 클래스 이름 > < 변수명 > = new < 클래스 이름 >();

- 새로운 < 클래스 이름 > 형의 데이터를 만든다.
- 클래스로 정의된 형에 맞는 구체적 데이터를 개체라고 한다
- C#에서는 new를 통해서만 만들 수 있다.
- 인스턴스 만들기, 인스턴스 화 한다고도 한다.


<br>

----------


### 생성자


### 좀 더 안전한 OOP

- 지금까지의 내용은?
1 . 사람이 세상을 바라보는 방법과 왜 OOP가 좋은가를 설명
2 . 그리고 이걸 어떻게 코드로 구현하는지에 대한 설명

- 개체 생성 후 깜빡하고 데이터를 대입 안 할 경우 예기치 못한 일이 발생 가능
  - 생성자를 사용하면 해결 가능


### 생성자(constructor)

- 생성자 개체를 생성할(new) 떄 반드시 호출되는 함수
- 함수명으로 클래스명을 씀
- 반환형을 아예 적지 않음
- 생성에 필요한 매개변수를 강제할 수 있음
- 생성자가 여럿이여도 됨.


#### 개체 만들었을 때 문제인 경우(예시)

- 모든 개체가 동일한 값을 가져야 하는 경우가 있음
- 이걸 프로그래머가 제대로 해줄거라고 믿으면 안 됨.(실수 가능)


#### 멤버변수로 다른 클래스형 가지기 가능

- string도 클래스
- Owner는 개체

#### 멤버 변수의 기본 값



- 0
- 단, 참조형은 0에 준하는 null
- 멤버변수일떄만 초기화 생략 가능
  - 지역 변수는 컴파일러 오류

정리하면 


- 생성자는 기본값이 숫자는 0
- 참조형의 기본값은 null



---------

### private 
- 클래스 안에서만 접근 가능
  - 바꿔 말하면 클래스 밖에선 접근 불가  => 컴파일 오류
  - 변수, 함수 모드 private 가능
  - 외부에서 private의 변수를 바꾸려면 public 함수 사용

### 프로퍼티

- 변수와 메서드가 모두 함께 있는 형태
- 프로퍼티는 변수가 아님
- 컴파일러가 알아서 getter와 setter 함수를 만들어 준다고 생각하면 됨
- 멤버 변수를 외부에 노출하지 않고 데이터를 변경하게 해줌
- getter/setter 함수처럼 추가적인 논리 코드도 넣을 수 있음.


------

### 자동으로 구현된 (auto-implemented) 프로퍼티

```
public string  Owner {get; set;}
public float Gas {get; private set;} = 10.0f;
public EGasType GasType {get; private set;}
```

< 접근 제어자 >< 자료형 > < 프로퍼티명 > {( < 접근제어자 >) get; ( < 접근제어자 >) set; } ( = < 데이터 >; )

- 멤버 변수에 단순히 데이터를 대입하거나 반환 할 때만 사용.
  - setter에서 특별한 연산을 해줄 떄는 여전히 수동 프로퍼티를 사용해야 함.

- 컴파일러가 컴파일 시에 멤버 변수를 만들어 줌.
- get과 set에도 접근 제어자를 붙여줄 수 있음.
  - private 이 붙으면 클래스 밖에서 사용할 수 있음.

- 초기화도 가능(선택)

#### 문제

![image](https://user-images.githubusercontent.com/37941513/226168941-9d0927ed-7576-4fcd-bd8a-aaa2c3f1010d.png)

![image](https://user-images.githubusercontent.com/37941513/226177754-9d98eaa1-a26a-4153-a5d7-9e0e068d17dc.png)




--------

### 코딩 표준 : 멤버 작성 순서

1 . public 멤버 변수/ 프로퍼티
2 . private 멤버변수
3 . 생성자
4 . public 멤버 함수
5 . private 멤버 함수
- 단 , 프로퍼티와 대응하는 private 멤버 변수는 프로퍼티 바로 위에 적음.

### 코딩 표쥰 - 프로퍼티 사용

- setter/getter 함수보다는 프로퍼티를 사용

### 코딩 표준 : 멤버변수/ 프로퍼티 이름 짓기

- public 멤버 변수 / 프로퍼티
  - 파스칼 표기법을 따른다

  ```
  public float GasType{get; private set;}
  ```

- private 멤버 변수 
    - 맨 앞에 'm'을 붙인다.
    - 낙타 표기법을 따른다.


```
private float mKillometersTravelled;
```

- 함수의 매개변수, 지역변수
  - 낙타 표기법을 따른다


![image](https://user-images.githubusercontent.com/37941513/226178356-2eb60d40-188c-4ae6-8fac-0b4f058b2419.png)

### 코딩 표준 : 멤버 함수 이름 짓기

![image](https://user-images.githubusercontent.com/37941513/226178435-682197b2-3b73-428a-a233-685900439610.png)


-----


### partial 클래스

- #에서는 Partial이라는 기능을 제공

- 이 Partial은 파일은 다르지만 한 파일에서 작성된 것 처럼 만들어 줌.

- 즉, 클래스를 파일별로 분할에서 작성할 수 있게 도와줌

-------------------


### 정적 클래스

```
static void Main(string[] args){}
```

### static

![image](https://user-images.githubusercontent.com/37941513/226181289-13358876-bab6-467c-9bfe-bde245edaaaf.png)

- 클래스, 멤버변수, 멤버 함수에 사용 가능
- 단, 상수는 묵시적으로는 static이다.

### 정적 멤버 변수

- 개체에 속하지 않고 클래스형에 속한다

- 모든 개체가 하나의 정적 멤버 변수를 공유한다.

![image](https://user-images.githubusercontent.com/37941513/226181824-9a2cd292-e70f-445b-bc5d-bcb965a5c116.png)

- 멤버 함수에서 접근 가능

- public 이면 개체가 없어도 외부에서 접근 가능
  - 정적 함수 볼 때 자세히.


![image](https://user-images.githubusercontent.com/37941513/226181891-46b8b262-2c24-42ff-b332-d9302c1a1420.png)  


### 정적 함수 예

![image](https://user-images.githubusercontent.com/37941513/226181955-1cb93c17-3106-45f3-9c1f-240e2770393a.png)


### 정적 멤버 함수


![image](https://user-images.githubusercontent.com/37941513/226182269-247ff75e-6725-4fe5-aa99-ab5065a22baf.png)

- 개체에 속하지 않고 클래스에 속함
- 정적 멤버 함수는 비정적 멤버 변수에 접근하지 못 함

### 정적 클래스의 예

![image](https://user-images.githubusercontent.com/37941513/226182298-0ea8c758-81c7-4db9-92c5-b18f633cff0a.png)


### 정적 클래스

- 정적 멤버만 가질 수 있음
  - 정적 멤버 변수
  - 정적 멤버 함수

- new로 개체를 생성할 수 없음

- 반드시 멤버 함수에 static을 붙여야 함
  - 안 붙이면 컴파일 오류 발생 -> 실수 방지를 위해서

![image](https://user-images.githubusercontent.com/37941513/226182341-ad313a3a-9af5-459d-962e-0a46c1fa1633.png)



- 개체를 생성하지 않고 정적 클래스 내의 함수를 사용 가능
- 주로 유틸리티 클래스를 만들 떄 사용

![image](https://user-images.githubusercontent.com/37941513/226182809-4772289f-ee78-4b06-99fc-15ab455ac9a3.png)

### 왜 정적 변수, 함수를 사용하는가

![image](https://user-images.githubusercontent.com/37941513/226182836-b873f228-55e7-4f38-a4ea-ead51ff169a0.png)



#### 문제


![image](https://user-images.githubusercontent.com/37941513/226191180-cb2c256c-65f7-446b-ad31-85bb0314bfb5.png)


---------




### 확장 메서드

![image](https://user-images.githubusercontent.com/37941513/226183285-a4321809-60ce-4d66-8551-a9f5c3a6b6d6.png)

### 확장 메서드를 이용한 해결 방법

![image](https://user-images.githubusercontent.com/37941513/226183325-28d87d50-8bfc-456d-935d-65972817403e.png)

### 확장 메서드 만드는 방법

![image](https://user-images.githubusercontent.com/37941513/226183392-010e323b-d250-4e64-8255-4824b34115f9.png)

![image](https://user-images.githubusercontent.com/37941513/226183442-e3020ddf-3e36-4d00-b76c-3ba066cede48.png)


### 확장 메서드

- 클래스에 함수를 추가하지 못 할떄 사용
  - 해당 클래스의 소스 코드가 없을 때(다른 사람의 라이브러리 사용할 때)
  - 추가하려는 함수가 클래스에 필수적이지 않을 때
    - 예제에 나온 문자열의 단어 수 같은 것
    - Linq라이브러리의 ToArray()같은 함수들

- 정적 메서드를 이용해서 해결
- C#에서는 확장 메서드를 사용


------

### 코딩 표준 : 확장 메서드임을 강조한다

![image](https://user-images.githubusercontent.com/37941513/226183952-bf08dc82-19ca-405c-964f-ba4dc854d405.png)

- 확장 메서드를 담는 클래스에 Extension을 접미사로 붙인다.

```
public static class <확장을 원하는 클래스> Extension
StringExtension, CatExtension, MathExtension
```

- 확장 메서드는 다른 파일에
  - 아예 클래스가 다르니 커스텀 데이터형마다 파일 하나 만드는 게 보통

### 베스트 프랙티스 : 확장 메서드

![image](https://user-images.githubusercontent.com/37941513/226183965-77d2a076-0de0-4e7f-821c-21a4e49e5778.png)


- 기본형의 확장 메서드를 만들 때 조심

```
CourseCode courseCode = something.ToCourseCode();
```
  - 비즈니스 로직을 넣어야 한다면 특히 더 안됨
  
```
CourseCode courseCode = something.Parse(something);
```
  - 차라리 정적 메서드를 만들 것

- 클래스형의 확장 메서드는 괜찮음
  - 클래스 자체가 이미 비즈니스 로직을 대표


---------


## 값형 vs 참조형, 구조체 , Nullable

### 값형


![image](https://user-images.githubusercontent.com/37941513/226409347-86c79cec-14ed-49d6-bec0-169b60092ec5.png)


- 기본 데이터형은 모두 값형(value type)이였음
  - int , float, double, decimal, byte등
- 값형이란 뭔가
  - 한 변수를 다른 변수에 대입하면 사본을 만드는 자료형
  - 함수의 매개변수 인자로 전달해도 마찬가지
  - 즉, 다른 변수의 값을 변경해도 원본은 바뀌지 않음.



![image](https://user-images.githubusercontent.com/37941513/226409774-bc017904-f7a0-4569-a8b1-3930683eae25.png)


### 참조형

![image](https://user-images.githubusercontent.com/37941513/226411984-7f96cdbb-6947-4ae1-b3ea-c1108d77809f.png)


예를 들어
- 배열의 배열
- 내부 배열을 다른 변수에 대입한 뒤, 요소를 바꿨는데 원본도 바뀜.


- 이건 배열이 참조형이기 떄문
- C#에서 모든 데이터 형은 값형 또는 참조형

- 값을 복사하지 않고 원본을 공유하는 형태의 자료형
- C#에서 클래스는 모두 참조형
- string도 참조형이였다(클래스이므로)
- enum은 값형(사실상 이름 붙인 정수)

### 참조형과 쓰레기 수집기

- 임시 문자열(쓰레기)은 쓰레기 수집기(GC)의 대상이었음.
- 마찬가지로 참조형도 다 GC의 대상
- 따라서 참조형 임시 데이터를 너무 많이 만들면 GC의 성능 저하가 올 수 있음
- 값형은 GC의 대상이 아님
- 단, 값형은 복사에 따른 비용에 따른 성능 저하가 올 수 있음.

<br>


---------------


### 참조형의 인자 전달

![image](https://user-images.githubusercontent.com/37941513/226415304-9bf488f4-3b37-4e71-af81-a8b48c670cb3.png)




### 참조형의 인자 전달과 ref

- 참조형을 ref 매개변수로 전달해도 제대로 작동

```
public static void SwapFace(ref Human human1, ref Human human2)
{
  Face temp = human1.GetFace();
  human1.SetFace(human2.GetFace());
  human2.SetFace(temp);
}
```

- 하지만 이건 참조형의 참조라 별 의미가 없는 경우가 대부분
- 오히려 쓸데없이 참조를 한번 더 해서 개미 눈꼽만큼의 성능 저하.

![image](https://user-images.githubusercontent.com/37941513/226417694-7bcb51d6-fd88-43b0-8d28-9aeeb39d8736.png)



------------------

### 참조형 vs 값형 매개변수 전달

![image](https://user-images.githubusercontent.com/37941513/226418045-9dac259b-640b-40ce-808a-7c3b8e150a46.png)


### 문제

![image](https://user-images.githubusercontent.com/37941513/226419155-a4c666c0-3728-4c03-9ee3-6de0c483c1ec.png)

![image](https://user-images.githubusercontent.com/37941513/226419227-cb7d63f4-ad65-41d5-aed4-413f6f985b38.png)


![image](https://user-images.githubusercontent.com/37941513/226419335-deb52408-1579-4a66-aa78-55d39d318ebe.png)

![image](https://user-images.githubusercontent.com/37941513/226419392-f8d05632-e1e3-4ac2-ad5e-2bc5168fbb57.png)

![image](https://user-images.githubusercontent.com/37941513/226419462-5671b4bd-6f52-45e9-857d-0786f2ad730e.png)


--------


### 구조체(struct)

![image](https://user-images.githubusercontent.com/37941513/226420991-8ae3d3f1-0aa4-4d53-b664-4d3722d5bff7.png)


- 개념: 기능은 없고 데이터만 있는 클래스
- 그러나 C#의 구조체는 함수도 가질 수 있다.
- 여전히 위 개념상의 이유로 클래스에서 가능한 것들을 못하는 경우가 있다
- 제일 중요한 건 **구조체는 값형**이라는 것
  - 개념상 데이터만 모아놓은 클래스이기 떄문에 당연

![image](https://user-images.githubusercontent.com/37941513/226421344-bd2d331a-7233-4fb0-997c-d9bb2ee58fdc.png)

### 생성자

![image](https://user-images.githubusercontent.com/37941513/226421524-f04967fd-e199-423b-acba-d507d719aad7.png)


### 멤버 변수와 프로퍼티

![image](https://user-images.githubusercontent.com/37941513/226421759-4a15dfed-85a2-4969-8475-794f2e819a23.png)

- 멤버변수와 프로퍼티 모두 선언과 동시에 초기화 불가

- 단, 상수나 정적변수는 초기화 가능

--------

### 구조체 개체 생성

![image](https://user-images.githubusercontent.com/37941513/226421965-8c5bd64c-9f7c-44ea-967f-f5354aac7e5a.png)

```
Vector2 v1 = new Vector2(); // 모든 멤버 변수가 0으로 초기화
Vector2 v2 = new Vector2(30,40);
```

- new 키워드를 사용해서 생성

-------------

### 구조체를 매개변수로 전달하기

![image](https://user-images.githubusercontent.com/37941513/226422627-3d2ac5cd-35ff-4344-b71c-6b8d307271aa.png)

### 클래스와 구조체 모두 자료형

- 클래스와 구조체 모두 자료형이므로 서로 포함 가능

```
public class Human
{
  public Head Head{get;set;} //Head는 구조체
  public Body Body{get;set;} //Body는 클래스
}
```

```
public struct Human
{
  public Head Head{get;set;} //Head는 구조체
  public Body Body{get;set;} //Body는 클래스
}
```


### 클래스 vs 구조체

- 대부분 응용 프로그램에서는 구조체를 잘 안씀
  - 개체를 전달하면서 원본을 바꾸는 것이 보통이므로

- 성능을 요하는 특정 분야에서 쓰는 경우는 있음(ex. 게임)
  - 쓰레기를 만들지 않음

- 원본 대신 언제나 복사본을 전달하고 싶다면 구조체를 쓰기도 함

![image](https://user-images.githubusercontent.com/37941513/226423753-8882e8dd-5940-46bb-bc28-dbfb9329f9d6.png)

**가장 중요한 차이는 구조체는 값형, 클래스는 참조형** 이라는 것.

### 문제

![image](https://user-images.githubusercontent.com/37941513/226423983-4815aad3-1507-4cf6-8cb1-9ac5bea0b992.png)


--------

<br>


### Nullable

#### 클래스 멤버 변수의 기본값


![image](https://user-images.githubusercontent.com/37941513/226619334-ada4c1b3-a3c0-40cf-9415-c544a0b6024a.png)

```
public class Human
{
  public int Age{get; private set;}
  public float Height{get; private set;}
  public Head Head {get; private set;} //Head는 클래스
}
```


### null

- 참조값의 기본값
- 데이터가 존재하지 않음을 의미
  - 아무것도 참조하고 있지 않음
- 없다를 컴퓨터 세계에서 이진수로 0
  - 컴퓨터는 0과 1로만 모든것을 표현하기 떄문


### 값형과 null

![image](https://user-images.githubusercontent.com/37941513/226623025-94f658fb-aa24-498b-b7b5-fd3b8fa90166.png)
- 값형에는 null을 쓸 수 없음
- 참조형에는 0을 쓸 수 없음
- 참조형의 기본값인 null은 메모리에서 보면 이진수 0과 같음
- 값형의 기본값인 0은 이진수로도 0임


### 값형에서 null을 쓰고 싶은 경우

![image](https://user-images.githubusercontent.com/37941513/226624855-6a2d28a9-f825-42c5-9cd9-e237ca53eb96.png)

### Nullable < T >

- T형의 값, 또는 null을 가질 수 있는 구조체
- null도 가질 수 있는 값형을 표현할 때 씀
- 기본값은 null
- 참조형은 T가 될 수 없음

### nullable 변수 선언 및 대입

![image](https://user-images.githubusercontent.com/37941513/226627197-4374ae62-c65f-48a3-aa44-9dcfc6ecc6c2.png)

![image](https://user-images.githubusercontent.com/37941513/226630407-1f9c2dc9-a526-4aba-88fa-50bb9ec0e3b4.png)


### Nullable 변수의 값 비교하기

- T형과 T?형 비교시 단순 == 연산자를 쓰는 게 가능
  - Nullable이 내부적으로 null 검사를 한 뒤 비교해줌

![image](https://user-images.githubusercontent.com/37941513/226632392-2c054e30-2ff8-4684-9120-e78cecb41a67.png)



### 값형에 Nullable 변수 대입하기

- Nullable을 값형에 직접 대입할 수 없음
- 왜? null인경우 예외 발생하므로

**Nullable과 아닌걸 섞어쓰면 은근 복잡해진다**

------------


### 그럼 다 Nullable을 쓰면 되지 않나?

- 왜 List< T > 의 IndexOf()는 굳이 -1을 썼는가
  - -1은 IndexOf()의 색인으로는 유효한 값이 아님
    - 리스트의 색인은 0부터 시작
  - uint였다면 요소를 못 찾는다면 unit. MaxValue 를 반환하기로 약속할 수 있다.


### Nullable 사용 시 당연히 오버헤드가 있다.

- 잘못 쓰면 코드가 복잡해진다
  - Null을 허용하는 코드와 null을 예상치 않는 함수 간에 데이터 교환 할 경우 등

![image](https://user-images.githubusercontent.com/37941513/226647453-38d473ed-8a44-4bfe-9450-fa0801c29e40.png)

### 정말 필요할 떄만 Nullable을 쓰자

#### 예외 상황시 흔히 사용하는 반환값
-   -1
-   unit.MaxValue

---------

### 문제

![image](https://user-images.githubusercontent.com/37941513/226652223-b661a3bb-22a8-4f2d-af2d-56be287e6959.png)


![image](https://user-images.githubusercontent.com/37941513/226652424-795ef51a-dcc3-49d2-9ae4-aaa27a3ae91f.png)


------------

### Linq

- 언어적으로 의미가 있는게 아니라 어떤 데이터를 빠르게 검색하고 주무르고 변환하고 이러기에 편하기에 사용한다.
- 디비 관리자들이 C#에서 데이터베이스 쓰던거 처럼 쓰려고 
- 어쩄건 데이터를 빠르게 처리하고 받고 이러기 위함.


![image](https://user-images.githubusercontent.com/37941513/226657668-03703d62-88d5-4547-be9a-fe6fdb67f060.png)

![image](https://user-images.githubusercontent.com/37941513/226657429-109eaaad-7de9-43e2-99c2-2056b36fdfba.png)


### 위 데이터를 컬렉션에 담으면?

엑셀 테이블과 똑같이 표현 가능

![image](https://user-images.githubusercontent.com/37941513/226658623-c9e9d1d4-ffe1-4b75-b8de-43f32b673bb8.png)


### 쿼리(query)

- 데이터베이스 테이블에서 필요한 데이터만 빠르게 선택(select) 하는 방법이 있는데 그걸 쿼리라 한다
- 엑셀에서 $15보다 비싼 메뉴를 반환한다면

![image](https://user-images.githubusercontent.com/37941513/226659026-f0ca6b33-f867-44ee-a6c2-83db90572a7f.png)

![image](https://user-images.githubusercontent.com/37941513/226659173-53c98546-d83a-46f5-82eb-bd6bee91914a.png)



### 필요한 개체만 뽑아내는 방법
#### 방법1: 반복문

- 컬렉션에서 필요한 개체만 뽑아내는 방법은 당연히 반복문

![image](https://user-images.githubusercontent.com/37941513/226659559-6675d0f0-e0fd-4dba-98a3-8d3142148a1d.png)


![image](https://user-images.githubusercontent.com/37941513/226659677-8fd2dd40-ee0d-4109-a832-d3b13989859f.png)

#### 방법2 : LINQ

![image](https://user-images.githubusercontent.com/37941513/226664376-6e118436-939b-4d16-9572-ca49566f4a3b.png)



### Linq로 완전히 코드와 같게 동작하도록 만들 수 있다.

![image](https://user-images.githubusercontent.com/37941513/226664509-fdc8786e-5c48-46b0-a2cb-8537cfd5c871.png)

![image](https://user-images.githubusercontent.com/37941513/226670037-99307910-9cd6-48ae-87a6-faa99f8c380c.png)


### Linq 함수들 예시
![image](https://user-images.githubusercontent.com/37941513/226670163-774feceb-52d0-436e-85ee-dfc366aa8dc9.png)


### where() 예

![image](https://user-images.githubusercontent.com/37941513/226670408-cd433e75-40fe-4cba-a6f1-5d7829cb9bc9.png)


### 문제

![image](https://user-images.githubusercontent.com/37941513/226672964-5cbac8ab-e5a1-4b93-8524-89195d9b4dfb.png)
![image](https://user-images.githubusercontent.com/37941513/226673070-fa8c5a30-027e-4709-826a-fd62e72067a0.png)



-----

![image](https://user-images.githubusercontent.com/37941513/226670636-da7bd1b5-16b9-4141-931b-eff52f5908ce.png)



### OrderBy() / ThenBy()

![image](https://user-images.githubusercontent.com/37941513/226677789-d4139b2e-2ce3-4a07-a727-86081f23dd98.png)

![image](https://user-images.githubusercontent.com/37941513/226678105-ca258f5d-c3f9-4a55-a7d6-09f34946cef9.png)




![image](https://user-images.githubusercontent.com/37941513/226686635-ee55ffee-6293-4f90-a407-099fe01ec9e8.png)



- 두 함수 모두 오름차순 정렬 후 반환함
- 별도의 정렬 기준 추가하려면 Thenby()를 사용

![image](https://user-images.githubusercontent.com/37941513/226687856-48615989-d407-4e77-926a-d208f572935a.png)

![image](https://user-images.githubusercontent.com/37941513/226688051-b4377168-1aa0-4616-8058-78a0398dc490.png)

![image](https://user-images.githubusercontent.com/37941513/226687963-3cfd4d0f-35a6-495c-ac83-0869e7e592db.png)


### OrderByDescending()과 ThenByDescending()

- 두 함수 모두 내림차순 정렬 후 반환함
- 별도의 정렬 기준 추가하려면 ThenbyDescending()를 사용

#### 섞어 쓰기도 가능


![image](https://user-images.githubusercontent.com/37941513/226690035-12956e3f-b4a2-4c87-a690-74c95c5b5159.png)


### where 과도 같이 쓸 수 있다

![image](https://user-images.githubusercontent.com/37941513/226691082-8143476e-47ce-442d-a8d3-06dff15c16e2.png)


### First()

- 데이터 셋에서 가장 처음 요소 반환.
- 단 비어있으면 예외 발생

![image](https://user-images.githubusercontent.com/37941513/226691294-16b23747-bdfa-49df-8876-8a485ea37b71.png)

![image](https://user-images.githubusercontent.com/37941513/226691294-16b23747-bdfa-49df-8876-8a485ea37b71.png)
![image](https://user-images.githubusercontent.com/37941513/226691391-519e5592-1ebb-48f2-ad8b-1538668735f0.png)

### FirstOfDefault()
![image](https://user-images.githubusercontent.com/37941513/226691954-d67d15e2-fc1d-4897-a6bb-98631dae6cfa.png)

- 조건에 맞는 첫 요소를 못 찾을 경우 기본값을 반환
- 클래스의 기본값은 null

### 문제

![image](https://user-images.githubusercontent.com/37941513/226693029-cc87ab33-e1ee-40df-bc81-a3196b58c82a.png)
![image](https://user-images.githubusercontent.com/37941513/226693057-f5be5edd-c218-4813-84f4-16133743a9e1.png)


--------

### All()

![image](https://user-images.githubusercontent.com/37941513/226693475-5952eb44-8682-48ec-ab33-172948b781e3.png)

![image](https://user-images.githubusercontent.com/37941513/226693560-f58bb5d2-93ba-4b45-9626-8bb73684baba.png)

- 모든 데이터가 특정 조건 만족하는지 평가
  - 그럴 경우 true, 아니면 false 반환

### Any 예

![image](https://user-images.githubusercontent.com/37941513/226693644-82cea497-1f00-494c-b091-d6a6b513fe77.png)
![image](https://user-images.githubusercontent.com/37941513/226693778-628b3f44-61d5-49f6-a8d6-396c2c021fc1.png)


- 데이터 셋에 있는 데이터 중 하나라도 특정 조건 만족하는 지 평가

  - 그럴 경우 true, 아니면 false 반환


--------

### ToList()/ToArray()/ToDictionary()

![image](https://user-images.githubusercontent.com/37941513/226694535-33234dbf-1981-47b6-a71b-84ccb801dd9b.png)


- 현재 쿼리 결과를 리스트, 배열, 딕셔너리로 변환해줌

![image](https://user-images.githubusercontent.com/37941513/226694757-d65ab053-e59d-4747-a73e-1115c5cad6a0.png)

-------

### Select

- 큰 개체 하나에서 몇개 멤버만 빼서 새로운 개체를 만드는 것

![image](https://user-images.githubusercontent.com/37941513/226694757-d65ab053-e59d-4747-a73e-1115c5cad6a0.png)

![image](https://user-images.githubusercontent.com/37941513/226694859-5a7ada5f-a4fa-4324-aeab-39e3838b4b43.png)


--------

### Linq 사용시 주의점1 : 내부를 이해할 것
- Linq는 매우 유용한 함수를 제공
- 대신 내부를 제대로 이해하는 것이 중요하다

![image](https://user-images.githubusercontent.com/37941513/226889456-c6c9411b-3c93-4faa-b6ec-b418992a7458.png)

### Where ()는 내부적으로 for문이 돈다.

![image](https://user-images.githubusercontent.com/37941513/226889577-7a7624b4-bcf6-4105-8920-20c21cb9aeea.png)




![image](https://user-images.githubusercontent.com/37941513/226890055-992a3fa4-d5c7-46ef-8d6a-2466607a2fbd.png)


![image](https://user-images.githubusercontent.com/37941513/226890252-9c3f8a87-c837-4d47-9df1-66cb2e4b9919.png)



![image](https://user-images.githubusercontent.com/37941513/226890347-73463453-08be-4b0a-9970-b8ae8a97af0e.png)



------------


### 파일 입출력, 예외 처리, 파일 스트림

### 파일이 필요한 이유

- 여태껏 만든 프로그램은 종료시 모든 데이터가 날아감
- 변수는 프로그램 실행 중 임시적으로 데이터를 저장하는 공간
- 나중에 프로그램을 다시 실행해도 원 상태로 복구되려면 어딘가에 저장해야 한다
  - 워드 작업 중 갑자기 꺼지면 데이터가 다 날아감
  - 요새 웹 브라우저는 이전 탭들이 다 열림
    - 어딘가에 저장해두기 떄문
- 파일은 이런 영구 저장소 중 하나.

![image](https://user-images.githubusercontent.com/37941513/228011215-224fcda2-ffde-4f61-a8a4-15c587372631.png)


### 텍스트 파일 저장하기


![image](https://user-images.githubusercontent.com/37941513/228313651-d805fe4a-9840-4f86-b3df-052e303f356c.png)

```
File.WriteAllLines(@"C:\CSharpExamples\13\students.txt",names);

File.WriteAllText(@"C:\CSharpExamples\13\students.txt",message);
```

- filePath에 여러줄의 문자열을 쓰고 파일을 닫음

```
File.WriteAllLines(string filePath, string [] lines);
```
- filePath에 한 줄의 문자열을 쓰고 파일을 닫음

```
File.WriteAllText(string filePath, string text);
```
- 파일에 문자열을 쓰는 가장 쉬운 법
- 이미 파일이 존재한다면 덮어씀

-----------

### 텍스트 파일에 덧붙이기

![image](https://user-images.githubusercontent.com/37941513/228316010-00048d4c-812d-4dcc-a2c6-a975e06ff530.png)

```
//파일 상단
using System.IO;

//메인함수 어딘가
string[] names= {"Leon Kim", "Lulu Park", "Teemo Lee"};
File.AppendAllLines(@"C:\CSharpExamples\13\students.txt",names);

string message = "C# is the best programming lang for begginers";
File.AppendAllText(@"C:\CSharpExamples\13\students.txt",message);
```

### 텍스트 파일 읽어오기 예시

![image](https://user-images.githubusercontent.com/37941513/228317425-beecc4bd-97db-4a57-af12-739024710807.png)

```
string [] lines = File.ReadAllLines(@"C:\CSharpExample\13\students.txt");
foreach(var line in lines)
{
  Console.WriteLine(line);
}
string text = File.ReadAllText(@"C:\CSharpExample\13\students.txt");

Console.WriteLine(text);
```

### 텍스트 파일 읽어오기

![image](https://user-images.githubusercontent.com/37941513/228317823-230bdd17-3f83-42f4-a09f-83582ee1f9b4.png)


```
string [] lines = File.ReadAllLines(string filePath);
```
filePath를 열어 모든 줄의 문자열을 읽어 string[]으로 반환 후, 파일을 닫음


```
string text = File.ReadAllText(string filePath);
```
filePath를 열어 모든 문자열을 읽어 string으로 반환 후, 파일을 닫음

- 파일을 읽어오는 가장 쉬운 방법
- 전에 CSV 데이터를 읽어와서 토큰화 할 때도 이 방법 사용

--------

### 이진 파일 저장 및 읽기 예


![image](https://user-images.githubusercontent.com/37941513/228323714-3e393e1d-0275-4e49-bbab-9d66eb514974.png)

```
byte [] bytes1 = new byte[3] {12,65,3};
File.WriteAllBytes(@"C:\CSharpExamples\13\binaryFile.txt",bytes1);


byte [] bytes2 = 
File.ReadAllBytes(@"C:\CSharpExamples\13\binaryFile.txt");
for(int i =0; i<bytes2.Lenth;++i)
{
  Console.WriteLine(bytes2[i]);
}
```

3과 12는 왜 파일 안에서 안 보이나?


### 이진 파일 vs 텍스트 파일

![image](https://user-images.githubusercontent.com/37941513/228324105-07941ef9-f06f-4a50-9df7-b4a6bc7a01f8.png)

### 이진 파일 확인하는 법
- 이진 파일이 제대로 저장되었는지 확인하려면 일반 텍스트 편집기가 아니라 16진수 편집기를 써야한다.

![image](https://user-images.githubusercontent.com/37941513/228599332-2c03a821-78f8-4216-a393-dfe6d516123a.png)


### 간단한 이진 파일 저장 및 읽기

![image](https://user-images.githubusercontent.com/37941513/228601320-6fbc6ad7-674f-4493-ab5b-48be6881bcfc.png)

![image](https://user-images.githubusercontent.com/37941513/228601371-f4f30b06-b9aa-4459-a314-1505e450d382.png)


- 이런건 BinaryReader와 BinaryWriter에서 사용

---------


### 파일 존재 여부를 미리 판단하기 예

```
string path = @"c:\unknown.txt";
string[] lines;
if(File.Exist(path)){
  lines = File.ReadAllLines(path)
}
```

---------------

### 예외

- 특별한 처리를 요구하는 비정상적 혹은 예외적인 조건
- 이것을 제대로 처리하지 않으면 정상적인 프로그램 실행순서가 망가짐
- 선형적이였떤 프로그래밍 실행순서에 나타난 복병

### 예외적인 조건

- 충분히 예측 가능
- 그러나 프로그래머가 미리 완벽히 방지할 수 없는 것
- 방지는 못하나 예외적인 조건이 발생할 떄 대응하는 것은 가능

### try / catch

- try 블록 안에 있는 코드를 순서대로 실행하려고 시도
- 아무 문제 없이 try 블록의 마지막 줄 까지 실행하면 계속 코드 실행(catch 블록 건너뜀)
- 만일 예외 발생시 아직 실행되지 않은 try블록 안의 모든 코드를 건너뜀(catch 블록은 건너뜀)
  - 발생한 예외를 처리하는 catch 블록이 있다면 그 안에서 문제 해결
  - 없다면 그 예외는 호출자에게 던져 짐(throw)

![image](https://user-images.githubusercontent.com/37941513/228897710-e5bf452f-3a9a-4340-8419-e3228c8b4ac2.png)


### catch 블록은 여러개가 있을 수 있다.
![image](https://user-images.githubusercontent.com/37941513/228898899-3283cc57-fe51-4627-ac36-1a2d8cffd1c6.png)

- 위에 있는 catch 블록부터 평가함

### Exception 클래스

![image](https://user-images.githubusercontent.com/37941513/228899580-11c379ae-cfbf-4e77-8cab-654cfe4eba9f.png)

### 발생한 예외의 내용은 message 프로퍼티에서 담아서 설명해줌

![image](https://user-images.githubusercontent.com/37941513/228899905-778f7d91-3c23-41f9-8959-db180da4953e.png)

- 멤버변수 
- 현재 예외가 왜 발생했는 지 설명

### StackTrace 프로퍼티

![image](https://user-images.githubusercontent.com/37941513/228901260-e470a1c5-6723-49c1-93c3-11a35d4764d6.png)

- 현재 발생한 예외의 호출 스택을 보여줌
  - 어느 함수에서 익셉션 난지 보여줌.(트리구조)
  - 호출 스택 : 현재 실행중인 함수의 호출 정보를 기록한 자료구조
  - 비쥬얼 스튜디오에서 디버깅 시 확인 가능

- Console.Error는 에러 스트림에 있는 내용

### Message와 StackTrace의 예

![image](https://user-images.githubusercontent.com/37941513/228901552-0d629fff-b343-4b70-8c9a-71281b63b1e1.png)


### 파일에 두번 쓴다.
![image](https://user-images.githubusercontent.com/37941513/228904777-6917ceb1-11ce-4e46-9f36-c759c2d5f04b.png)

### 예외가 발생한 이유

![image](https://user-images.githubusercontent.com/37941513/228904907-5b15eded-1323-41a9-a828-1c8b4adcfa1f.png)

### catch 블록에 없는 예외가 발생하면?
![image](https://user-images.githubusercontent.com/37941513/228904998-1c004918-928f-4579-a1ba-01263a7afcee.png)

- 아래까지 실행은 가나 어떤 일이 일어날 지는 모름

### finally 블록

- 예외가 발생하든 안하든 언제나 최종적으로 실행되는 코드 블록
- catch 되지 않은 예외가 있어도 실행된다.
- 보통 시스템 리소스들을 해제(release) 해줄 때 많이 씀
  - 시스템 리소스들은 GC가 치워주지 못함
  - 직접 해제해주지 않으면 메모리 누수라는 문제 발생
  - 파일 핸들이 열려있기도 하다.


### 수정한 파일에 두번 씀

![image](https://user-images.githubusercontent.com/37941513/228906342-9a1c95af-d199-4fcd-bc62-9b1382fa14d2.png)

### 문제


![image](https://user-images.githubusercontent.com/37941513/228906425-835aff0c-b14e-4672-b9a4-f56cb5f1357f.png)


---------

### 커스텀 예외


![image](https://user-images.githubusercontent.com/37941513/229123024-7ed44590-4add-49e5-8e08-37d6278ce278.png)

### 커스텀 예외 클래스 만드는 법

![image](https://user-images.githubusercontent.com/37941513/229124653-6f99a582-eadb-401c-9c23-74d7b25e7ef9.png)

### catch블록에서 받은 예외를 다시 던질 수 있나?
- 가능은 하나 추천은 하지 않는다.

![image](https://user-images.githubusercontent.com/37941513/229216534-e51a6809-90aa-4038-a9fd-867435794a19.png)

그러나 이런식으로 예외 작성하면 절대 안됨.

### throws e 의 문제점

- 호출스택을 초기화 함
- 오류가 발생한 위치가 어디인지 알 수 없어짐
- 올바른 방법

```
catch(ArgumentNullException e){
  throw;
}
```

------

### 호출 스택의 차이

![image](https://user-images.githubusercontent.com/37941513/229219458-9235335d-35d8-40ab-90bf-8b4d9528b98f.png)

### 올바른 예외 다시 던지기

![image](https://user-images.githubusercontent.com/37941513/229219673-5415aa54-0ebe-41cd-9252-06197268c4bb.png)

### 근데 예외를 다시 던지는 게 좋은건가?
- 좋은 방법이 아니다.
- 다른 사람에게 폭탄을 던지는 것과 같은 행위

**올바른 예외 처리방법은 무엇인가?**


## 올바른 예외처리 방법

### 예외처리는 훌륭하다?

![image](https://user-images.githubusercontent.com/37941513/229220722-e5c6835c-0eaa-4169-8ae2-bc05b98cc660.png)

### 예외처리는 훌륭하다?
- 예외처리개념이 소개된 건 매우 오래전
- 열심히 쓴건 지난 20년 정도
  - java의 성장
  - 프로그램의 안정성을 높여준다는 믿고싶었던 약속
- 그러나 여전히 같은 불만과 피드백
  - 이유가 뭐든 사람이 쉽게 이해 못함
  - 따라서 실수도 많이 저지를 수 밖에 없음

- 예외가 실제 프로그램의 안정성을 높였다는 통계 및 연구 결과 없음
- 오히려 그 반대 연구결과가 존재

### 예외처리와 선 조건

- 모든 예외 상황에 예외를 던지라는 말 하는 사람도 있따.
- 하지만 많은 경우 함수의 선조건에 의해 처리 가능
  - 잘못된 입력값을 절대 함수에 전달하지 말 것
  - 잘못된 입력값이 전달되는 코드를 작성하면 Assert()로 처리할 것
  - 혹시라도 못 잡으면 배포버전 실행중에 오작동 가능


### 함수의 선조건에 의해 처리 안 되는 경우

- 프로그래머가 함수에 어떤 입력값이 들어올 지 컨트롤 할 수 없을 떄

1 . 유저가 프로그램 실행 중 직접 입력하는 값
2 . 외부에서 유입되는 데이터(예: 웹 요청)
3 . 소스코드가 없는 외부 라이브러리를 이용하는 경우
4 . 내 코드가 라이브러리로 판매되는 경우

### 입력값 검증(input validation)

- 유저 입력을 그대로 내부 함수에 전달하지 말 것
- 그 전에 유저 입력값이 유효한 지 검증

1 . TryParse()와 같은 함수 사용
2 . 유효하지 않다면 곧바로 유저에게 오류 메시지 보여줄 것
3 . 유효한 경우에만 내부 함수로 전달

![image](https://user-images.githubusercontent.com/37941513/229229946-76ea068c-3668-4b25-8ef2-76baa9a75373.png)

- 입력값의 완벽한 유효성 판단이 어려운 경우 내부함수가 확인 후 bool 또는 오류코드 반환 

  - 좋은 예: TrySomething() 함수
  ```
  static bool TryOrder(int id)
  {
    if(//db에 id가 존재하는 지 확인){
      return false;
    }
    return true;
  }
  ```
- 외부에서 들어오는 데이터에도 마찬가지다.


### 예외 vs 오류코드

- 다른 사람이 내 라이브러리를 잘못 호출 시 예외 던지는 것은 괜찮음
- 그 대신 오류코드 또는 오류 개체를 반환하는 것도 가능

  - bool TrySomething(out int result)함수
  - EError TrySomething(out int result)함수
  - Result< int > DoSomething(out int result)함수
    - Result에는 int결과와 오류코드를 나타내는 열거형이 들어가 있다.

### 예외는 경계에서 바로 처리한다

- 앞의 입력값 검증도 이 원칙을 따르는 것
- 다른 라이브러리 호출 시 예외가 나올 경우
  - 이 예외를 처리 안하고 호출자에게 넘기면 제대로 처리하나?
  - 호출자가 자기가 처리해야 하는 건 알까?
  - 제대로 처리할 수 있는가?

*** 차라리 내가 제어하는 코드와 남의 코드의 경계에서 처리하는게 맞다 ***

![image](https://user-images.githubusercontent.com/37941513/229233808-1e57e3f2-9263-4451-b3c2-55bfd1ff2415.png)


### 문제

![image](https://user-images.githubusercontent.com/37941513/229233902-11f0c2d9-c3ec-4e8f-92b2-d0e7a860e5f0.png)

-------


### 파일 스트림

### 기존 파일 입출력 방법의 문제

```
string[] line = File.ReadAllline(@"C:\CSharpExamples\13\students.txt);
byte[] bytes = File.ReadAllline(@"C:\CSharpExamples\13\binaryFile.txt);
```

- 파일 컨텐츠를 전부 메모리로 읽어온다
- 파일 용량이 엄청 크면?(ex. 10GB)
  - 메모리에 부담
  - 한 번씩 조금씩 읽어서 처리하는게 낫다
  - 이 파일의 일부분만 읽고 싶으면 그 읽을 위치로 점프 한 뒤 그 부분만 읽는게 좋음
  - 이런 걸 할 수 있는 게 파일 스트림

### 스트림이란(stream)

- 데이터의 입력이나 출력을 줄줄이 순서대로 한다고 해서
- 예: 네트워크 패킷
  - 한번에 오지 않고 주르륵 옪다
- 예 : 웹브라우저에서 이미지 뜰 떄 한번에 뜨지 않고 줄줄이 뜨는 경우

- 파일도 그렇게 볼 수 있다.(파일 스트림)
- 메모리에 저장된 데이터도 그렇게 볼 수 있다.(메모리 스트림)
- 스트림에 따라 원하는 위치로 읽기 쓰기 위치를 건너 뛸 수도 있음

### 파일 스트림 읽기 예

![image](https://user-images.githubusercontent.com/37941513/229260843-e482f04c-7612-463e-82b8-0fc5d0c9611b.png)


### File.Open()

```
FileStream fs = File.Open(path, FileMode.Open)
FileStream fs = File.Open(string path, FileMode mode);
```


- File.Open() 은 파일 모드에 따라 파일을 연뒤 FileStream을 반환

### 사용 가능한 FileMode

![image](https://user-images.githubusercontent.com/37941513/229261461-50dffa90-b375-4c93-9494-ca1d5ade5496.png)

### FileStream 프로퍼티

![image](https://user-images.githubusercontent.com/37941513/229261558-fb1cb1d0-0f31-4a40-a6e0-2d8499b6afbd.png)

```
FileStream fs = File.Open(path, FileMode.Open)
if(fs.CanRead){}
if(fs.CanWrite){}
if(fs.CanSeek){}

public bool CanSeek{get;}
public bool CanWrite{get;}
public bool CanSeek{get;}
```

- CanRead
  - 스트림이 읽기를 지원하면 true, 아니면 false

- CanWrite
  - 스트림이 읽기를 지원하면 true, 아니면 false
  
- CanSeek
  - 스트림이 읽기를 지원하면 true, 아니면 false


### ReadByte()

```
FileStream fs = File.Open(path, FileMode.Open)
for (int i = 0; i< fs.Length; ++i)
{
  int value = fs.ReadByte();
  Console.Write($"{value}");
}
```
```
public int ReadByte();
```


- 파일로부터 한 바이트 씩 읽어오는 함수
- 파일을 끝까지 읽으면 -1을 반환
  - 그래서 byte가 아닌 int가 반환형
- 파일을 모두 읽으려면 반복문을 돌려야 함

### Read()

```
FileStream fs = File.Open(path, FileMode.Open)
byte[] values = new byte[fs.Length];
int n = fs.Read(values,3,5);
```
```
public int Read(byte[] array, int offset, int count);
```

![image](https://user-images.githubusercontent.com/37941513/229263121-10513a94-5add-440e-9d87-a5784d0f7038.png)

- 스트림에서 count만큼 바이트를 읽어와서 array[ offset ] 으로부터 array[ offset +count -1 ] 에 집어 넣는다.


------

### ReadByte()/ Read()의 문제점

- 바이트 또는 바이트 배열만 읽을 수 있다.
- 즉, 텍스트 파일도, 이진파일도 모두 파이트로 보임

![image](https://user-images.githubusercontent.com/37941513/229263182-9d4976b4-f6b9-465b-9124-1bdd533b935d.png)

- 텍스트 파일일떄는 string으로 저장하거나 읽어오고 싶고, 이진파일일 떄는 long으로 쓰고 싶은데 바이트로 읽어오면 하나하나 변환하라는 의미?
  -> 해결법은 존재

### 파일 스트림 쓰기 예


![image](https://user-images.githubusercontent.com/37941513/229263511-2483a9d9-06fb-463b-a13e-e467f0f54435.png)


### WriteByte()

```
FileStream fs = File.Open(path, FileMode.OpenOrCreate)
fs.WriteByte(0x73);
```
```
public int WriteByte(byte value);
```

- 파일에 한 바이트 씩 쓰는 함수

### Write()

![image](https://user-images.githubusercontent.com/37941513/229264404-1b4a73b2-9b4c-4794-b9d3-9c2aee9f8336.png)


### Seek()

![image](https://user-images.githubusercontent.com/37941513/229264490-960a29a8-2a71-4ea6-9674-e83ca2f1ff14.png)

- 현재 위치를 origin+offset으로 이동시키는 함수


### Close()

```
FileStream fs = File.Open(path, FileMode.OpenOrCreate)
fs.Write(bytes,0,4)
fs.close()
```

```
public void Close();
```

- 현재 열려있는 스트림을 닫는 함수

### Close 호출을 까먹으면?

- 언젠가는 GC가 지울 떄 대신 Close()를 호출해줌
  - 그러나 그게 언제가 되는지는 모른다

- 그 전까지는 파일이 열려있는 곳에 다른 코드가 다시 열려고 하면 오류 날 수도
  - 그러나 까먹기가 너무 쉽다.

***using문 사용하면 해결 가능***

### using 문의 예

![image](https://user-images.githubusercontent.com/37941513/229266844-9514ef1c-80c4-41e3-bf87-8771619f6681.png)


### using 문

- 라이브러리를 사용하는 using문과 다르다(동명)
```
using system //이거 아님
using (FileStream fs = File.Open(path,FileMode.Append))
```
- 시스템 리소스를 사용하는 클래스들은 Dispose() 란 함수를 구현하는 경우가 있다.

- 이 때, using문을 사용하면 그 블록이 끝나는 데서 알아서 Dispose()를 호출해줌. 이건 다시 Close를 호출해준다.

- 아래의 조건이 하나라도 만족하면 무조건 using문을 사용하자
1 . 클래스 헤더에 IDisposable이라는게 있을 경우
2 . 멤버 함수로 Dispose()가 있는 경우

- 이해가 안되면 " 이 블록 안에서만 FileStream fs 사용할 테니 끝나면 알아서 지워줘" 라고 이해하면 된다.

![image](https://user-images.githubusercontent.com/37941513/229267991-6a110340-ef7c-40e4-83d1-52f85a0adf78.png)


### 문자열을 텍스트에 쓰기

![image](https://user-images.githubusercontent.com/37941513/229268246-14bca90d-0589-4436-9d3e-33c0342b8bd8.png)

### StreamWriter

- 텍스트를 스트림에 쉽게 저장할 수 있게 해주는 클래스
- 개체 생성하기

```
var writer = new StreamWriter(File.Open(path, FileMode.OpenOrCreate));
```

```
var < 변수명 > =  new StreamWriter(Stream stream);
```
- File.Open()은 반환값으로 FileStream 개체를 줌
  - 이 개체는 Stream 개체라 볼 수 있음


### StreamWriter - 텍스트 쓰기

```
Writer.Write(message)
Writer.Write(message)
```

```
public void Write(string value);
public void WriteLine(string value);
```


- 파일에 텍스트를 쓰는 함수들


### 파일에서 텍스트 읽기

![image](https://user-images.githubusercontent.com/37941513/229269513-cadf7fa6-e55f-4f05-8a50-72dca41e9ace.png)

### StreamReader

- 스트림에서 텍스트를 쉽게 읽어올 수 있는 클래스
- 개체 생성하기

- File.Open()은 반환값으로 FileStream개체를 줌
  - 이 개체는 Stream개체라 볼 수 있음

### StreamReader - 텍스트 읽기

```
string line = reader.ReadLine(); //한 줄 읽기
string text = reader.ReadtoEnd(); //모든 텍스트 읽기
```

```
public void ReadLine();
public void ReadtoEnd();
```

- 파일에서 텍스트를 읽는 함수들

### 이진 파일 쓰기

![image](https://user-images.githubusercontent.com/37941513/229270033-41b3c54f-4176-4764-b157-1567a2908ed9.png)

### BinaryWriter - 이진 데이터 쓰기

```
writer.Write(3.14);
writer.Write("Hi");
```

- 이진 스트림에 이진 데이터 쓰기
  - 수많은 write() 오버로드 함수가 존재

### 이진 파일 읽기

![image](https://user-images.githubusercontent.com/37941513/229270199-7548ad72-3b27-4ca0-980e-458be70b643b.png)

### BinaryReader - 이진 데이터 읽기

```
writer.Write(3.14);
writer.Write("Hi");
```

- 이진 스트림을 쉽게 읽어올 수 있는 클래스
- 개체 생성하기

```
var reader = new BinaryReader(File.Open(path, FileMode.Open));
```

```
var < 변수명 > =  new BinaryReader(Stream stream);
```

- File.Open()은 반환 값으로 FileStream 개체를 줌
  - 이 개체는 Stream 개체라 볼 수 있음.


### BinaryReader - 이진 데이터 읽기

```
short shortVal = read.ReadInt16();
unit uintVal = read.ReadInt32();
double doubleVal = = read.ReadDouble();
string stringVal = = read.ReadString();
```

- 이진 스트림에 이진 데이터 읽기기
  - 수많은 오버로드 함수가 존재

### 보너스 : 파일 대신 메모리에 저장하고 싶다면


![image](https://user-images.githubusercontent.com/37941513/229270495-4c4997a5-1a77-4d3f-b9e1-c52bd2753552.png)

- StreamReader는 이름부터 FileStreamReader가 아님
- 따라서 파일 스트림 외에 다른 스트림과도 사용 가능
- 대표적인 예가 MemoryStream
  - 파일이 아닌 메모리에 쓰고 그로부터 읽고 싶을 때 사용

![image](https://user-images.githubusercontent.com/37941513/229270705-e8569d03-8a58-483f-9347-9af7df99d44d.png)


### 문제

![image](https://user-images.githubusercontent.com/37941513/229270742-c72e6828-1f86-43f3-bc24-df3d630d9d71.png)

![image](https://user-images.githubusercontent.com/37941513/229270745-b5caf950-4cbf-4cb2-a9ae-da6574942a4a.png)

![image](https://user-images.githubusercontent.com/37941513/229270751-5ae24dc1-fa51-425e-a4d8-d8fde53cef06.png)



-------

## 파일과 디렉터리, 나만의 라이브러리, 직렬화

### 파일

- 파일 입출력에 대해서는 위에 있다
- 파일 내용을 바꾸는게 아닌 파일을 복사하고 지우고 옮기는 일을 다룸
- File 클래스를 사용
  - 정적 클래스
  - 고로 모든 멤버 함수들도 "정적 메서드"

### 왜 정적 함수인가?
- 운영체제에서 파일 시스템은 하나다.
  - 파일 시스템을 개체로 보기가 애매

- 그러나 파일을 열고나면 그건 각각의 개체
  - File.Open() 이 개체를 반환하는 이유

- 파일/디렉터리 등에서 볼 대부분의 함수는 정적 함수.

### File.Exist()

```
if(File.Exists(path)){}//path는 문자열
```

```
public static bool Exist(string path);
```

- 전에는 파일 입출력 했을 때 잠시 봤었다.
- 파일(path)이 있으면 true, 없으면 false 반환
  - 파일 접근 권한이 없어도 false를 반환
  - path가 null이거나, 길이가 0이거나, 올바른 경로가 아니더라도 false
- 특별한 예외를 던지지 않는다.
  - 예외 처리를 최대한 안 하려 만든 함수

### 파일 이동하기 예

![image](https://user-images.githubusercontent.com/37941513/229271029-44885a3d-9e39-463d-9388-ad33cb97e0ac.png)


### File.Move()

```
File.Move(source, destination);//source, destination 모두 문자열
```

```
public static bool Move(string sourceFileName, string destFileName);
```

- 파일을 새로운 위치로 이동
  - 파일 이름을 바꿀수도
- 다양한 예외가 발생할 수 있음

  - IOException
    - 목적지에 같은 이름의 파일이 있는 경우
    - sourceFileName을 찾을 수 없는 경우
  - DirectoryNotFoundException
    - sourceFileName나 desFileName의 경로가 유효하지 않을 경우
    - 그 외도 존재하긴함

### is 키워드

```
if(e is DirectoryNotFoundException){}
```

```
<expr> is <type>
```

- < expr > 이 < type > 형으로 변환 가능하면 true를 반환, 아니면 false를 반환
- 런타임에 형 호환성(type compatibility)를 평가함
- 개체 인스턴스가 특정 자료형인지 확인할 때 사용


---------------

### 파일 이동하기 실패인 경우

![image](https://user-images.githubusercontent.com/37941513/229271266-4db6c5c1-aca0-4714-973b-902a4346e60b.png)

-------


### File.Copy()

![image](https://user-images.githubusercontent.com/37941513/229271607-631d5efc-dd57-4ac5-af0e-31d99599e26f.png)

- 파일을 다른곳에 복사하는 함수. 파일 이름도 바꿀 수 있음
- 와일드카드 문자(*,?)는 지원 안 함
- File.Move()와 정말 비슷함. 복사한 뒤 원본을 지우냐 마냐의 차이일 뿐
  - 단 OS에서 File.Move()가 훨씬 빠른 연산임
  - 예외도 File.Move()에서 나온 것과 같음

### File.Delete()

![image](https://user-images.githubusercontent.com/37941513/229271651-68c4cb7f-e4ae-4dee-afd3-9594deac33c3.png)

- 파일을 삭제하는 함수
- 예외
  - File.Move()에서 나온 것과 거의 같음


### File.Encrpyt()/File.Decrpyt()


![image](https://user-images.githubusercontent.com/37941513/229271578-01633064-c9aa-4fb4-ba25-a35a12b252c7.png)

- 현재 프로그램을 실행하는 계정(account)만 파일을 열 수 있도록 암호화 하는 함수
- Window운영체제 전용 함수
  - 단 Window Home Edition은 지원 안 함

![image](https://user-images.githubusercontent.com/37941513/229271767-83ed0691-e8f6-47a2-bd52-4ec002a7aef6.png)
![image](https://user-images.githubusercontent.com/37941513/229271779-dc7ee0de-458d-4d61-bfc9-4f0f37d52338.png)
![image](https://user-images.githubusercontent.com/37941513/229271787-0889d39b-7955-4dd1-82c4-b70adbccd099.png)
![image](https://user-images.githubusercontent.com/37941513/229271798-d1ed2b0d-d6ec-480d-a2f2-e7ac57cf3fd5.png)
![image](https://user-images.githubusercontent.com/37941513/229271811-c504596b-44a3-4db7-8d8d-bbb85baaf22b.png)



------------


### 디렉토리


- 말 그대로 폴더
- 파일처럼 디렉토리도 만들거나 지울 수 있음
- 디렉토리에는 무엇이 들어있나?
  - 파일
  - 또 다른 하위 디렉토리들(재귀 할떄 언급함)

### Directory.Exist()

![image](https://user-images.githubusercontent.com/37941513/229271954-a3cc7dab-2203-4e81-9480-76af600bd82b.png)


- 주어진 경로가 디렉토리면 true, 아니면 false 반환
- 역시 별다른 예외를 던지지 않는다.
  - File.Exist()와 마찬가지



### Directory.CreateDirectory()

![image](https://user-images.githubusercontent.com/37941513/229272113-d2615d85-024d-4f75-a673-6e522a248022.png)

- 디렉토리를 만든다
- 모든 중간 폴더까지 만듦
- 이미 존재하지 않는 디렉토리를 만들려 하면?
  - 아무런 일도 일어나지 않음


### Directory.Delete()


![image](https://user-images.githubusercontent.com/37941513/229272149-632b7ae1-0677-4800-8406-3bb9e828a3f1.png)


- 디렉토리를 지우는 함수


### Directory.GetDirectories()
![image](https://user-images.githubusercontent.com/37941513/229272195-159fd9ba-548f-4a44-a4dc-fbd39d0446af.png)
![image](https://user-images.githubusercontent.com/37941513/229272212-1a9f7d62-a50a-4ff7-89ca-5a0c80c3b508.png)


### Directory.GetFiles()

![image](https://user-images.githubusercontent.com/37941513/229272249-92ddfa66-4993-4102-a64d-c563c61c51d1.png)
![image](https://user-images.githubusercontent.com/37941513/229272261-8d743eee-2fc6-47b3-afbb-43dc51da2630.png)


### 재귀함수 함수 때 본 의사코드

![image](https://user-images.githubusercontent.com/37941513/229272280-2c69ba14-c86a-4618-bd68-3777cc52830d.png)


### Directory.Copy()

![image](https://user-images.githubusercontent.com/37941513/229272306-f7912f98-de3d-4631-a91d-07c42ad324d6.png)



-----------

### 경로
