---
layout: post
title: "기말고사 대비"
subtitle: "etc"

date: "2023-03-01-17:26:51 +0900"
categories: etc
tags: etc
comments: true
---

## 재귀 함수

### 재귀 함수(recursive function)

- 이미 해결한 작은 문제에 얹어서 더 큰 문제를 해결하는 방법
    - 예) 1에서 5까지의 합을 구하려는거는 뭔가
        - 이미 1~4 더한 결과가 10임을 알고 있음
        - 그러면 여기에 5만 더하면 15가 된다.

- 프로그래밍에서 함수 A가 매개변수만 바꿔 다시 함수A를 호출하는 방법으로 구현

- 호출과정

![image](https://user-images.githubusercontent.com/37941513/222087536-5fa7d368-24c8-4287-8461-9081e1bd1b01.png)

### 재귀 함수의 구성 요소

#### 종료 조건 (ending condition , base case)
- 더 이상 재귀 함수를 호출하지 않고, 값을 반환하는 조건
- 매우 간단히 함수의 반환 값을 찾을 수 있는 경우
- 이것을 없으면, 함수를 무한히 재귀적으로 호출

#### 재귀적 함수 호출
- 종료 조건이 아닌 경우
- 함수의 인자를 바꿔 스스로를 다시 호출
- 이 때, 함수의 인자는 현재 문제보다 작은 문제를 대표해야 함
- 즉, 동일한 동작을 보다 작은 문제에 적용

--------

### 일반적으로는 반복문이 더 쉽다

![image](https://user-images.githubusercontent.com/37941513/222088599-e74b3acd-11aa-4c79-8ce4-7442d2a31ea5.png)


### 반복문을 그냥 쓰면 안되나?

- 사실 모든 재귀함수는 반복문으로 해결 가능
- 그러나 복잡한 문제일 수록 재귀함수가 훨씬 편해진다

    - 이진 검색
    - 트리 구조
    - 퀵 정렬
    - 하노이의 탑
    - 어떤 폴더 아래 있는 모든 파일 목록 구하기


### 재귀함수 예 - 피보나치 수열
- 제 0 항은 0, 제 1항은 1이며, 그 뒤의 모든 항은 앞 두항의 합인 수열. 
- 0 1 1 2 3 5 8 13 21 34 55
- F0=0 , F1=1, F(n)= F(n-1) + F(n-2);


```
using System;
class FiboTest
{
 static long fibo(int value)
 { 
  if (value == 0)
  {
    return 0;
  }
  if (value == 1 || value == 2)
  {
   return 1;
  }
  
  return fibo(value-1) + fibo(value-2);
 }
 static void Main(string[] args)
 {
  if (args.Length < 1)
  {
   Console.WriteLine("인자의 수가 부족합니다...");
   Console.WriteLine("Usage : FiboTst1 Arg1");
   return;
  }
  
  int toValue = Convert.ToInt32(args[0]);
  for(int i=1; i <= toValue; i++)
  {
   Console.Write("{0} ", fibo(i));
  }
 }
}
 
```
#### 호출 과정

![image](https://user-images.githubusercontent.com/37941513/222090899-078af08d-6513-4c8b-9753-21ee5cbf626e.png)


- 함수는 신뢰의 문제
- 재귀 함수는 더 큰 신뢰 요구
- Fibanocci(4) 를 구하려 할때
    - Fibonacci(2), Fibonacci(3) 반드시 올바른 값을 반환한다 믿어야 한다
    - 왜냐면 수학적 귀납법이기 때문
    - 다른말로 Fibonacci(0), Fibonacci(1)은 반드시 1을 반환
    - 그 후의 수는 위 종료 조건에 기초하여 값을 계산할 수 있음.


##### 반복문이 더 쉬운건 수학적 귀납법이 익숙치 않기 때문


### 복잡한 내용의 함수인 경우 재귀문이 더 쉽다

![image](https://user-images.githubusercontent.com/37941513/222102995-c276380c-350b-478d-b0ac-c4c8bce9ca1b.png)




### 재귀적 해결법 = 논리력

- 프로그래머의 논리력을 평가하기 적합
- 매우 큰 문제를 작게 쪼개서 증명할 수 있나
    - 절대 틀릴 수 없는 최소한의 문제를 품
    - 최소한의 문제 해법에 의존하여 그 보다 더 큰 문제를 해결
    - 그 과정을 반복하면 논리적으로 최종 문제까지 해결
- 수학적 귀납법과 매우 밀접

### 수학적 귀납법 예시

![image](https://user-images.githubusercontent.com/37941513/222106056-f368ca7a-3789-4ccd-a980-45bd3df5c216.png)


### 재귀함수의 장점

- 개념적으로 매우 훌륭하다.
- 증명이 가능하다

### 재귀함수의 단점 - 효율성이 떨어진다. 🤔

![image](https://user-images.githubusercontent.com/37941513/222107578-717ea39f-9977-4ebd-9eae-75081e670c46.png)

- 반복문은 그런 문제가 없다.
- 이전 연산 결과를 저장(캐싱) 하기 떄문(캐시에 저장)



![image](https://user-images.githubusercontent.com/37941513/222108733-7e41a282-6824-4f78-bd29-548bdb82b844.png)


### 재귀함수의 단점 - 스택 오버플로우

![image](https://user-images.githubusercontent.com/37941513/222110422-7d3a1d58-8082-4037-8ca3-634d6ca1f48b.png)

- 함수 호출깊이엔 제한 존재


### 언제 써야 하는가

- 캐싱 없이 간단한 반복문으로 작성 가능한 문제는 반복문으로
    - 1부터 N까지 합 구하기

- 그 외에는 재귀함수로 우선 작성
    - 설계가 용이하기 떄문

- 다음의 경우는 반복문으로 코드 리팩토링
    - 함수의 호출 최대 깊이를 확정할 수 없음
    - 또는 성능상 문제 발경
    - 코드 리팩토링 : 코드 실행결과를 유지하며 코드의 구조를 재조정.

##### 재귀함수 실전에서 정말 많이 쓰인데. 다만 이슈가 있을 경우 코드 리팩토링 하는 거


#### 문제

![image](https://user-images.githubusercontent.com/37941513/222112129-7ac02d43-66e2-4e84-998f-041166060ae0.png)

![image](https://user-images.githubusercontent.com/37941513/222112315-ae1e5f9a-45a6-44dc-9f8c-9e06152b2855.png)

-------


### 재귀함수 이용 예시

#### 재귀함수 쓰기전 간단한 가위바위보

![image](https://user-images.githubusercontent.com/37941513/222114055-137f0dd5-dfa9-4462-a538-58f09f806ea2.png)

무조건 플레이어가 이기는 경우. 이런 경우 두 판 이상가면 질림

------


### 랜덤 수 생성 (random number generation)

- 난수 생성이라고도 함
- 언제나 예측 가능했던 컴퓨터였으나 난수 생성이 가능해짐
- 이 덕에 게임이 나옴
- 거의 모든 프로그래밍 언어에 존재하는 개념

![image](https://user-images.githubusercontent.com/37941513/222118662-1a97fad5-5f10-4865-af8e-64c8121cf2c3.png)


### Random 클래스와 개체 생성


![image](https://user-images.githubusercontent.com/37941513/222119006-a32b68e1-8ccf-4219-80ea-89a8a17f7c3d.png)

```
Random random = new Random()
```
- 랜덤 생성기를 만들어 random이라는 변수에 대입
- random은 변수명이므로 다른 단어를 써도 무방

```
Random luck = new Random(); //OK
```

- 클래스 : 여러개의 함수가 뭉쳐있는 집합
- 개체 : 클래스 안에 있는 함수를 사용하려면 필요하다.


#### 난수 생성기


![image](https://user-images.githubusercontent.com/37941513/222119243-3213c648-e2d9-40d7-b8dc-525bf555f40c.png)

```
Random random = new Random () ; //반드시 필요한 코드
int number1 = random.Next(3);
int number2 = random.Next(1,10);
```

<변수명>.Next(<최대값>)
- 0 이상 최대값 미만 수 중 하나를 무작위로 뽑아줌 => [0, 최대값]


<변수명>.Next(<최소값>, <최대값>)
- 최소값 이상 최대값 미만의 수 중 하나를 무작위로 뽑아줌 => [최솟값, 최댓값]

------

### 수정한 가위,바위,보 게임


![image](https://user-images.githubusercontent.com/37941513/222125718-8f248f79-9821-4655-b821-f3fde046d11c.png)


근데 계속 같은 결과가 나온다. 


```
using System;

namespace EMode
{
    class Program
    {
        enum EShape
        {
            Rock = 0,
            Paper = 1,
            Scissor = 2
        };
        static void Main(string[] args)
        {
 //           Random random = new Random();   
            
            Random random = new Random(0);   //매개변수로 0 들어감

            while(true)
            {
                EShape computer = (EShape)random.Next(3);

                Console.WriteLine("Rock Scissor paper");
                EShape user = (EShape)int.Parse(Console.ReadLine());
                if (computer == user)
                {
                    Console.WriteLine($"[Draw]\nYou({user}), Computer({computer})");
                }
                else if ((computer == EShape.Rock && user == EShape.Scissor)
                    || (computer == EShape.Paper && user == EShape.Rock)
                    || (computer == EShape.Scissor && user == EShape.Paper))
                {
                    Console.WriteLine($"[Lose]\nYou({user}), Computer({computer})");
                }
                else if ((computer == EShape.Rock && user == EShape.Paper)
                        || (computer == EShape.Paper && user == EShape.Scissor)
                        || (computer == EShape.Scissor && user == EShape.Rock))
                {
                    Console.WriteLine($"[Win]\nYou({user}), Computer({computer})");
                }
                else
                {
                    Console.WriteLine($"Wrong input!");
                }
            }
        }
    }
}
```
![image](https://user-images.githubusercontent.com/37941513/222128874-605a0676-310a-4e80-ada6-ea24dbc1fe41.png)

- 위 코드로 실행하면 계속해서 실행했을 떄 같은 값이 나온다.
    - 왜?

-----

### 의사 랜덤(pseudo random)

- 대부분 언어에서 지원하는 랜덤은 진정한 랜덤이 아님
    - 진짜 랜덤을 만드는 건 정말 어려운 일
    - 알고리즘의 효율성은 난수의 분포로 결정
- 시드 값을 (seed) 초기 입력값으로 하여 알고리즘을 통해 난수를 만들어내는 함수
- 그 결과는 다시 랜덤 입력값이 됨.
- 이 말은 시드가 같으면 언제나 생성된 난수의 순서가 동일


### 랜덤 함수도 마찬가지

![image](https://user-images.githubusercontent.com/37941513/222172004-058e3ace-d6cd-458f-80ee-29be7f027745.png)


- 랜덤함수는 최초(시드)를 제외하고 본인 스스로가 반환한 값을 다시 입력으로 사용.

#### 그렇기 때문에 시드가 같으면 늘 같은 결과가 나온다

![image](https://user-images.githubusercontent.com/37941513/222176070-db2bd0cc-cf7f-4ca7-9eab-1c76002158d0.png)

#### 위에서는 매번 같은 결과가 나온 것도 시드가 0일 떄의 랜덤 값이 계속 나온 것이다.

![image](https://user-images.githubusercontent.com/37941513/222181231-983ad03d-79f0-4a6d-b791-416635591de4.png)

### new Random()은 괜찮았는데?
- 이런 문제를 해결하기 위해 컴퓨터에 달린 시계를 시드값으로 사용
- new Random()도 내부적으로 그렇다
- 이걸 직접 안 해주는 언어는 시간을 직접 읽어서 시드값으로 넣어준다.


### 그럼 고정된 시드값은 쓸모가 없는가?

- 시드값을 고정시키면 좋은 경우가 있다
- 랜덤 수에 기초한 프로그램 로직에서 문제가 발생한 경우
    - 똑같은 시드값을 넣고 개발자 기계에서 실행하면 그대로 문제 재현

- 네트워크로 연결된 두 사용자가 게임을 할 때
    - 동일한 시드값을 각 컴퓨터에 넣어주고 난수를 동일한 횟수만큼 생성
    - 그러면 난수에 의해 바뀌는 게임 속 로직도 두 컴퓨터에서 동일


#### 숫자 섞기 예제

```
using System;

namespace EMode
{
    class Program
    {
       
        static void Main(string[] args)
        {
            const int SEED = 0; //시드 정의 . 무슨 값이든 올 수 있음. 시드 넣으면 결과값 언제나 똑같이 나온다.
            int[] numbers = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };
            Console.WriteLine($"Before Shuffling");
            Console.WriteLine($"[{string.Join(",",numbers)}]"); //이쁘게 보여주기 위함
            
            //Random random = new Random();
            Random random = new Random(SEED); //시드 넣으면 결과값 언제나 똑같이 나온다.
            
            for (int i = numbers.Length -1; i > 0; i--)     //뒤에서 앞으로 돈다(여태껏 앞에서 뒤로 돌았는데). 이거의 문제는 첫번쨰 숫자는 방문 안함.
                                                            //왜 그런가?(많이들 실수함). 두번쨰 종료조건을 조금만 바꾸면 처음 요소도 방문한다.)

            {
                int j = random.Next(0,i);   //0부터 i까지 난수 생성
                int temp = numbers[j];
                numbers[j] = numbers[i];
                numbers[i] = temp;
            }
            Console.WriteLine($"After Shuffling");
            Console.WriteLine($"[{string.Join(",", numbers)}]");
        }
    }
}
```

- SEED 값을 설정해서 실행 반복할떄마다 같은 결과값이 나온다.

문제

![image](https://user-images.githubusercontent.com/37941513/222185161-66d8a205-d1a2-4cf9-9b9d-b88518006e9d.png)
![image](https://user-images.githubusercontent.com/37941513/222185285-f36b6aa4-8e04-47c4-ad44-d9a7628f29ce.png)


- 재귀함수에서는 프로그래머의 논리를 판단하는 부분
    - 면접관이 질문을 많이 할 수밖에 없다.
    - 왜냐면 큰 문제를 작게 쪼개서 볼 수 있는지 확인하기 위함.
- 실용적인 부분에서는 재귀함수일떄 코드를 보기가 좀 더 쉽다.

- 폴더 탐색같은 경우 계속 뻗어나가는데 그럴떄마다 변수나 기타 로직 만드는 거보다 재귀를 이용해 함수 만들면 좀 더 용이함
- 그러나 함수호출을 여러번 하거나 깊게해서 스택 오버플로우가 날 경우가 있다.
    - 이런 경우는 반복문에 기초해서 변환 해야할 수도 있다.

- 랜덤 수는 게임이나 이런게 들어가고 그걸 재밌게 만들어줌.
