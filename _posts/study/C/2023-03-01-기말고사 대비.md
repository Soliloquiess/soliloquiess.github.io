---
layout: post
title: "기말고사 대비"
subtitle: "etc"

date: "2023-03-01-17:26:51 +0900"
categories: etc
tags: etc
comments: true
---

## 재귀 함수

### 재귀 함수(recursive function)

- 이미 해결한 작은 문제에 얹어서 더 큰 문제를 해결하는 방법

  - 예) 1에서 5까지의 합을 구하려는거는 뭔가
    - 이미 1~4 더한 결과가 10임을 알고 있음
    - 그러면 여기에 5만 더하면 15가 된다.

- 프로그래밍에서 함수 A가 매개변수만 바꿔 다시 함수A를 호출하는 방법으로 구현

- 호출과정

![image](https://user-images.githubusercontent.com/37941513/222087536-5fa7d368-24c8-4287-8461-9081e1bd1b01.png)

### 재귀 함수의 구성 요소

#### 종료 조건 (ending condition , base case)

- 더 이상 재귀 함수를 호출하지 않고, 값을 반환하는 조건
- 매우 간단히 함수의 반환 값을 찾을 수 있는 경우
- 이것을 없으면, 함수를 무한히 재귀적으로 호출

#### 재귀적 함수 호출

- 종료 조건이 아닌 경우
- 함수의 인자를 바꿔 스스로를 다시 호출
- 이 때, 함수의 인자는 현재 문제보다 작은 문제를 대표해야 함
- 즉, 동일한 동작을 보다 작은 문제에 적용

---

### 일반적으로는 반복문이 더 쉽다

![image](https://user-images.githubusercontent.com/37941513/222088599-e74b3acd-11aa-4c79-8ce4-7442d2a31ea5.png)

### 반복문을 그냥 쓰면 안되나?

- 사실 모든 재귀함수는 반복문으로 해결 가능
- 그러나 복잡한 문제일 수록 재귀함수가 훨씬 편해진다

  - 이진 검색
  - 트리 구조
  - 퀵 정렬
  - 하노이의 탑
  - 어떤 폴더 아래 있는 모든 파일 목록 구하기

### 재귀함수 예 - 피보나치 수열

- 제 0 항은 0, 제 1항은 1이며, 그 뒤의 모든 항은 앞 두항의 합인 수열.
- 0 1 1 2 3 5 8 13 21 34 55
- F0=0 , F1=1, F(n)= F(n-1) + F(n-2);

```
using System;
class FiboTest
{
 static long fibo(int value)
 {
  if (value == 0)
  {
    return 0;
  }
  if (value == 1 || value == 2)
  {
   return 1;
  }

  return fibo(value-1) + fibo(value-2);
 }
 static void Main(string[] args)
 {
  if (args.Length < 1)
  {
   Console.WriteLine("인자의 수가 부족합니다...");
   Console.WriteLine("Usage : FiboTst1 Arg1");
   return;
  }

  int toValue = Convert.ToInt32(args[0]);
  for(int i=1; i <= toValue; i++)
  {
   Console.Write("{0} ", fibo(i));
  }
 }
}

```

#### 호출 과정

![image](https://user-images.githubusercontent.com/37941513/222090899-078af08d-6513-4c8b-9753-21ee5cbf626e.png)

- 함수는 신뢰의 문제
- 재귀 함수는 더 큰 신뢰 요구
- Fibanocci(4) 를 구하려 할때
  - Fibonacci(2), Fibonacci(3) 반드시 올바른 값을 반환한다 믿어야 한다
  - 왜냐면 수학적 귀납법이기 때문
  - 다른말로 Fibonacci(0), Fibonacci(1)은 반드시 1을 반환
  - 그 후의 수는 위 종료 조건에 기초하여 값을 계산할 수 있음.

##### 반복문이 더 쉬운건 수학적 귀납법이 익숙치 않기 때문

### 복잡한 내용의 함수인 경우 재귀문이 더 쉽다

![image](https://user-images.githubusercontent.com/37941513/222102995-c276380c-350b-478d-b0ac-c4c8bce9ca1b.png)

### 재귀적 해결법 = 논리력

- 프로그래머의 논리력을 평가하기 적합
- 매우 큰 문제를 작게 쪼개서 증명할 수 있나
  - 절대 틀릴 수 없는 최소한의 문제를 품
  - 최소한의 문제 해법에 의존하여 그 보다 더 큰 문제를 해결
  - 그 과정을 반복하면 논리적으로 최종 문제까지 해결
- 수학적 귀납법과 매우 밀접

### 수학적 귀납법 예시

![image](https://user-images.githubusercontent.com/37941513/222106056-f368ca7a-3789-4ccd-a980-45bd3df5c216.png)

### 재귀함수의 장점

- 개념적으로 매우 훌륭하다.
- 증명이 가능하다

### 재귀함수의 단점 - 효율성이 떨어진다. 🤔

![image](https://user-images.githubusercontent.com/37941513/222107578-717ea39f-9977-4ebd-9eae-75081e670c46.png)

- 반복문은 그런 문제가 없다.
- 이전 연산 결과를 저장(캐싱) 하기 떄문(캐시에 저장)

![image](https://user-images.githubusercontent.com/37941513/222108733-7e41a282-6824-4f78-bd29-548bdb82b844.png)

### 재귀함수의 단점 - 스택 오버플로우

![image](https://user-images.githubusercontent.com/37941513/222110422-7d3a1d58-8082-4037-8ca3-634d6ca1f48b.png)

- 함수 호출깊이엔 제한 존재

### 언제 써야 하는가

- 캐싱 없이 간단한 반복문으로 작성 가능한 문제는 반복문으로

  - 1부터 N까지 합 구하기

- 그 외에는 재귀함수로 우선 작성

  - 설계가 용이하기 떄문

- 다음의 경우는 반복문으로 코드 리팩토링
  - 함수의 호출 최대 깊이를 확정할 수 없음
  - 또는 성능상 문제 발경
  - 코드 리팩토링 : 코드 실행결과를 유지하며 코드의 구조를 재조정.

##### 재귀함수 실전에서 정말 많이 쓰인데. 다만 이슈가 있을 경우 코드 리팩토링 하는 거

#### 문제

![image](https://user-images.githubusercontent.com/37941513/222112129-7ac02d43-66e2-4e84-998f-041166060ae0.png)

![image](https://user-images.githubusercontent.com/37941513/222112315-ae1e5f9a-45a6-44dc-9f8c-9e06152b2855.png)

---

### 재귀함수 이용 예시

#### 재귀함수 쓰기전 간단한 가위바위보

![image](https://user-images.githubusercontent.com/37941513/222114055-137f0dd5-dfa9-4462-a538-58f09f806ea2.png)

무조건 플레이어가 이기는 경우. 이런 경우 두 판 이상가면 질림

---

### 랜덤 수 생성 (random number generation)

- 난수 생성이라고도 함
- 언제나 예측 가능했던 컴퓨터였으나 난수 생성이 가능해짐
- 이 덕에 게임이 나옴
- 거의 모든 프로그래밍 언어에 존재하는 개념

![image](https://user-images.githubusercontent.com/37941513/222118662-1a97fad5-5f10-4865-af8e-64c8121cf2c3.png)

### Random 클래스와 개체 생성

![image](https://user-images.githubusercontent.com/37941513/222119006-a32b68e1-8ccf-4219-80ea-89a8a17f7c3d.png)

```
Random random = new Random()
```

- 랜덤 생성기를 만들어 random이라는 변수에 대입
- random은 변수명이므로 다른 단어를 써도 무방

```
Random luck = new Random(); //OK
```

- 클래스 : 여러개의 함수가 뭉쳐있는 집합
- 개체 : 클래스 안에 있는 함수를 사용하려면 필요하다.

#### 난수 생성기

![image](https://user-images.githubusercontent.com/37941513/222119243-3213c648-e2d9-40d7-b8dc-525bf555f40c.png)

```
Random random = new Random () ; //반드시 필요한 코드
int number1 = random.Next(3);
int number2 = random.Next(1,10);
```

```
<변수명>.Next(<최대값>)
- 0 이상 최대값 미만 수 중 하나를 무작위로 뽑아줌 => [0, 최대값]


<변수명>.Next(<최소값>, <최대값>)
- 최소값 이상 최대값 미만의 수 중 하나를 무작위로 뽑아줌 => [최솟값, 최댓값]
```

---

### 수정한 가위,바위,보 게임

![image](https://user-images.githubusercontent.com/37941513/222125718-8f248f79-9821-4655-b821-f3fde046d11c.png)

근데 계속 같은 결과가 나온다.

```
using System;

namespace EMode
{
    class Program
    {
        enum EShape
        {
            Rock = 0,
            Paper = 1,
            Scissor = 2
        };
        static void Main(string[] args)
        {
 //           Random random = new Random();

            Random random = new Random(0);   //매개변수로 0 들어감

            while(true)
            {
                EShape computer = (EShape)random.Next(3);

                Console.WriteLine("Rock Scissor paper");
                EShape user = (EShape)int.Parse(Console.ReadLine());
                if (computer == user)
                {
                    Console.WriteLine($"[Draw]\nYou({user}), Computer({computer})");
                }
                else if ((computer == EShape.Rock && user == EShape.Scissor)
                    || (computer == EShape.Paper && user == EShape.Rock)
                    || (computer == EShape.Scissor && user == EShape.Paper))
                {
                    Console.WriteLine($"[Lose]\nYou({user}), Computer({computer})");
                }
                else if ((computer == EShape.Rock && user == EShape.Paper)
                        || (computer == EShape.Paper && user == EShape.Scissor)
                        || (computer == EShape.Scissor && user == EShape.Rock))
                {
                    Console.WriteLine($"[Win]\nYou({user}), Computer({computer})");
                }
                else
                {
                    Console.WriteLine($"Wrong input!");
                }
            }
        }
    }
}
```

![image](https://user-images.githubusercontent.com/37941513/222128874-605a0676-310a-4e80-ada6-ea24dbc1fe41.png)

- 위 코드로 실행하면 계속해서 실행했을 떄 같은 값이 나온다.
  - 왜?

---

### 의사 랜덤(pseudo random)

- 대부분 언어에서 지원하는 랜덤은 진정한 랜덤이 아님
  - 진짜 랜덤을 만드는 건 정말 어려운 일
  - 알고리즘의 효율성은 난수의 분포로 결정
- 시드 값을 (seed) 초기 입력값으로 하여 알고리즘을 통해 난수를 만들어내는 함수
- 그 결과는 다시 랜덤 입력값이 됨.
- 이 말은 시드가 같으면 언제나 생성된 난수의 순서가 동일

### 랜덤 함수도 마찬가지

![image](https://user-images.githubusercontent.com/37941513/222172004-058e3ace-d6cd-458f-80ee-29be7f027745.png)

- 랜덤함수는 최초(시드)를 제외하고 본인 스스로가 반환한 값을 다시 입력으로 사용.

#### 그렇기 때문에 시드가 같으면 늘 같은 결과가 나온다

![image](https://user-images.githubusercontent.com/37941513/222176070-db2bd0cc-cf7f-4ca7-9eab-1c76002158d0.png)

#### 위에서는 매번 같은 결과가 나온 것도 시드가 0일 떄의 랜덤 값이 계속 나온 것이다.

![image](https://user-images.githubusercontent.com/37941513/222181231-983ad03d-79f0-4a6d-b791-416635591de4.png)

### new Random()은 괜찮았는데?

- 이런 문제를 해결하기 위해 컴퓨터에 달린 시계를 시드값으로 사용
- new Random()도 내부적으로 그렇다
- 이걸 직접 안 해주는 언어는 시간을 직접 읽어서 시드값으로 넣어준다.

### 그럼 고정된 시드값은 쓸모가 없는가?

- 시드값을 고정시키면 좋은 경우가 있다
- 랜덤 수에 기초한 프로그램 로직에서 문제가 발생한 경우

  - 똑같은 시드값을 넣고 개발자 기계에서 실행하면 그대로 문제 재현

- 네트워크로 연결된 두 사용자가 게임을 할 때
  - 동일한 시드값을 각 컴퓨터에 넣어주고 난수를 동일한 횟수만큼 생성
  - 그러면 난수에 의해 바뀌는 게임 속 로직도 두 컴퓨터에서 동일

#### 숫자 섞기 예제

```
using System;

namespace EMode
{
    class Program
    {

        static void Main(string[] args)
        {
            const int SEED = 0; //시드 정의 . 무슨 값이든 올 수 있음. 시드 넣으면 결과값 언제나 똑같이 나온다.
            int[] numbers = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };
            Console.WriteLine($"Before Shuffling");
            Console.WriteLine($"[{string.Join(",",numbers)}]"); //이쁘게 보여주기 위함

            //Random random = new Random();
            Random random = new Random(SEED); //시드 넣으면 결과값 언제나 똑같이 나온다.

            for (int i = numbers.Length -1; i > 0; i--)     //뒤에서 앞으로 돈다(여태껏 앞에서 뒤로 돌았는데). 이거의 문제는 첫번쨰 숫자는 방문 안함.
                                                            //왜 그런가?(많이들 실수함). 두번쨰 종료조건을 조금만 바꾸면 처음 요소도 방문한다.)

            {
                int j = random.Next(0,i);   //0부터 i까지 난수 생성
                int temp = numbers[j];
                numbers[j] = numbers[i];
                numbers[i] = temp;
            }
            Console.WriteLine($"After Shuffling");
            Console.WriteLine($"[{string.Join(",", numbers)}]");
        }
    }
}
```

- SEED 값을 설정해서 실행 반복할떄마다 같은 결과값이 나온다.

문제

![image](https://user-images.githubusercontent.com/37941513/222185161-66d8a205-d1a2-4cf9-9b9d-b88518006e9d.png)
![image](https://user-images.githubusercontent.com/37941513/222185285-f36b6aa4-8e04-47c4-ad44-d9a7628f29ce.png)

- 재귀함수에서는 프로그래머의 논리를 판단하는 부분
  - 면접관이 질문을 많이 할 수밖에 없다.
  - 왜냐면 큰 문제를 작게 쪼개서 볼 수 있는지 확인하기 위함.
- 실용적인 부분에서는 재귀함수일떄 코드를 보기가 좀 더 쉽다.

- 폴더 탐색같은 경우 계속 뻗어나가는데 그럴떄마다 변수나 기타 로직 만드는 거보다 재귀를 이용해 함수 만들면 좀 더 용이함
- 그러나 함수호출을 여러번 하거나 깊게해서 스택 오버플로우가 날 경우가 있다.

  - 이런 경우는 반복문에 기초해서 변환 해야할 수도 있다.

- 랜덤 수는 게임이나 이런게 들어가고 그걸 재밌게 만들어줌.

---

## 배열 안의 배열

### 2D배열의 문제

- 직사각형의 데이터만 지원 가능
  ![image](https://user-images.githubusercontent.com/37941513/222440393-85946d36-c9c9-4d93-b7bd-303342ecc8b2.png)

- 하지만 각 행마다 열 수가 달라져야 한다면?
- 1D 배열에는 없는 문제
  - 행이 한개이므로 원하는 열의 개수를 적용 가능

### 해결 방법 - 배열 안의 배열

- 바깥 배열(다른 배열을 포함하는 배열)
  - 1D 배열
  - 각 요소형은 다시 1D 배열(안 쪽 배열)
- 안 쪽 배열
  - 1D 배열
  - 각 요소의 형은 실제 자료형

### 바깥 배열을 만드는 법

![image](https://user-images.githubusercontent.com/37941513/222446742-71aee473-a3b5-4848-8aff-083c5a846d55.png)

![image](https://user-images.githubusercontent.com/37941513/222447494-e54314a1-d9b0-4c3f-b727-d85b3e9edaa3.png)

![image](https://user-images.githubusercontent.com/37941513/222449040-73b96bd5-6aa8-406e-bc7a-8dc8b11c06a6.png)

- Null 출력

- 아무것도 없음 : NULL

![image](https://user-images.githubusercontent.com/37941513/222449375-4acf0ae4-cc6a-4261-a67e-919c90497edf.png)

```
String [][] classrooms = new string [CLASS_COUNT][];
```

- CLASS_COUNT 수 만큼 문자열 배열을 담을 공간을 만드는 게 전부다.

### 안 쪽 배열 만들기 예제

![image](https://user-images.githubusercontent.com/37941513/222450347-f49f1535-1cd0-4030-abc6-ad074761716c.png)

### 안 쪽 배열에 접근하는 법

![image](https://user-images.githubusercontent.com/37941513/222452667-00489668-0381-47d7-a3ff-93fa339c8023.png)

![image](https://user-images.githubusercontent.com/37941513/222453445-5bd59a2c-62a6-40ca-847b-0f878be52a49.png)

### 원본이 바뀐다?

- 값에 의한 전달이 아니라 참조에 의한 전달이였던건가?

```
string[] studentNames = classrooms[classIndex];
studentNames[studentIndex] = "Severus";
```

![image](https://user-images.githubusercontent.com/37941513/222454198-ee0cb0fd-96a7-4337-9f65-8f99b20b3a4d.png)

```
using System;

namespace EMode
{
    class Program
    {

        static void Main(string[] args)
        {
            const int CLASS_COUNT = 3;
            int[] STUDENT_COUNT_PER_CLASS = { 3, 2, 5 };
            string[][] classrooms = new string[CLASS_COUNT][];
            for (int i = 0; i<CLASS_COUNT; i++)
            {
                classrooms[i] = new string[STUDENT_COUNT_PER_CLASS[i]];
            }
            int classIndex = 0; //1반
            int studentIndex = 0; //첫번쨰 학생

            string[] studentNames = classrooms[classIndex];
            studentNames[studentIndex] = "Severus";

            Console.WriteLine($"Class 1 - Student 1: {classrooms[classIndex][studentIndex]}");
        }
    }
}
```

![image](https://user-images.githubusercontent.com/37941513/222455096-98bbd659-094c-4f72-98f9-84575f124ee4.png)

결과를 보면 바뀌어 있다.

### 왜?

```
int num1 = 20;
int num2 = num1;
num2 = 10;
```

하면 그대로 20이고 10으로 안 바뀌고 변수 다 그런데 왜 studentNames[0]은 바뀌었나?

일반적인 값들은 다 값에 의한 전달이지만 **new로 만든 것들은 원본이 바뀐다**.

**즉, new로 만든 건 기본적으로 그 데이터 자체가 참조형 데이터다.**

참조형이기 떄문에 이제 원본이 다 바뀐다.

문제

![image](https://user-images.githubusercontent.com/37941513/222458712-08d5c9f9-8301-4c98-b595-d03153a5ef59.png)

![image](https://user-images.githubusercontent.com/37941513/222458627-3409241a-ff4f-43fd-ae5c-ea33defd3d76.png)

### 안쪽 배열을 늘리는 법

```
string[][] classrooms = new string[CLASS_COUNT][];

classrooms[0] = new string[3];
classrooms[1] = new string[2];
classrooms[2] = new string[5];
```

- 안쪽 배열은 여전히 1D배열 -> 추가 인원을 받지 못함

  - 배열의 크기가 2에서 3으로 늘 수 없다는 의미

- 방법은 오직 하나 뿐

  1 . 크기가 3인 배열을 새로 만든다

  2 . for문을 이용해 기존의 배열 데이터를 새 배열로 복사한다.

  3 . 새 배열을 바깥 배열에 대입한다.

### for문으로 배열 복사하기

![image](https://user-images.githubusercontent.com/37941513/222464101-d4fdd7b6-c95f-4838-beb9-74cfc346033e.png)

```
string [][] classrooms = new string[CLASS_COUNT][];
// 학생들 이름을 넣는 코드는 생략
string[] classroom2 = classrooms[1];

string[] newClassroom2 = new string[classroom2.Length+1];
for (int i = 0l i < classroom2.Length ; ++i)
{
    newClassroom2[i] = classroom2[i];
}
newClassroom2[newClassroom2.Length -1] = "Leanne";
classrooms[1] = newClassroom2;
```

### Array.Copy()를 이용한 배열 복사

- for 문 쓰는게 면접 더 나오고 이러지만 실무에선 이렇게 간단하게도 많이 쓴다. 단, 이거만 쓴다고 for문 쓰는 거 까먹었다는 건 말이 안 됨.

![image](https://user-images.githubusercontent.com/37941513/222465606-0ed13000-2203-44d8-8408-e174622456f8.png)

```
string [][] classrooms = new string[CLASS_COUNT][];
// 학생들 이름을 넣는 코드는 생략
string[] classroom2 = classrooms[1];

string[] newClassroom2 = new string[classroom2.Length+1];

Array.Copy(classroom2, newClassroom2, classroom2.Length);
newClassroom2[newClassroom2.Length-1]="leanne";
classrooms[1] = newClassroom2;
```

- classroom2 내용을 newClassroom2으로 복사하는 것(첫 번쨰 요소를 두 번째 요소로 복사)

### Array.Copy()

![image](https://user-images.githubusercontent.com/37941513/222465918-e05b848a-0861-4c20-b833-5304306158a9.png)

### 2D 배열 vs 배열의 배열

![image](https://user-images.githubusercontent.com/37941513/222467014-e62cf27e-267e-4905-8015-77177dcd59a2.png)

#### 사실 배열의 배열은 2차원 배열을 요소로 가질 수 있다.

![image](https://user-images.githubusercontent.com/37941513/222467249-c715330b-6201-4b1d-9ac5-08a3e1cea4a8.png)

문제

![image](https://user-images.githubusercontent.com/37941513/222469306-4c5986a5-e093-4b5e-b0df-16109756cca2.png)

```
using System;

namespace EMode
{
    class Program
    {

        static void Main(string[] args)
        {
            int[] STUDENT_COUNT_PER_CLASS = { 10, 15, 21 };
            int classCount = STUDENT_COUNT_PER_CLASS.Length;
            string[] STUDENT_NAMES = { "john", "Pope", "Bob" };

            string[][] classrooms = new string[classCount][];
            for (int i = 0; i < classCount; ++i)
            {
                classrooms[i] = new string[STUDENT_COUNT_PER_CLASS[i]];
            }

            for (int classIndex = 0; classIndex< classCount; ++classIndex)
            {
                string[] studentNames = classrooms[classIndex];

                for (int studentIndex = 0; studentIndex < studentNames.Length; ++studentIndex)
                {
                    studentNames[studentIndex] = STUDENT_NAMES[studentIndex % 3];
                }
            }
            string[] classroom2 = classrooms[1];
            string[] newClassroom2 = new string[classroom2.Length +1];

            for(int i = 0; i < classroom2.Length; ++i)
            {
                newClassroom2[i] = classroom2[i];
            }
            newClassroom2[newClassroom2.Length -1] = "Leanne";
            classrooms[1] = newClassroom2;
        }
    }
}
```

![image](https://user-images.githubusercontent.com/37941513/222469971-642d5859-1bfe-4261-bb9a-f481032411da.png)
![image](https://user-images.githubusercontent.com/37941513/222470026-d1c3cdc7-bcac-443e-9752-e99fdcb94ae6.png)

![image](https://user-images.githubusercontent.com/37941513/222469714-3b9cafe9-0149-416b-b0ef-a2058d326a22.png)

---

### 배열의 배열 예제

```
using System;

namespace ArrayOfArrays
{
    class Program   //간단한 캘린더 프로그램
    {
        static void Main(string[] args)
        {
            const int MONTHS_IN_A_YEAR = 12;
            int[] daysInEachMonth = new int[MONTHS_IN_A_YEAR] { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

            string[][] calendar = new string[MONTHS_IN_A_YEAR][]; //calendar는 문자열 배열을 포함하는 배열이 될 것

            for (int i = 0; i<MONTHS_IN_A_YEAR; i++)
            {
                calendar[i] = new string[daysInEachMonth[i]];   //바깥 배열의 각 요소를 문자열 배열로 초기화
            }
            while(true)
            {
                Console.Write("Enter the Month (1-12): ");
                string monthString = Console.ReadLine();
                int month = int.Parse(monthString);
                if (0>=month || month >12)
                {
                    Console.WriteLine("Invalid range of month. Terminating program");
                    break;
                }
                Console.WriteLine($"enter the day(1-{calendar[month -1].Length}):"); //날을 입력. 몇월인지에 따라 날짜 범위는 1~28, 1~30, 1~31 중 하나가 됨.
                string dayString = Console.ReadLine();

                int day = int.Parse(dayString);
                if(0>= day || day > calendar[month-1].Length)
                {
                    Console.WriteLine("Invalid range of month. Terminating program");
                    break;
                }
                Console.WriteLine("Enter your schedule:");
                string schedule = Console.ReadLine();

                calendar[month - 1][day - 1] = schedule;
                Console.WriteLine("---------------------");

                for(int i = 0; i<MONTHS_IN_A_YEAR- 1; i++)
                {
                    for (int j = 0; j < calendar[i].Length; j++)
                    {
                        if (!string.IsNullOrEmpty(calendar[i][j]))  //calendar[i][j]가 비어있거나 널이 아니면
                        {
                            Console.WriteLine($"{i + 1}/{j + 1}:{calendar[i][j]}"); //그날의 스케줄 출력
                        }
                    }
                }

                Console.WriteLine("---------------------");
            }
        }
    }
}

```

---

## 문자열 분할

![image](https://user-images.githubusercontent.com/37941513/222711106-e1464398-6847-4f33-b490-9e30a90b4a1e.png)

![image](https://user-images.githubusercontent.com/37941513/222759305-3e1a5d45-3065-4645-a95c-f6d0a94ea75c.png)

![image](https://user-images.githubusercontent.com/37941513/222759364-c433c2e3-4836-48e1-8aaf-93dfef8a0c71.png)

![image](https://user-images.githubusercontent.com/37941513/222759437-adef21f8-9117-4d2b-a621-9fec82b98975.png)

![image](https://user-images.githubusercontent.com/37941513/222759520-7ac82cc1-8270-4c6a-98ab-eaf2b52c985a.png)

![image](https://user-images.githubusercontent.com/37941513/222771931-8fc8ca29-7773-4d0c-8c17-b8ff56c1c126.png)

![image](https://user-images.githubusercontent.com/37941513/222774071-4b9b2bed-0bad-4e22-9e9f-7afe79110747.png)

### 토큰을 읽어오는 법

- 토큰 : 연속된 데이터에서 쪼갤 수 있는 가장 작은 단위
  ![image](https://user-images.githubusercontent.com/37941513/222774398-f75aa7c4-8f6e-4e19-9741-2035773d81db.png)

- 별도의 for문이 필요
- string의 IndexOf(), Substring()등의 함수 또는 첨자 연산자([])를 이용해서 구분 가능

### IndexOf()

![image](https://user-images.githubusercontent.com/37941513/222774522-a3b7ed21-f2b2-4b7b-a7d2-47376dc092e4.png)

```
string nameMessage = "C# is very fun";
int index = message.IndexOf('v'); //6반환
```

- char의 위치를 찾아서 색인을 반환하는 함수

  - 문자가 문자열에 여러번 나타나면 가장 처음에 나타난 곳의 색인 반환
  - 찾는 문자가 문자열에 없다면 -1을 반환

- 다양한 버전의 IndexOf() 함수가 존재함

### Substring()

![image](https://user-images.githubusercontent.com/37941513/222776141-e1960d88-8c19-4b43-81f0-3709074a5830.png)

```
string nameMessage = "name: Pokemon";
string name = nameMessage.Substring(6); //"pokemon"반환
```

- 지정된 문자 위치(색인)에서부터 문자열을 반환하는 함수

- 마찬가지로 다양한 버전의 Substring() 함수가 존재한다.

### 첨자 연산자

![image](https://user-images.githubusercontent.com/37941513/222776585-9f76bfc4-c0c9-422d-89fc-0e6481e82b64.png)

```
string HPMessage = "HP:100";
char ch = HPMessage[4]; //'1';
```

문자열 변수 이름[<색인>];

- <색인>위치에 있는 문자 하나를 반환

### 토큰을 읽어 오는 법

![image](https://user-images.githubusercontent.com/37941513/222781520-d89de93d-bafd-48f6-8d70-bac90973acc0.png)

- 이런 정형화 된 데이터를 쉽게 읽어오는 함수가 존재한다
  - 문자열 토크나이저

### 문자열 토크나이저 - Split()

![image](https://user-images.githubusercontent.com/37941513/222786058-3393e96c-8e51-445b-8520-d3cb3663a754.png)

```
string text = "pokemon,1,10000"
string[] tokens = text.Split(','); //"pokemon","1","10000
```

문자열 변수 이름.Split(char)

- char는 문자열 쪼갤 떄 사용할 구분 문자
- 원본 문자열은 변경없이 그대로 유지
- 쪼갠 문자열을 문자열 배열로 반환
- 여러버전의 Split()가 존재함

### 여러 개의 구분 문자가 문자열에 있는 경우

![image](https://user-images.githubusercontent.com/37941513/222787613-83594893-7e78-4014-af66-01793b113be9.png)

```
string text = "pokemon,1:10000"

char [] delimiters = {',',':'};
string [] tokens = text.Split(delimiters); //{"pokemon","1","10000"}
```

문자열 변수 이름.Split(char[]);

- 문자열 배열 (char[])에 여러개의 구분 문자를 대입

### 구분 문자 사이가 비어있다면

- 문자열을 쪼개면 빈 문자열이 나옴
  ![image](https://user-images.githubusercontent.com/37941513/222789173-0c9042ff-3602-47b3-91a0-f6b1af1781d8.png)

```
string text = "pokemon,1,10000:,10,1000:LopeMon,100,100";

char [] delimiters = {',',':'};
string [] tokens = text.Split(delimiters);
//{"pokemon","1","10000","","10","1000","LopeMon","100","100"}
```

### 구분 문자 사이가 비어있다면 - 해결법

![image](https://user-images.githubusercontent.com/37941513/222790737-b79cf99f-4982-4b89-bac9-5f97a29d4160.png)

- StringSPlitOptions.RemoveEmptyEntries를 사용

```
string text = "pokemon,1,10000:,10,1000:LopeMon,100,100";

char [] delimiters = {',',':'};
string [] tokens = text.Split(delimiters, StringSPlitOptions.RemoveEmptyEntries);
//{"pokemon","1","10000","","10","1000","LopeMon","100","100"}
```

---

### 불필요한 공백 지우기

![image](https://user-images.githubusercontent.com/37941513/222791306-f0e64993-ebba-43e1-b116-96acd19be70c.png)

```
string firstName = "    Leon";
string lastName = "Kim      ";
string trimmedFirstName = firstName.Trim(); //"Leon";
string trimmedLastName = lastName.Trim(); //"kim";
```

문자열 변수 이름.Trim()

- 문자열 앞뒤로 있는 공백을 없앤 후 문자열을 반환
- 원본 문자열은 변경 없이 그대로 유지

### 불필요한 공백 지우기 - TrimStart()

![image](https://user-images.githubusercontent.com/37941513/222794428-6df61233-a0d8-4f4d-b5bc-ec55a5bd0994.png)

### 불필요한 공백 지우기 - TrimEnd()

![image](https://user-images.githubusercontent.com/37941513/222794489-a152b6c3-0445-4108-af63-0323f925769c.png)

### 정리

- 배열의 배열은 2D배열과 다름.
- 배열의 배열은 만약 학교에 반마다 학생이 다른데 이런 경우 사용 가능(그와 비슷하거나)
- 2D배열은 추가시 크기가 고정되서 추가하기 불가능 하나, 단 더 큰 배열 만들고 배열 복사해두고 새로운 거 추가하는 식으로 가능.

- 문자열 분할은 컴퓨터 공학에서 중요하진 않을 수도 있긴 함
- 어떤 특정한 분리문자를 써서 단어들을 뗴온다.
- 이 외 string을 다루다 보니 안에 함수들도 있다. 이런거 알아두자.

---

### 함수 오버로딩

```
static float AverageFromInts(int[] scores)// 함수 바디 생략
static float AverageFloat(float[] floats) //함수 바디 생략
```

- FromInts, FromFloats이 없어도 이미 매개변수 형에서 유추 가능
- 같은 형이 아니면 호출 자체가 불가능
- 동일한 이름 사용 할 수 있을까?

```
static float Average(int[] scores)// 함수 바디 생략
static float Average(float[] floats) //함수 바디 생략
```

- 있다. 이를 함수 오버로딩이라고 부른다.

### 함수 오버로딩

![image](https://user-images.githubusercontent.com/37941513/222871568-76efb0d9-7b81-43c2-9ca4-97de9f99bc14.png)

- 동일한 이름을 가진 함수 구현을 허용하는 기능
- 단, 매개변수의 목록이 달라야 한다
- 함수의 이름 + 매개변수가 함수의 시그니처라 했다.
- 반환형은 일부가 아님.

- 매개변수 목록을 제외하고는 모든게 동일
- 반환형은 상관 없음

![image](https://user-images.githubusercontent.com/37941513/222871987-7d348b9b-03b4-46d6-bae0-44afd24e426b.png)

### 모든 걸 함수 오버로딩으로?

- 잘못된 함수 호출이 일어날 수 있음

```
static string[] GetStudents(float height);
static string[] GetStudents(int age);

int height = 178;
Getstudent(height);
Getstudent(178);
```

- 동일한 매개변수 함수가 없다면, 승격(promotion)/묵시적 형변환을 통해 일치하는 함수를 찾는다.

```
static string[] GetStudents(float height) //함수 바디 생략

//메인 함수
int age = 17;
Getstudent(17);
Getstudent(17);
```

- 따라서 이런 경우 오버로딩을 안 쓰는게 낫다

![image](https://user-images.githubusercontent.com/37941513/222872507-70cf10c6-5740-4f86-830d-4be65188850a.png)

### 코딩 표준 : 함수 오버로딩

1 . 매개변수가 다른 경우 = 오버로딩
2 . 승격/묵시적 변환을 해도 상관 없는 경우 -> 오버로딩

```
static double Sqrt(double num) //함수 바디 생략
static int Sqrt(int num)//함수바디 생략

//메인함수
Sqrt(10.0f); //double형을 호출해도 그닥 문제는 없다.
```

- 실제 C# 의 Math 라이브러리도 float보단 double을 더 많이 지원함
  - float 지원 함수 : Abs(), Clamp(), Max(), Min(), Sign()
  - float 미지원 함수 : Ceiling(), Cos(), Floor(), Log(), Pow(), Round() 등

3 . 매개변수가 아예 승격이 불가능한 경우 -> 오버로딩
(예: string <-> int 혹은 string[] <-> int[])

```
static string[] GetStudent(string name);
static string[] GetStudent(int age);

```

4 . 그런 게 아니라면 함수 오버로딩 보다는 다른 이름을 쓸 것

---

### 기본값 인자

#### 약간만 차이나는 함수라면?

//좋은 예는 아님

```
static string GetFullAddress(string street, string city);
static string GetFullAddress(string street, string city, string state);
```

- 두 코드의 차이는 string state 뿐
- 이 처럼 함수 간 중복된 매개변수가 많을 경우 어떻게 해야하나?

  - 함수를 계속 오버로딩하면?
  - 도시개념이 없는 나라를 고려해야하면?

```
static string GetFullAddress(string street); 를 추가?
```

### 기본값 인자(default parameter)

```
static string GetFullAddress(string street, string city, string state = "")
static float GetHP(int level, int mapID, int difficulty = 0)

//메인함수
GetFullAddress("123 Main street", "Big City", "Big state");
GetFullAddress("456 jido-daero", "Seul"); //OK

GetHP(1,1234,10); //OK
GetHP(1,1234); //OK
GetHP(1,1234,0); //OK

```

- 매개변수 선언시 미리 기본값 설정해 둘 수 있다.
- 하나 이상 가능

```
//컴파일 오류
static string GetHP(int level, int mapID, int difficulty = 0, string name);
//OK
static float GetHP(int level, int mapID, string name int difficulty = 0 );

```

- 매개변수 목록 중간에 기본값 인자가 아닌 것이 오면 안 된다.

---

### 기본값 인자의 문제점 1

- 나중에 누군가 기본값 인자를 중간에 추가할 시 이상한 일이 일어날 수 있다.

```
static float GetHP(int level, int mapID, int difficuilty = 0)

static float GetHP(int level, int mapID, int decimalPoint = 1, int difficuilty = 0)
```

- 기본값 인자가 도중에 변경될 경우 기존 사용 코드에서 문제 발생할 수 있다.

```
static float GetHP(int level, int mapID, int difficuilty = 0)

static float GetHP(int level, int mapID, int difficuilty = 1)
```

### 코드 표준 : 기본 인자값

- 새 기본 매개변수는 언제나 뒤에 둘 것

  - 즉, 중간에 끼우지 말 것

- 기본값은 언제나 0으로 할 것

  - 0이 아니면 기본 매개변수로 하지 말 것

- 함수 오버로딩 대신 실제 함수 이름을 제대로 써주는 게 더 좋을 떄도 있다는 것을 기억할 것

- 매개변수 직접 넣어 줄 것

---

### out 매개변수

#### 나누기 함수 개선

static bool TryDivide(float numerator, float denominator, ref float result)
{
if(denominator == 0.0f)
{
return false;
}
result = numerator / denominator;

    return true;

}

static void Main (string[] args)
{
float result1= 0.0f;
bool bSuccess 1= TryDivide(10.0f, 0.0f, ref result1);
float result2= 0.0f;
bool bSuccess2= TryDivide(10.0f, 5.0f, ref result1);

}

### Out 매개변수

- 함수 안에서 대입 안하면 컴파일 오류

```
//컴파일 오류
static bool TryAdd(float num1, float num2, out float result)
{
    return false;
}
//OK
static bool TryAdd(float num1, float num2, out float result)
{
    result = 0.0f;
    return false;
}

```

### 키보드 입력에서 숫자 이외 값을 넣음

```
int num = int.Parse(Console.ReadLine());
```

- 문제점: 숫자 이외 값을 넣으면 예외 발생
- 해결법 : TryParse();

```
int num;
bool bSuccess = int.TryParse(Console.ReadLine(), out num);
//bSuccess에 따라 코드 작성
```

- TryParse()는 예외처리 없이 예외 상황을 처리할 수 있는 방법
  - int로 변환 시도해서 성공하면 true, 실패시 false
- 함수가 반환형을 두개 가질 수 있다면 이 문제가 없을 수도 있다.

---

## 문자열 빌더

### 문자열 합치기는 느릴 수 있다.

- 임시로 만들고 버리는 문자열이 너무 많기 때문

![image](https://user-images.githubusercontent.com/37941513/222877707-244089b3-d77b-478d-8e6a-90c2129b9b06.png)

```
for (int i = 0; i<=100 ; i++)
{
    ++result;
    message = message + result + " ";
}
```

### 가비지 수집기(garbage collector, GC)

- 새로 만들어진 문자열들은 언젠가 지워져야 함
- C#에서는 그걸 가비지 수집기라는 시스템이 자동으로 해줌
- 다만, 쓰레기 문자열이 넘쳐나면 GC의 성능 저하가 올 수 있음

### 해결법

- 임시 문자열 수를 줄이면 됨
- 그러나 문자열 합치기는 매우 자주하는 연산
- 따라서 최적화 하기위한 라이브러리 존재

**그게 StringBuilder**

### StringBuilder 라이브러리

- 문자열을 효율적으로 만들어주는 라이브러리
- 대략적인 동작 방법

  - 긴 문자열을 담을 수 있는 충분한 공간을 미리 확보
  - 추가되는 문자열들로 그 공간을 차례로 채워나감
  - 모든것이 준비되면 최종적으로 문자열을 만들어서 반환

```
using System;
using System.Text; //문자열 빌더 사용하기 위해 using

namespace StringBuilderExample
{
    class Program   //간단한 캘린더 프로그램
    {
        static void Main(string[] args)
        {
            StringBuilder builder = new StringBuilder(4096);
            builder.AppendLine("Hello Pope");
            builder.AppendLine("Give me");
            builder.Append(2);
            builder.AppendLine("  dollars");

            string greetings = builder.ToString();
            Console.WriteLine(greetings);
        }
    }
}

```

### StringBuilder 생성하기

![image](https://user-images.githubusercontent.com/37941513/222878447-f4ea835d-ebbb-4a50-878c-1650ea234efc.png)

```

using System.Text; //문자열 빌더 사용하기 위해 using
//함수 안에서
StringBuilder builder = new StringBuilder(4096);
```

StringBuilder <변수명> = new StringBuilder(int maxCharCount);

- 총 용량이 maxCharCount 인 StringBuilder 생성
  - string은 내부적으로 char[]와 다르지 않다.
  - 큰 char[]를 확보해 둔다 생각하면 좋다.

### 문자열 추가

![image](https://user-images.githubusercontent.com/37941513/222878544-b584ba23-8e96-4028-bf79-44007c0e6cde.png)

- StringBuilder의 내부 문자열에 문자열을 추가
- 여러 오버로드 함수들 존재

### 문자열 아닌 것도 합치기 가능하다

![image](https://user-images.githubusercontent.com/37941513/222878615-6b45f9a7-6228-4035-aca1-d23bb5814128.png)

- 기존의 문자열 합치기(+ 연산자 ) 처럼 StringBuilder 또한 다양한 자료형을 문자열에 합칠 수 있다.

### 배열의 총 용량과 사용 중인 길이 얻기

![image](https://user-images.githubusercontent.com/37941513/222878750-acfb72b9-9ca9-4ca3-a94e-2dc2e395d921.png)

- 각각 내부 배열의 총 용량과 길이 값을 가지고 있음

- 함수 아님

### 추가 공간 확보

![image](https://user-images.githubusercontent.com/37941513/222879000-174bbfb2-2449-4a1d-891c-95fdff396376.png)

### StringBuilder - 최종 문자열 얻어오기

```
StringBuilder builder = new StringBuilder(4096);
//문자열 추가 코드 생략

string greetings = builder.ToString();
```

![image](https://user-images.githubusercontent.com/37941513/222879083-2c7afcbd-8a9b-4581-bede-0fde6ee94848.png)

### 임시 문자열은 몇개인가

![image](https://user-images.githubusercontent.com/37941513/222879210-22b22a75-7c3f-40c7-b87c-8b200d190f22.png)

### 처음 확보해 둔 공간을 다 쓰면?

- 아무 문제 없다
- 전에 배열의 배열에서 학생을 추가했듯이 StringBuilder가 자동적으로 내부 공간을 늘린 뒤 모든 데이터를 복사

![image](https://user-images.githubusercontent.com/37941513/222879305-76a327ba-52ad-4a65-b662-6db930028dd0.png)

```
StringBuilder builder = new StringBuilder(10);
builder.Append("Hello ");
builder.AppendLine(" human");
```

---

### StringBuilder의 기타함수

- Insert()
- Replace()
- Remove()
- Clear()

### Insert()

```
StringBUilder builder = new StringBuilder(4096);
builder.AppendLine("Hello ");
builder.Insdert(6,"and bye");
```

![image](https://user-images.githubusercontent.com/37941513/222879457-27b969b1-996c-49a6-930a-799d0f5faceb.png)

- StringBUilder의 내부 배열 중간(int index)에 새로운 문자열(string text)를 삽입.
- 여러가지 오버로드 함수 존재
  - Append()와 마찬가지로 다양한 매개변수 형 지원

### Replace()

![image](https://user-images.githubusercontent.com/37941513/222879471-fa95a29e-a2ae-4a82-9ec3-9cc8e8d082cc.png)

### Remove()

![image](https://user-images.githubusercontent.com/37941513/222879503-31966dd9-76a3-49f8-b1ed-2bdc5a36ee2e.png)

### Clear()

![image](https://user-images.githubusercontent.com/37941513/222879547-be41c296-58e3-49bd-832f-35284b0d0a30.png)

- 임시 문자열을 제거하는 함수
- 이 함수를 호출 후 길이 확인하면 0

### StringBuilder vs 문자열 합치기

- 합칠 문자열이 몇개 없다면 StringBuilder를 쓸 이유가 크게 없음
  - 쓰는게 귀찮기도 함
- 대여섯개 합치면 그때부터 StringBuilder를 고려
- 수십개면 당연히 써야한다

---

<br>

## decimal 형

### 부동 소수점의 정밀도 문제

![image](https://user-images.githubusercontent.com/37941513/222880981-9475719d-aaa4-4aa7-8a9e-ed5d14547fa6.png)

- 지수에 따라 소수점이 둥둥 떠다니는 자료형

- 비트 수는 정해져있는데 표현해야 할 숫자가 너무 많다
  - 0부터 0.00000000000001씩 더해 1까지 가는 과정을 정확히 출력 가능한가
    - 불가능. 이미 32개 비트만으로 표현할 수 있는 수의 개수를 넘어감
    - 1을 출력하기 전 많은 수들이 정확하지 않게 출력
  - 정수에 이런 문제가 없는 이유는 사실상 열거형이기 때문
  - 따라서 부동소수점에서 근접한 두 수는 같은 값이 될 수도 있음

**부동소수점형 값은 언제나 근사값이다**

### 은행에서 쓰기 적합한가?

![image](https://user-images.githubusercontent.com/37941513/222881174-f5a593b4-18d4-4825-b2f6-bc6ed7fc0c7d.png)

- 정밀도 때문에 불가능

### 그럼에도 쓰는 이유?

![image](https://user-images.githubusercontent.com/37941513/222881202-3065bf45-5628-4120-a7b6-c02add7d9c01.png)

- 다른 곳에서는 크게 문제 없기 떄문

### 해결책 1: 정수로 변환해서 쓰기

![image](https://user-images.githubusercontent.com/37941513/222881303-835a365c-ceb8-463c-b066-9792e1ac48b3.png)

- 달러의 경우 , 금액에 100 곱함
  - 예: $10.10 + $0.01 = $10.11 ->1010+1=1011
- 화면에 보여줄때는 100으로 나누고 반올림 해서 보여줌
- 더하기 빼기에만 올바른 방법
  - 달러를 곱할 일이 있나?
- 정수가 표현할 수 있는 범위까지만 표현 가능
  - 32비트 정수에서는 문제(0~4,294,967,295)
  - 64비트 정수에서는 크게 문제가 아님(0~9,223,372,036,854,775,807)
  - 단, 소수점 9자리까지 계산해야한다면?

### 해결책 2: 문자열 사용

![image](https://user-images.githubusercontent.com/37941513/222881331-b56cc0ed-e540-4d44-bd2a-844ad55524de.png)

1 . 문자열은 무한의 길이를 가지니 숫자가 아닌 문자열로 저장 - ex ) '10.01' + '0.01'

2 . 그리고 두 숫자를 계산시 문자열에서 각 자리의 문자를 숫자로 바꾼 뒤 한 자리씩 계산

### 해결책 3: decimal 자료형 사용

![image](https://user-images.githubusercontent.com/37941513/222881416-fb42d5f4-8e3c-4f48-8196-dec273140c99.png)

- CPU(기계) 자체에서 지원하는 형은 아님
- 금융권에서 돈 계산에 쓰기 적합
- 일부 언어에도 비슷한 해결책 존재
  - java의 BigDecimal

### decimal 자료형 사용하기

![image](https://user-images.githubusercontent.com/37941513/222881464-9cc0731a-4f93-48ac-b08d-3f637f51c926.png)

- 접미사 'm' 사용

  - 정수일 때는 안 붙여도 됨(묵시적 변환 허용, 단, 그 반대는 안 됨)
  - 부동소수점일 시, 반드시 붙여야 함

### decimal 자료형과 다른 자료형간의 변환

![image](https://user-images.githubusercontent.com/37941513/222881509-67ad703a-2c04-42a6-b1d5-9018056f481b.png)

---

<br>

## 컬렉션

### 컬렉션 정의

![image](https://user-images.githubusercontent.com/37941513/222882116-a4c7ac75-b0fc-46f3-bc6d-74be2ac3f3fc.png)

- 동일한 형의 여러 자료를 저장하는 공간
- 자료구조의 일부
- 다른 언어에서는 컨테이너라 부름

### 배열 vs 컬렉션

| 배열                     | 컬렉션                        |
| ------------------------ | ----------------------------- |
| 자료 구조                | 자료 구조                     |
| 요소의 수를 바꿀 수 없음 | 요소의 수를 바꿀 수 있음      |
| 유용한 함수 제공 안함    | 유용한 함수를 기본적으로 제공 |

### 컬렉션 종류

- 단순한 컬렉션 : 길이가 바뀔 수 있는 배열
- 복잡한 컬렉션 : 자유로운 길이 + 다양한 요소 접근 방법

![image](https://user-images.githubusercontent.com/37941513/222882246-bb188613-42f9-41b3-bb0f-21be897e1426.png)

### 가장 많이 쓰는 컬렉션

- List
- Dictionary
- HashSet

그 외에 Stack, Queue, LinkedList 등

멀티 쓰레드 환경에도 안전한 컬렉션들도 있다. - System.Collections.Concurrent 네임스페이스를 볼 것

### 리스트

- 배열과 거의 비슷
- 색인(0부터 n)을 통해 데이터에 접근
- 그러나 배열의 길이(담을 수 있는 최대 요소 수)를 언제든 바꿀 수 있다.

![image](https://user-images.githubusercontent.com/37941513/222882671-830e6e4d-d74e-4892-abe9-ead6111b36a3.png)
![image](https://user-images.githubusercontent.com/37941513/222882683-2b9cd3a1-da5f-4978-91bd-ba267d815bd3.png)
![image](https://user-images.githubusercontent.com/37941513/222882733-0d6229e8-0030-4d2d-8237-9900ed656293.png)
![image](https://user-images.githubusercontent.com/37941513/222882874-b1610673-24fc-43d4-91ba-3de4b68c508e.png)

![image](https://user-images.githubusercontent.com/37941513/222882952-69e8dd80-d5e2-4a85-becf-2a3635227d6c.png)
![image](https://user-images.githubusercontent.com/37941513/222883120-8d799653-d971-4830-9ebe-c23c0c2e3331.png)
![image](https://user-images.githubusercontent.com/37941513/222883178-96fdbc02-1f56-48b2-a0e3-4dca5d90f630.png)
![image](https://user-images.githubusercontent.com/37941513/222883388-cfe63d1b-c720-4251-bfa2-4b7f65c2c9f2.png)
![image](https://user-images.githubusercontent.com/37941513/222883407-0754e2de-96b9-4db2-999d-59111bc8610a.png)
![image](https://user-images.githubusercontent.com/37941513/222883432-7e867c86-2a85-4a37-8417-3a9fb3763a91.png)
![image](https://user-images.githubusercontent.com/37941513/222883453-46687c02-95ff-4071-a006-fd461decb8b6.png)
![image](https://user-images.githubusercontent.com/37941513/222883481-96d3333b-a82d-4814-930c-a99a26fb30ba.png)
![image](https://user-images.githubusercontent.com/37941513/222883511-ae52c696-2169-43d5-9a6b-140a30765f23.png)
![image](https://user-images.githubusercontent.com/37941513/222883522-598ea12d-6f75-4b24-aac1-0e2d7a179d74.png)

- 언제 쓰면 좋나?
  - 배열 사용 하는 곳에는 다 사용하기 좋다.

![image](https://user-images.githubusercontent.com/37941513/222893620-0ef95cbe-80cd-4129-8fee-8efecd04d982.png)

![image](https://user-images.githubusercontent.com/37941513/222893624-a9d88723-7a68-4ae8-a587-95217c8165ec.png)

---

### 딕셔너리

- List < T >와 다른 점은 색인이 0~n이 아니라 임의의 데이터 형

  - 이 임의의 데이터형을 키(key)라고 함
  - 실제 저장되는 값은 값(value)라고 함

- 실제로 사용하는 사전과 비슷하다.

- 배열에서 색인이 동일하면 같은 위치 가르켰듯이 키가 동일하면 같은 값을 가리킨다.

- 따라서 내부 데이터 저장은 배열처럼 연속된 메모리에 할 수 없다. -> 당연히 배열이 더 효율적

- 다른 언어에서는 딕셔너리 대신 맵이라 한다.

![image](https://user-images.githubusercontent.com/37941513/222894224-cac1bb17-544e-4a51-8125-1f84d5da66ec.png)

![image](https://user-images.githubusercontent.com/37941513/222894416-44af8627-9c08-4820-8dc6-f0efbc9f94ef.png)

![image](https://user-images.githubusercontent.com/37941513/222894436-d02bed61-7086-4598-93d3-8d1a6eb5993d.png)

![image](https://user-images.githubusercontent.com/37941513/222894445-498dbb43-3e00-48d2-93c1-6d6c2394dd7c.png)

![image](https://user-images.githubusercontent.com/37941513/222894528-8d0c9bbc-73f7-4747-a8ad-68320240e7cd.png)
![image](https://user-images.githubusercontent.com/37941513/222894540-dbb73fd2-4935-43f6-b22c-281c05a897a7.png)

![image](https://user-images.githubusercontent.com/37941513/222894557-49a3ad71-79a3-4476-92a6-85c76eedf47e.png)

![image](https://user-images.githubusercontent.com/37941513/222894695-0eb593cc-25da-4c0d-8f33-563d44119a4f.png)

![image](https://user-images.githubusercontent.com/37941513/222894730-720d0cfa-2e68-40fd-bd6a-5a9b84bc3fb5.png)

### 언제 사용하면 좋나?

- 배열처럼 0,1,2,3.. 이렇게 순서대로 저장하기 힘든 경우

  - 학번처럼 숫자가 커서 배열 색인으로 쓰기 힘들 떄

- 데이터 저장 공간이 크고, 배열 중간에 데이터를 삽입 및 삭제를 자주 해야할 경우

문제

![image](https://user-images.githubusercontent.com/37941513/222895628-18e73e7e-d47c-4965-9edd-da7320d7697e.png)
![image](https://user-images.githubusercontent.com/37941513/222895637-fd663faf-ed94-4390-bbfe-f32fd1047e4b.png)

---

### 해시셋

- 딕셔너리와 매우 비슷
- 리스트와 딕셔너리를 쓰는 경우가 거의 90%
- 나머지는 정말 특별한 경우 사용
- 해시셋은 딕셔너리와 매우 비슷
- 차이점은 해시셋은 키만 존재한다.

![image](https://user-images.githubusercontent.com/37941513/222895981-619c28bf-deea-4f1d-b845-36df84f2e4cf.png)
![image](https://user-images.githubusercontent.com/37941513/222896003-e012b955-7b73-4cbe-8ed9-20d63e59887d.png)
![image](https://user-images.githubusercontent.com/37941513/222896017-1dbec505-78bd-42a6-a511-d72e7e0a4d08.png)
![image](https://user-images.githubusercontent.com/37941513/222896033-eaf04c71-14ce-4cf1-8213-88dbda73b66d.png)

![image](https://user-images.githubusercontent.com/37941513/222896055-98ba46b6-5cb3-4c99-ae62-7a6286727caf.png)

### 언제 사용하면 좋나

- 중복 데이터 제거할 경우
  - 수학의 집합.
  - 똑같은 데이터 Add() 하면 아무 일도 일어나지 않으므로

문제

![image](https://user-images.githubusercontent.com/37941513/222896472-26c8e7ef-f1d0-4d9b-b5bc-f0c18a4f68bb.png)
![image](https://user-images.githubusercontent.com/37941513/222896478-65f06a1a-f5b2-401a-b82b-e351239cfcd4.png)

### 컬렉션과 같이 쓰면 좋은 것들

### 컬렉션의 순차적 요소 탐색

![image](https://user-images.githubusercontent.com/37941513/222896657-85c46d82-6193-48e6-a121-37f484215f31.png)

### 어떤 컬렉션이든 순회할 수 있는 방법 - foreach문

![image](https://user-images.githubusercontent.com/37941513/222896704-95b9e25e-3334-44f9-9b63-98c74a26d12d.png)
![image](https://user-images.githubusercontent.com/37941513/222896717-1901fa55-5ab6-454f-9d31-1ff2fef78061.png)
![image](https://user-images.githubusercontent.com/37941513/222896727-4b7ab89c-115f-4348-a8c8-2cc0673e83fb.png)
![image](https://user-images.githubusercontent.com/37941513/222896737-21afc139-681c-4086-8047-177de0c37de9.png)

### foreach문의 한계

1 . 방문하는 요소의 값을 바꿀 수 없다

![image](https://user-images.githubusercontent.com/37941513/222896754-21ee27b1-4543-4ef4-aaee-3704f4ea4e9f.png)

2 . 현재 방문중인 요소의 색인을 알 방법이 없다. - 알려면 별도의 변수를 foreach문 밖에서 선언 후 사용해야 한다.

![image](https://user-images.githubusercontent.com/37941513/222896773-ff92edd7-fa16-49fd-88b7-04c9c916f807.png)

3 . 컬렉션이나 배열을 거꾸로 탐색할 수 없다.

![image](https://user-images.githubusercontent.com/37941513/222896821-1aae4b1a-42d8-4449-b604-09ac806b7dfc.png)

![image](https://user-images.githubusercontent.com/37941513/222897202-b02adfcd-0a02-462b-b1c3-983641b1c633.png)
![image](https://user-images.githubusercontent.com/37941513/222897206-1b1dab1b-4bd8-4b8f-8185-72060c3390d6.png)

---

<br>

### var 키워드

### 딕셔너리 foreach문의 문제점

![image](https://user-images.githubusercontent.com/37941513/222897242-58eb0e9f-afb7-4036-821f-4428d0be47fc.png)

- 길다
- 매번 KeyValuePair<Tkey,Tvalue>를 써야한다.

![image](https://user-images.githubusercontent.com/37941513/222897254-8f61cf18-b98b-4a78-9c87-85d4dd89ccb6.png)

### var 키워드

![image](https://user-images.githubusercontent.com/37941513/222897279-a46b603d-ff05-4aca-a02b-e66bbfb7e21d.png)

- 묵시적 자료형
  - 컴파일러가 알아서 자료형 추론해줌
- 지역변수에서만 사용 가능
- C++은 auto라고 표현
- 긴 자료형을 짧게 줄여줌 -> 짱 편함
- 반드시 선언과 동시에 대입해야 함
  - 안 하면 컴파일 오류

### 코딩 표준 : 자료형이 뭔지 바로 알 수 있을 때만

![image](https://user-images.githubusercontent.com/37941513/222897333-e62e52c5-2d32-4b83-8cba-8c738a876cf1.png)

문제

![image](https://user-images.githubusercontent.com/37941513/222897336-4139bad2-ce88-4215-a5f7-5b6bcc242b4b.png)

![image](https://user-images.githubusercontent.com/37941513/222897349-3fc26098-0f7a-46ac-ae35-9312ab7b8bca.png)

![image](https://user-images.githubusercontent.com/37941513/222897356-207f6cc1-a6a8-40a5-9e84-f275e58e87b3.png)
