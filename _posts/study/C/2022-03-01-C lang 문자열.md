---
title: "[C] C lang 문자열"
layout: post
subtitle: C
date: "2022-03-01-04:42:51 +0900"

categories: study
tags: C
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---


### 문자열의 표현과 길이

-  C에는 자체적으로 문자열이 없다. -> 그래서 char 형 배열을 계속 사용.
    - 물론 이걸 대신 문자열처럼 표현하는 방법들이 있다. 이게 C스타일 문자열.
    - C에선 가장 기본적인 것들이고, 면접 볼떄 이거 몰라서 떨어지는 사람들도 많다.

- 가장 기본적인 내용 문자열 길이는 어떻게 구하나.

- 기본 자료형 배울 때, 어떤 걸 가장 많이 봤나?
    - 자료형의 크기, 범위
    - 언제나 고정

#### 문자열 길이는 정해져 있지 않다.

- 따라서 하드웨어보고 문자열 하나 읽으라 하면 어쩔 줄 모름.
 - 이게 문자열이 기본 자료형이 아닌 이유.

- 문자열은 여러가지 글자 (문자)들이 섞인 것.
 - 심지어 공백조차 글자.

- "여러 개"의 문자를 표기하는 데 뭐가 좋을까?
    - > 배열

- 따라서 char str[ 글자수 ] 로 표현 가능


#### 배열의 길이도 저장해야 할 것 같은데.

- 앞에서 배열에서 배열의 길이 구할 수 없다고 했는데?
    - 맞다. 그래서 배열의 길이가 배열과 같이 저장이 안 됨.
    - 따라서 프로그래머가 배열의 길이는 따로 알고 있어야 한다.
        - 그 말은 따로 변수 만들어서 이 배열의 길이는 몇이다 이런거 주면 좋다.
        - 함수 호출시 배열 길이 같이 매개변수로 넘겨준다거나 했던거는 이미 했었다.
    - char str[] = "c is fun";


![20221019_130842](https://user-images.githubusercontent.com/37941513/196671378-29d71bd5-c70b-4ee9-8232-3356fd5be254.png)

<br>

-------

### 문자열 관리 시 길이의 문제

그럼 길이를 저장하는 변수만 있으면 되겠네?


```
void print_string(void)
{
    char chars[] = "Pointer is the best";
    const size_t NUMS = 20;

    size_t =i;
    for (i = 0; i<NUM_CHARS ; ++i)
    {
        printf("%c", chars[i]);
    }
}
```

근데 여기서 


```
void print_string(void)
{
    char chars[] = "Pointer is the best C language";
    const size_t NUMS = 20;

    size_t =i;
    for (i = 0; i<NUM_CHARS ; ++i)
    {
        printf("%c", chars[i]);
    }
}
```

이런식으로 문자열 길이가 늘어나버리면? 배열의 크기도 바꿔야 함.
근데 깜빡하고 실제 배열의 크기를 저장하는 변수 NUMS의 값을 안 바꾸면? 
배열의 크기는 자동으로 바꾸는 데 변수를 제대로 안 바꾼 것 -> 세보니까 30개 가량인듯 근데 세봤는데 잘 못 세거나 문자열이 어엄청 길면?

그래서 어떤 것에서 도출해 낼 수 있는 값들을 다른 변수를 써서 따로 저장해두고 기억해 두면 이런 실수를 할 일이 많다.

<br>

배열에서 길이를 곧바로 읽어오는 방법이 없기 때문에 이런 식으로 하는 경우가 많다.


<br>

##### 문자열은 자주 쓰는데 이런 식으로 관리시 문제가 엄청 터지게 됨.

- 자주 쓰는 아이는 프로그래밍 언어 자체에서 관리해주면 좋다.

<br>

---------


### 문자열 길이 문제 해결방법 1

1. 길이를 배열 첫 위치에 저장

- 첫 메모리 위치에 문자열 길이를 저장하고, 실제 문자열이 따라오게 함.
    1. unsigned char로 길이를 저장하기엔 너무 짧음. (255자)
    2. 길이는 int로 저장하고(4 byte), 그 뒤에 char로 문자들을 저장.(그럼 2의 32승까지니까 엄청 큰 숫자가 된다.)


![20221019_133312](https://user-images.githubusercontent.com/37941513/196671385-a2cf7afd-fcaa-4eea-8414-c7790c610267.png)



![20221019_134449](https://user-images.githubusercontent.com/37941513/196671387-d3fc7804-cbb2-40b0-b90f-c936e8692256.png)


###### 장점
- 첫 주소만을 보는 것 만으로 총 글자수가 몇인지 알 수 있다.





<br>

----------


- 다른 언어에서 문자열 크기를 바로 알 수 있었던 이유
- 이런 방식으로 문자열의 길이를 저장해 두기 때문

```
string message = "HELLO";
Console.writeLine($"message len:{message.Length}");
```


###### 단점

- 글자 하나가 1바이트인데 여기에 4바이트나 쓴다?
    - 이건 클래스 또는 구조체에서나 쓰는 법

- 순수 C 코드로 이것을 어떻게 작성해야 할 지 애매함.
    - 첫 데이터는 int *로 캐스팅해서 읽고, 그 다음 부터는 char*로 읽어야 함.

    - 물론, 디스크로부터 이진파일을 통째로 읽어 메모리에 읽어오면 이런 식으로 접근하기는 함.  근데 이걸 언어 기본으로 하는거 자체가..


```
char array[9]; //길이 5와 'hello'가 적혀있음.

int * len  = (int*)&array[0];
char * str = &array[4];
```


![20221019_135314](https://user-images.githubusercontent.com/37941513/196671389-095d551d-7247-434b-96b2-36c32c8709be.png)
ㄴ

<br>

------

### 문자열 길이 문제 해결방법 2, C 스타일 문자열

#### 문자열이 끝나는 위치를 표시

- 그냥 char[] 만 쓰되 그 문자열이 끝나는 위치에 특수한 문자를 두자.

    - 배열에서 값을 찾을 수 없으면 존재할 수 없는 색인 -1을 반환하는 방식과 마찬가지.

```
size_t index_of(const char* str, char c)
{
    //str 안에 c가 있으면 해당 색인
    //없으면 -1 리턴

    return -1;
}
```

<br>


-----

##### 아스키 코드 중 화면에 출력되지 않는 특수한 문자들이 있음.

- 제어문자라 불림.
- 0~31, 127
- 그 중 하나가 0
- 널 문자(null character, 널 캐릭터)라고 불림.
- 널 포인터하고 다른 아이니 헷갈리지 말자.

![20221020_122849](https://user-images.githubusercontent.com/37941513/196939624-9e90d2cc-9d26-4882-9a66-9c8762a095bf.png)


```
char null_char ='\0';
```

- 0은 숫자 영
- \는 이스케이프 문자
- 근데 아스키코드로 0이니 char null_char = 0으로 작성 가능
- 그러나 읽기 쉽게 '\0'으로 써주자.

**C스타일 문자열이라 하면 널 문자로 끝나는 char배열을 말함.**

<br>

--------


#### C스타일 문자열

- char[] 로만 구성
- 문자열이 끝나는 곳에 널 문자를 붙임.


![20221020_123509](https://user-images.githubusercontent.com/37941513/196939629-4ce2f929-3c7c-4eba-aea4-9e8e1d7e5a23.png)

<br>


-----


```
char str1[] = "abc"; //스택에 abc 저장
char *str2 = "abc"; //데이터 섹션에 abc저장
```

- 이 두 코드는 저장위치 이외에는 동일

    - 문자열 뒤에 별도로 '\0'을 넣지 않아도, 컴파일러가 알아서 해줌.


![20221020_124043](https://user-images.githubusercontent.com/37941513/196939633-f98fe5bc-ce68-4a12-8d0c-bccd0bc4a2a9.png)


<br>

단, 이 경우에는 '\0'을 넣어주지 않음

- char str[] ={'a','b','c'};


![20221020_234858](https://user-images.githubusercontent.com/37941513/196982240-cc345352-c526-4e45-bb1f-8741efc730da.png)


```
const char str[] = "hello"
printf("str length:%d", sizeof(str));
```

뭐가 출력 되나? (6)

<br>

--------

### C 스타일 문자열의 장단점, 문자열 길이 구하기

##### 언제나 배열에 널 문자도 있다는 건 있지 말자.

- 문자열의 길이는 4
- 배열의 길이는 최소한 5

배열의 실제 크기를 잡아두고(충분히 크게 잡아두고) 거기 일부만 이런식으로 5개 채워놓고 널 집어넣어도 그건 유효한 문자열임.

어찌보면 C에서 이런식으로 문자열 구현해서 메모리 관리가 좀 더 효율적이고 빠르게 될 수 있었다.


#### C스타일 문자열의 장단점

- 장점
    - 가장 최소한의 메모리
    - 한 가지 데이터형으로 문자열과 길이를 다 표현

- 단점 
    - 어떤 문자열 길이를 알려면 배열을 끝까지 훑어야 함. O(N)


<br>

-------

#### 문자열 길이 구하기

- 이 정도는 스스로 작성 해야됨
- 사실 매우 흔한 기초 면접 문제
- 너무 기초라 못 맞추면 그 순간 탈락.
- 이거 못해서 떨어지는 사람들도 많다(경력직까지)
- fizzbuzz마저 못 푸는 시니어도 많다.
 
<br>

-----

#### 문자열 구하기 개념

1 . char 배열의 요소를 처음부터 차례로 읽는다.
2 . 널 문자를 만나면 멈춘다.
3 . 여태껏 몇개 char 방문한 지 그 카운터를 반환

```
size_t get_string_length(const char* str)
{
    size_t i;
    for(i =0; str[i]!= '\0'; ++i)
    {

    }
    return i;
}
```

이런 문자열 길이 구하는 건 1~2분 안에 풀어야 한다. 메모리상에서 어떻게 문자열 구성해야 하는지 이건 기초.
이런 걸 못 풀면 기초조차 안 되어 있다고 봄.


```
size_t get_string_length(const char* str)
{
    size_t i;
    for(i = 0; str[i]!= '\0';++i)
    { 
    }
    return i;
}
```

위 코드는 어떤가 확실한가? - 뭔 질문인지 모르면 다시 공부해야됨.(포인터를)
정수 훑으면서 합 구할때 나왔었다.


![20221021_014205](https://user-images.githubusercontent.com/37941513/197008558-48a21d23-5499-450f-8cfd-a3ae2b4d2ab5.png)


왜 최선이 아닌가?

1번씩 돌 때 마다 시작주소 플러스 i 를 해야한다. 비효율 적일 수 있음.

앞에서 포인터 못 잡으면 문자열 해도 의미 없다.

그떄 개미만큼 더 효율적인 건 포인터 쓰는거라고 했다.

만약 코드에서 for문썼는데 효율적으로 될까요? 라고 물을때 이렇게 답하면 면접에서 만점인 것.


![20221021_014933](https://user-images.githubusercontent.com/37941513/197010088-0b543ce2-f5a8-4893-91a2-cc9740b1915e.png)


둘 다 작동하는 방법

1은 str을 p에 두고 p를 그냥 증가시키는 거 (널 캐릭터 나올떄 까지)
그거와 시작위치와 널포인터 위치 구하고 뺴면 위치 나옴. = 그 사이 몇개 요소 있는 지 알려줌.

2는 카운터 변수 하나 두고 메모리 위치 옮길 떄 마다 카운트 하나 증가.

앞으로는 문자열 설명시 배열은 다른 언어에서나 하는거지 C에서는 포인터 방식.(배열을 포인터 접근하는 거 잊지 말자.)

