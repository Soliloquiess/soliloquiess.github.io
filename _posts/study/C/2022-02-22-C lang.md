---
title: "[C] C lang 기본문법"
layout: post
subtitle: C
date: "2022-02-22-04:42:51 +0900"

categories: study
tags: C
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---

### #include, stdio.h

- C#에서 using 지시문(directive)과 비슷한 일을 한다.
- 다른 파일에 구현한 함수나 변수를 사용할 수 있게 해줌.(다만, C#처럼 알아서 함수나 변수를 찾아주지는 않음.)
- #include는 전처리기 지시문 중 하나.
- 전처리기
  - 컴파일을 하기 전 텍스트를 복붙해주는 역할을 함.


#### #include<>

- #include<stdio.h>에서 <> 안의 단어는 실제로 디스크상에 존재하는 파일 이름이다.

c의 헤더가드 include는 헤더 파일을 열어서 (*h) 그 내용을 복사한 뒤, - #include<stdio.h> 라는 부분을 없애고 복사한 내용으로 바꾸는 것이다.

- include <stdio.h> /* 컴파일 */
- include 'stdio.h' /* 컴파일 오류 */
- include "stdio.h" /* 컴파일 */

-> include "stdio.h" 는 사용이 되나 권장하지 않는다.(사용 하지 말것)
- include <stdio.h>는 C 표준라이브러리 중 일부이다. (C standard Library)

##### C 표준 라이브러리란.

다음에 필요한 매크로 , 자료형 (data type) , 함수 등을 모아 둔 것.

- 문자열 처리
- 수학 계산
- 입출력 처리
- 메모리 관리

##### <stdio.h>의 역할

- libc에서 표준 입출력 (Standard Input and Output)을 담당.
- 스트림 입출력에 관한 함수들을 포함.
- C#의 네임스페이스와 비슷한 역할을 지닌 라이브러리.
- 안에 있는 함수의 예로 printf(), scanf(), fopen(), fclose() 등이 있다.



------


### main(void) 함수

```
int main(void)
{
  return 0;
}
```

- 프로그램의 진입점 (entry point)
- C 코드를 빌드해서 나온 실행파일 (.exe 또는 .out) 을 실행하면 main 함수가 자동적으로 실행 됨.

#### main() 함수의 이름과 반환형

C#
```
static void Main(string[] args)
{

}
```

###### C#에서 봤던 Main()함수와 같은 역할

- 하지만 C는 대문자 'M' 대신 소문자 'm' 사용
- 약속된 함수명이라 바꾸는 건 불가능 함.

###### 반드시 int를 반환함.

- 0: 프로그램이 문제가 없었다는 뜻.(정상종료 판단)
근데 이걸 어겨도 누가 때리거나 그러지는 않는다.



```
#include <stdio.h>

int main(void)
{
  printf("hello");
  return 0;
}
```

clang -std=c89 -W -Wall -pedantic-errors main.c

를 clang 설치 후 컴파일 하면 윈도우면 a.exe, 유닉스 계열은 a.out 생성.


#### main(void) 함수 : (void)

```
int main(void){
  return 0;
}
```

다른 언어와 달리 void를 생략한다고 **매개변수가 없다는 뜻이 아님**
C에는 함수 선언과 함수 정의가 있음.
- 함수 선언에서 void를 생략하면 매개 변수를 받는다는 의미
  - 단, 아직 매개변수의 개수와 자료형을 모를 뿐.

- 함수정의에서 void를 생략하면 매개변수가 없다는 뜻.

따라서 언제나 void를 넣는 습관을 기르자.


##### 예시

int sum(void); /* 함수 선언: 매개 변수가 없음  */
int sum(); /* 함수 선언: 매개 변수가 있는데, 아직 뭔지 모름.  */

int sum(void) /*함수정의: 매개변수가 없음 */
{
  /*코드 생략 */
}

int sum() /* 함수 정의 : 매개변수가 없음 */
{
  /*코드 생략 */
}

int sum(const int num1, const int num2 ) /* 함수 정의: 매개변수가 2개 있음 */
{
  /*코드 생략 */
}

##### 커맨드라인 인자 받아오는 법

JAVA나 C#은 커맨드라인 인자를 main에서 받아온다.(main함수에 바로 넣어버림)
public static void main(String args[])
{
  //args[4] : "a" , "b" , "c" , "d"
}

##### main() 함수와 커맨드라인 인자

- C에도 같은 코드가 있다.

```
int main(int argc, char * argv[])
{
  /* 코드 생략 */
  return 0;
}
```
<br>
혹은

```
int main(int argc, char ** argv)
{
  return 0;
}
```
위는 배열형태로 받고 아래는 문자열 형태로 받는다 보면 된다.
argc는 인자, argv는 받는 형태(내용), **argv는 포인터 받는다 보면 된다.


<br>
------


### printf()

printf("hello");

- 화면에 데이터 출력하는 함수.
- printf()는 'print formatted'(서식에 맞게 출력하다.) 그냥 이쁘게 출력한다 보면 됨.

#### printf() 함수로 문자열 출력하기

- C#이나 다른 언어들은 '+'나 string.format() 혹은 문자열 보간 ($"{}") 을 이용.
- C는 그런거 없다..

  - '%s' 라는 서식문자가 (format specifier) 문자열이 들어갈 위치를 알려줌.

```
const char* name = "Blood Mary";
printf("hello, %s\n", name);

```

#### printf() 함수로 정수 출력하기

- C#이나 다른 언어들은 '+'나 string.format() 혹은 문자열 보간 ($"{}") 을 이용.
- C는 그런거 없다..

  - '%d' 라는 서식문자가 (format specifier) 정수가 들어갈 위치를 알려줌.

```
int num1 = 90;
int num2 = 80;

printf("%d %d", num1, num2);

```

각 '%s', '%d' 가 데이터를 서식하게 됨.

<br>
------

### 주석(comments)

/* entry point for the program */

- /* */ 만 지원
- 주석이 여러줄이든 한줄이든 다 /* */
  -  vsc나 다른 ide에서 //를 치면 주석처리 되는 경우가 많은데 vsc는 c++과 c 혼용해서 적혀서 그런점도 있으며 ide도 그랜식으로 되어있는게 많다.
- 다른 언어는 하나는 //, 여러줄이면 /* */가 일반적이다.
- C는 그딴거 없다. 🤔



```
#include <stdio.h>

int main(void)
{
  //Lets try it
  printf("hello");
  return 0;
}
```

주석 부분에서 에러가 난다.


<br>

------
test)

```
void print_number(void); /* 함수 선언: 매개변수 목록에 void를 사용 */
void print_number();     /* 함수 선언: 매개변수 목록에 void를 생략 */
```

- C에서 함수를 선언할 때 매개 변수 목록에 void를 사용하는 것은 무엇을 의미하나?

1. 이 함수는 매개변수를 받지만, 매개변수의 개수가 한정된다.
2. 이 함수는 매개변수가 없다.
3. 이 함수는 매개변수를 받는다. 단지, 아직 자료형과 개수를 모를 뿐 이다.
4. 이 함수는 void 형 매개변수를 받는다.


- C89 표준에서 허용하는 주석 형태는?



------


### C언어만의 기본 문법. C는 절차적 언어

- 절차적 언어와 개체지향언어(OOP) 차이는 다들 안다.
- C#, JAVA같은 언어들은 OOP언어지만 절차적으로도 어느정도 사용이 가능하다.
- 하지만 C는 순수하게 절차적 언어로만으로 사용이 가능하다.

<br>

- 즉, C로 작성한 코드는 데이터보다 프로세스에 맞춰져 있다.
- 이게 반드시 나쁜 것은 아니다.
  - OOP에서도 종종 절차적 언어 스타일로 코드를 작성한다.
- 또한 절차적 언어는 이해하기 쉽다.
  - 매뉴얼에 적힌 대로 따라하는 느낌.

절차적 언어는 데이터 보다 프로세스를 중시 하기 떄문에 클래스, 절차적 OOP 이런 개념들도 없다.(문법 자체는 간단해 보일수도 라고 느낄수 있다.)
