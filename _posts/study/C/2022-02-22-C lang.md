---
title: "[C] C lang 기본문법"
layout: post
subtitle: C
date: "2022-02-22-04:42:51 +0900"

categories: study
tags: C
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---

### #include, stdio.h

- C#에서 using 지시문(directive)과 비슷한 일을 한다.
- 다른 파일에 구현한 함수나 변수를 사용할 수 있게 해줌.(다만, C#처럼 알아서 함수나 변수를 찾아주지는 않음.)
- #include는 전처리기 지시문 중 하나.
- 전처리기
  - 컴파일을 하기 전 텍스트를 복붙해주는 역할을 함.


#### #include<>

- #include<stdio.h>에서 <> 안의 단어는 실제로 디스크상에 존재하는 파일 이름이다.

c의 헤더가드 include는 헤더 파일을 열어서 (*h) 그 내용을 복사한 뒤, - #include<stdio.h> 라는 부분을 없애고 복사한 내용으로 바꾸는 것이다.

- include <stdio.h> /* 컴파일 */
- include 'stdio.h' /* 컴파일 오류 */
- include "stdio.h" /* 컴파일 */

-> include "stdio.h" 는 사용이 되나 권장하지 않는다.(사용 하지 말것)
- include <stdio.h>는 C 표준라이브러리 중 일부이다. (C standard Library)

##### C 표준 라이브러리란.

다음에 필요한 매크로 , 자료형 (data type) , 함수 등을 모아 둔 것.

- 문자열 처리
- 수학 계산
- 입출력 처리
- 메모리 관리

##### stdio.h의 역할

- libc에서 표준 입출력 (Standard Input and Output)을 담당.
- 스트림 입출력에 관한 함수들을 포함.
- C#의 네임스페이스와 비슷한 역할을 지닌 라이브러리.
- 안에 있는 함수의 예로 printf(), scanf(), fopen(), fclose() 등이 있다.



------


### main(void) 함수

```
int main(void)
{
  return 0;
}
```

- 프로그램의 진입점 (entry point)
- C 코드를 빌드해서 나온 실행파일 (.exe 또는 .out) 을 실행하면 main 함수가 자동적으로 실행 됨.

#### main() 함수의 이름과 반환형

C#
```
static void Main(string[] args)
{

}
```

###### C#에서 봤던 Main()함수와 같은 역할

- 하지만 C는 대문자 'M' 대신 소문자 'm' 사용
- 약속된 함수명이라 바꾸는 건 불가능 함.

###### 반드시 int를 반환함.

- 0: 프로그램이 문제가 없었다는 뜻.(정상종료 판단)
근데 이걸 어겨도 누가 때리거나 그러지는 않는다.



```
#include <stdio.h>

int main(void)
{
  printf("hello");
  return 0;
}
```

clang -std=c89 -W -Wall -pedantic-errors main.c

를 clang 설치 후 컴파일 하면 윈도우면 a.exe, 유닉스 계열은 a.out 생성.


#### main(void) 함수 : (void)

```
int main(void){
  return 0;
}
```

다른 언어와 달리 void를 생략한다고 **매개변수가 없다는 뜻이 아님**
C에는 함수 선언과 함수 정의가 있음.
- 함수 선언에서 void를 생략하면 매개 변수를 받는다는 의미
  - 단, 아직 매개변수의 개수와 자료형을 모를 뿐.

- 함수정의에서 void를 생략하면 매개변수가 없다는 뜻.

따라서 언제나 void를 넣는 습관을 기르자.


##### 예시

int sum(void); /* 함수 선언: 매개 변수가 없음  */
int sum(); /* 함수 선언: 매개 변수가 있는데, 아직 뭔지 모름.  */

int sum(void) /*함수정의: 매개변수가 없음 */
{
  /*코드 생략 */
}

int sum() /* 함수 정의 : 매개변수가 없음 */
{
  /*코드 생략 */
}

int sum(const int num1, const int num2 ) /* 함수 정의: 매개변수가 2개 있음 */
{
  /*코드 생략 */
}

##### 커맨드라인 인자 받아오는 법

JAVA나 C#은 커맨드라인 인자를 main에서 받아온다.(main함수에 바로 넣어버림)
public static void main(String args[])
{
  //args[4] : "a" , "b" , "c" , "d"
}

##### main() 함수와 커맨드라인 인자

- C에도 같은 코드가 있다.

```
int main(int argc, char * argv[])
{
  /* 코드 생략 */
  return 0;
}
```
<br>
혹은

```
int main(int argc, char ** argv)
{
  return 0;
}
```
위는 배열형태로 받고 아래는 문자열 형태로 받는다 보면 된다.
argc는 인자, argv는 받는 형태(내용), **argv는 포인터 받는다 보면 된다.


<br>
------


### printf()

printf("hello");

- 화면에 데이터 출력하는 함수.
- printf()는 'print formatted'(서식에 맞게 출력하다.) 그냥 이쁘게 출력한다 보면 됨.

#### printf() 함수로 문자열 출력하기

- C#이나 다른 언어들은 '+'나 string.format() 혹은 문자열 보간 ($"{}") 을 이용.
- C는 그런거 없다..

  - '%s' 라는 서식문자가 (format specifier) 문자열이 들어갈 위치를 알려줌.

```
const char* name = "Blood Mary";
printf("hello, %s\n", name);

```

#### printf() 함수로 정수 출력하기

- C#이나 다른 언어들은 '+'나 string.format() 혹은 문자열 보간 ($"{}") 을 이용.
- C는 그런거 없다..

  - '%d' 라는 서식문자가 (format specifier) 정수가 들어갈 위치를 알려줌.

```
int num1 = 90;
int num2 = 80;

printf("%d %d", num1, num2);

```

각 '%s', '%d' 가 데이터를 서식하게 됨.

<br>
------

### 주석(comments)

/* entry point for the program */

- /* */ 만 지원
- 주석이 여러줄이든 한줄이든 다 /* */
  -  vsc나 다른 ide에서 //를 치면 주석처리 되는 경우가 많은데 vsc는 c++과 c 혼용해서 적혀서 그런점도 있으며 ide도 그랜식으로 되어있는게 많다.
- 다른 언어는 하나는 //, 여러줄이면 /* */가 일반적이다.
- C는 그딴거 없다. 🤔



```
#include <stdio.h>

int main(void)
{
  //Lets try it
  printf("hello");
  return 0;
}
```

주석 부분에서 에러가 난다.


<br>

------
test)

```
void print_number(void); /* 함수 선언: 매개변수 목록에 void를 사용 */
void print_number();     /* 함수 선언: 매개변수 목록에 void를 생략 */
```

- C에서 함수를 선언할 때 매개 변수 목록에 void를 사용하는 것은 무엇을 의미하나?

1. 이 함수는 매개변수를 받지만, 매개변수의 개수가 한정된다.
2. 이 함수는 매개변수가 없다.
3. 이 함수는 매개변수를 받는다. 단지, 아직 자료형과 개수를 모를 뿐 이다.
4. 이 함수는 void 형 매개변수를 받는다.


- C89 표준에서 허용하는 주석 형태는?



------


### C언어만의 기본 문법. C는 절차적 언어

- 절차적 언어와 개체지향언어(OOP) 차이는 다들 안다.
- C#, JAVA같은 언어들은 OOP언어지만 절차적으로도 어느정도 사용이 가능하다.
- 하지만 C는 순수하게 절차적 언어로만으로 사용이 가능하다.

<br>

- 즉, C로 작성한 코드는 데이터보다 프로세스에 맞춰져 있다.
- 이게 반드시 나쁜 것은 아니다.
  - OOP에서도 종종 절차적 언어 스타일로 코드를 작성한다.
- 또한 절차적 언어는 이해하기 쉽다.
  - 매뉴얼에 적힌 대로 따라하는 느낌.

절차적 언어는 데이터 보다 프로세스를 중시 하기 떄문에 클래스, 절차적 OOP 이런 개념들도 없다.(문법 자체는 간단해 보일수도 라고 느낄수 있다.)

- 클래스(Class): 그런거 없다.

- 함수
  - 모두 전역(global) 변수
  - 기본적으로 어디서나 호출 가능

- 변수
  - 함수 밖에 선언되어 있으면 전역변수
  - 함수 안이면 지역변수



<br>


-----


### 자료형 (data type)

- char, short, int, long, float, double, long double 이런 건 다 안다는 가정하에

#### unsigned 와 signed

- C#에서는 부호없는(unsigned) 자료형 앞에 접두사 u를 붙임.
  - 단. byte는 기본이 '부호 없음'
  - 부호 있는 byte를 쓰려면 접두사 s를 붙였음.

- C는 unsigned라는 단어를 자료형 이름 앞에 넣어줘야 함.
  - 예: unsigned char, unsigned int
  - '부호 있음'을 명확히 보여주기 위해 signed를 붙일 수도 있음.
    - 예) signed int, signed char
  - unsigned/signed 를 생략하면 부호 있음(char)이 기본이다.
    - 단, char은 예외다.



위 둘(char, byte)가 다른 이유는 둘 다 어떤 데이터를 표현하는 가장 작은 단위이다.(컴퓨터에 접근 가능한 가장 작은 단위)
데이터를 읽어오는 가장 작은 단어가 byte인데, 바이트이기 때문에 바이트를 순수한 1바이트 이진 숫자로 생각하면  signed으로 보기 어려운 점도 있고 아스키 코드와도 관련이 없다고는 할 수 없다.

<br>
----------


### Char형

```
char a = 'a';
char b = 'a+1' /* 98,b */
char c = 99;  /* 99, c */

```

**최소** 8 비트인 정수형

최소 8비트? -> '표준은 8비트 이상' 이라고만 정의한다.
그럼 몇십만 비트 적용해도 표준에 맞나? -> ㅇㅇ 표준에 맞다.

물론 그런 컴파일러는 없긴 하다. 표준은 기본적으로 비트로 얘기한다.

#### char가 몇 비트인지 찾는 법

- <limit.h> 헤더를 include 한 뒤, CHAR_BIT을 보면 몇 비트인지 알 수 있음.(define 된 정수 볼 수 있다.)

```
#include <limit.h>
int main(void)
{
    char char_size = CHAR_BIT;
    return 0;
}
```

char가 몇 비트인지 찾는 이유 = 컴파일러에 따라 char의 비트가 다를 수 있다. 어떤건 16비트, 어떤건 9비트 어떤건 90비트. 이런 식일 수 있기 때문.

윈도우 , vsc 등 char은 기본적으로 8비트

원래 C표준은 기본 자료형들의 정확한 바이트 수를 강요하지 않는다.
  - 컴파일러마다 알아서 함.

더 나아가 1바이트를 CHAR_BIT 만큼이라고 한다.

왜냐하면? 소형기기에 따라 특정 크기를 적용하는 게 어려울 수 있기 때문이다.


<br>

------


##### 헷갈리는 점

1바이트는 비트 8개가 모인 것.
근데 그건 일반 컴퓨터에서 얘기하는 점이고

C기준에서는 1바이트가 8비트가 아닐 수 있다.

**C 표준은 CHAR_BIT 이 8 비트이면 그게 1바이트이다.**
이게 16비트면 1바이트이다.

??? 🤔 ???


char는 내가 돌리는 기계에서 표현이 가능한 가장 작은 단위의 메모리.
내가 접근하고 데이터를 저장하는 단위의 작은 메모리.

그게 어떤 기기냐에 따라서 1 바이트일 수도 있고, 어떤 기기는 2 바이트에 저장을 할 수도 있다.

여기서 말하는 2바이트는 일반적으로 얘기하는 8비트.
8비트로 저장할 수도 있고 16비트로 저장할 수도 있다.

***이게 char라는 자료형이다. 그럼 C언어에서의 바이트라고 하는 개념은 char의 크기이다.***


-> 컴퓨터의 가장 적게 저장할 수 있는 단위. 지금 사용하고 있는 기기에, 그 단위가 2바이트라면 실제 16비트라면 그 16비트를 1바이트로 한다.

즉, char 사이즈 1바이트. 그게 C표준이 말하는 것. 위에서 계속 8비트, 8비트 적었는데. 비트는 바뀌지 않기 때문. 그래서 비트로 얘기했다.

결국 소형기기에 따라, 구조를 어떻게 잡았냐에 따라, 기계가 어떻게 되어있는지에 따라 기본적으로 저장소는 단위가 다를 수 있다.

하드웨어 설계자의 마음대로이기 때문에, C는 과거에 많은 하드웨어에 쓰였던 것. 그 하드웨어가 지금도 많이 쓰이기 떄문에

8비트 = 1바이트로 굳어졌다.

생각해야 될 건 그 **바이트는 char의 크기이다.**


<br>

----


#### char과 signed/unsigned

- 정수형이니 signed(부호 있음)와 unsigned(부호 없음)가 있음.
- signed/unsigned 를 생략하면?
- signed이라고 보통 생각 (왜? 보통 정수형은 다 그러기 때문)
- 그럼 unsigned 인가? -> ㄴㄴ
- C 표준은 그런걸 정하지 않았다.
- 컴파일러 구현 따라 정해짐.
  - 어디서는 signed, 어디서는 unsigned(clang으로 윈도우에서 확인해보면 signed 출력)
  - clang window에서는 signed.
  - char sign_test = 255;
    - 주고 -1을 확인해보면 signed가 나온다.

<br>
---------

#### char의 기본 부호가 지정 안 된 이유?


- 아스키의 범위는 0~127 이므로 부호 여부는 상관이 없음.
  - 기본 부호 지정 안 된 이유는 char를 아스키 char만 사용한다고 가정하면 부호는 상관이 없음.  그게 0이든 1이든 간에 뒤에는 0,1 쓸 일이 없으니까  아예 첫 번째 비트, 최상위 비트 쓸 일이 없고 하위 일곱 비트만 쓰니까 상관이 없음 


- 단, 8비트 정수형으로 쓰려고 할 때는  반드시 char 앞에 signed나 unsigned를 붙이는 게 좋음.  



```
signed char signed_char = -1;
unsigned char unsigned_char = 255;
```

안 그러면 포팅해도 문제 없는 정수 범위는 0~127 뿐.
- 0000 0000(2) ~ 1111 1111(2)






-----
