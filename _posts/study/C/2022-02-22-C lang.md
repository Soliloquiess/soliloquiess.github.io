---
title: "[C] C lang 기본문법"
layout: post
subtitle: C
date: "2022-02-22-04:42:51 +0900"

categories: study
tags: C
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---

### #include, stdio.h

- C#에서 using 지시문(directive)과 비슷한 일을 한다.
- 다른 파일에 구현한 함수나 변수를 사용할 수 있게 해줌.(다만, C#처럼 알아서 함수나 변수를 찾아주지는 않음.)
- #include는 전처리기 지시문 중 하나.
- 전처리기
  - 컴파일을 하기 전 텍스트를 복붙해주는 역할을 함.


#### #include<>

- #include<stdio.h>에서 <> 안의 단어는 실제로 디스크상에 존재하는 파일 이름이다.


![20221006_105658](https://user-images.githubusercontent.com/37941513/194294922-cd98384e-b952-48cf-971f-61b91d066001.png)


c의 헤더가드 include는 헤더 파일을 열어서 (*h) 그 내용을 복사한 뒤, - #include<stdio.h> 라는 부분을 없애고 복사한 내용으로 바꾸는 것이다.

- include <stdio.h> /* 컴파일 */
- include 'stdio.h' /* 컴파일 오류 */
- include "stdio.h" /* 컴파일 */

-> include "stdio.h" 는 사용이 되나 권장하지 않는다.(사용 하지 말것)
- include <stdio.h>는 C 표준라이브러리 중 일부이다. (C standard Library)

##### C 표준 라이브러리란.

다음에 필요한 매크로 , 자료형 (data type) , 함수 등을 모아 둔 것.

- 문자열 처리
- 수학 계산
- 입출력 처리
- 메모리 관리

##### stdio.h의 역할

- libc에서 표준 입출력 (Standard Input and Output)을 담당.
- 스트림 입출력에 관한 함수들을 포함.
- C#의 네임스페이스와 비슷한 역할을 지닌 라이브러리.
- 안에 있는 함수의 예로 printf(), scanf(), fopen(), fclose() 등이 있다.



------


### main(void) 함수

```
int main(void)
{
  return 0;
}
```

- 프로그램의 진입점 (entry point)
- C 코드를 빌드해서 나온 실행파일 (.exe 또는 .out) 을 실행하면 main 함수가 자동적으로 실행 됨.

#### main() 함수의 이름과 반환형

C#
```
static void Main(string[] args)
{

}
```

###### C#에서 봤던 Main()함수와 같은 역할

- 하지만 C는 대문자 'M' 대신 소문자 'm' 사용
- 약속된 함수명이라 바꾸는 건 불가능 함.

###### 반드시 int를 반환함.

- 0: 프로그램이 문제가 없었다는 뜻.(정상종료 판단)
근데 이걸 어겨도 누가 때리거나 그러지는 않는다.



```
#include <stdio.h>

int main(void)
{
  printf("hello");
  return 0;
}
```

clang -std=c89 -W -Wall -pedantic-errors main.c

를 clang 설치 후 컴파일 하면 윈도우면 a.exe, 유닉스 계열은 a.out 생성.


#### main(void) 함수 : (void)

```
int main(void){
  return 0;
}
```

다른 언어와 달리 void를 생략한다고 **매개변수가 없다는 뜻이 아님**
C에는 함수 선언과 함수 정의가 있음.
- 함수 선언에서 void를 생략하면 매개 변수를 받는다는 의미
  - 단, 아직 매개변수의 개수와 자료형을 모를 뿐.

- 함수정의에서 void를 생략하면 매개변수가 없다는 뜻.

따라서 언제나 void를 넣는 습관을 기르자.


##### 예시

int sum(void); /* 함수 선언: 매개 변수가 없음  */
int sum(); /* 함수 선언: 매개 변수가 있는데, 아직 뭔지 모름.  */

int sum(void) /*함수정의: 매개변수가 없음 */
{
  /*코드 생략 */
}

int sum() /* 함수 정의 : 매개변수가 없음 */
{
  /*코드 생략 */
}

int sum(const int num1, const int num2 ) /* 함수 정의: 매개변수가 2개 있음 */
{
  /*코드 생략 */
}

##### 커맨드라인 인자 받아오는 법

JAVA나 C#은 커맨드라인 인자를 main에서 받아온다.(main함수에 바로 넣어버림)
public static void main(String args[])
{
  //args[4] : "a" , "b" , "c" , "d"
}

##### main() 함수와 커맨드라인 인자

- C에도 같은 코드가 있다.

```
int main(int argc, char * argv[])
{
  /* 코드 생략 */
  return 0;
}
```
<br>
혹은

```
int main(int argc, char ** argv)
{
  return 0;
}
```
위는 배열형태로 받고 아래는 문자열 형태로 받는다 보면 된다.
argc는 인자, argv는 받는 형태(내용), **argv는 포인터 받는다 보면 된다.


<br>
------


### printf()

printf("hello");

- 화면에 데이터 출력하는 함수.
- printf()는 'print formatted'(서식에 맞게 출력하다.) 그냥 이쁘게 출력한다 보면 됨.

#### printf() 함수로 문자열 출력하기

- C#이나 다른 언어들은 '+'나 string.format() 혹은 문자열 보간 ($"{}") 을 이용.
- C는 그런거 없다..

  - '%s' 라는 서식문자가 (format specifier) 문자열이 들어갈 위치를 알려줌.

```
const char* name = "Blood Mary";
printf("hello, %s\n", name);

```

#### printf() 함수로 정수 출력하기

- C#이나 다른 언어들은 '+'나 string.format() 혹은 문자열 보간 ($"{}") 을 이용.
- C는 그런거 없다..

  - '%d' 라는 서식문자가 (format specifier) 정수가 들어갈 위치를 알려줌.

```
int num1 = 90;
int num2 = 80;

printf("%d %d", num1, num2);

```

각 '%s', '%d' 가 데이터를 서식하게 됨.

<br>
------

### 주석(comments)

/* entry point for the program */

- /* */ 만 지원
- 주석이 여러줄이든 한줄이든 다 /* */
  -  vsc나 다른 ide에서 //를 치면 주석처리 되는 경우가 많은데 vsc는 c++과 c 혼용해서 적혀서 그런점도 있으며 ide도 그랜식으로 되어있는게 많다.
- 다른 언어는 하나는 //, 여러줄이면 /* */가 일반적이다.
- C는 그딴거 없다. 🤔



```
#include <stdio.h>

int main(void)
{
  //Lets try it
  printf("hello");
  return 0;
}
```
![20221006_141231](https://user-images.githubusercontent.com/37941513/194295004-830155c6-251a-4fe9-b261-a34dbbc0ee7c.png)
s

주석 부분에서 에러가 난다.


<br>

------
test)

```
void print_number(void); /* 함수 선언: 매개변수 목록에 void를 사용 */
void print_number();     /* 함수 선언: 매개변수 목록에 void를 생략 */
```

- C에서 함수를 선언할 때 매개 변수 목록에 void를 사용하는 것은 무엇을 의미하나?

1. 이 함수는 매개변수를 받지만, 매개변수의 개수가 한정된다.
2. 이 함수는 매개변수가 없다.
3. 이 함수는 매개변수를 받는다. 단지, 아직 자료형과 개수를 모를 뿐 이다.
4. 이 함수는 void 형 매개변수를 받는다.


- C89 표준에서 허용하는 주석 형태는?



------


### C언어만의 기본 문법. C는 절차적 언어

- 절차적 언어와 개체지향언어(OOP) 차이는 다들 안다.
- C#, JAVA같은 언어들은 OOP언어지만 절차적으로도 어느정도 사용이 가능하다.
- 하지만 C는 순수하게 절차적 언어로만으로 사용이 가능하다.

<br>

- 즉, C로 작성한 코드는 데이터보다 프로세스에 맞춰져 있다.
- 이게 반드시 나쁜 것은 아니다.
  - OOP에서도 종종 절차적 언어 스타일로 코드를 작성한다.
- 또한 절차적 언어는 이해하기 쉽다.
  - 매뉴얼에 적힌 대로 따라하는 느낌.

절차적 언어는 데이터 보다 프로세스를 중시 하기 떄문에 클래스, 절차적 OOP 이런 개념들도 없다.(문법 자체는 간단해 보일수도 라고 느낄수 있다.)

- 클래스(Class): 그런거 없다.

- 함수
  - 모두 전역(global) 변수
  - 기본적으로 어디서나 호출 가능

- 변수
  - 함수 밖에 선언되어 있으면 전역변수
  - 함수 안이면 지역변수



<br>


-----


### 자료형 (data type)

- char, short, int, long, float, double, long double 이런 건 다 안다는 가정하에

#### unsigned 와 signed

- C#에서는 부호없는(unsigned) 자료형 앞에 접두사 u를 붙임.
  - 단. byte는 기본이 '부호 없음'
  - 부호 있는 byte를 쓰려면 접두사 s를 붙였음.

- C는 unsigned라는 단어를 자료형 이름 앞에 넣어줘야 함.
  - 예: unsigned char, unsigned int
  - '부호 있음'을 명확히 보여주기 위해 signed를 붙일 수도 있음.
    - 예) signed int, signed char
  - unsigned/signed 를 생략하면 부호 있음(char)이 기본이다.
    - 단, char은 예외다.



위 둘(char, byte)가 다른 이유는 둘 다 어떤 데이터를 표현하는 가장 작은 단위이다.(컴퓨터에 접근 가능한 가장 작은 단위)
데이터를 읽어오는 가장 작은 단어가 byte인데, 바이트이기 때문에 바이트를 순수한 1바이트 이진 숫자로 생각하면  signed으로 보기 어려운 점도 있고 아스키 코드와도 관련이 없다고는 할 수 없다.

<br>
----------


### Char형

```
char a = 'a';
char b = 'a+1' /* 98,b */
char c = 99;  /* 99, c */

```

**최소** 8 비트인 정수형

최소 8비트? -> '표준은 8비트 이상' 이라고만 정의한다.
그럼 몇십만 비트 적용해도 표준에 맞나? -> ㅇㅇ 표준에 맞다.

물론 그런 컴파일러는 없긴 하다. 표준은 기본적으로 비트로 얘기한다.

#### char가 몇 비트인지 찾는 법

- <limit.h> 헤더를 include 한 뒤, CHAR_BIT을 보면 몇 비트인지 알 수 있음.(define 된 정수 볼 수 있다.)

```
#include <limit.h>
int main(void)
{
    char char_size = CHAR_BIT;
    return 0;
}
```

char가 몇 비트인지 찾는 이유 = 컴파일러에 따라 char의 비트가 다를 수 있다. 어떤건 16비트, 어떤건 9비트 어떤건 90비트. 이런 식일 수 있기 때문.

윈도우 , vsc 등 char은 기본적으로 8비트

원래 C표준은 기본 자료형들의 정확한 바이트 수를 강요하지 않는다.
  - 컴파일러마다 알아서 함.

더 나아가 1바이트를 CHAR_BIT 만큼이라고 한다.

왜냐하면? 소형기기에 따라 특정 크기를 적용하는 게 어려울 수 있기 때문이다.


<br>

------


##### 헷갈리는 점

1바이트는 비트 8개가 모인 것.
근데 그건 일반 컴퓨터에서 얘기하는 점이고

C기준에서는 1바이트가 8비트가 아닐 수 있다.

**C 표준은 CHAR_BIT 이 8 비트이면 그게 1바이트이다.**
이게 16비트면 1바이트이다.

??? 🤔 ???


char는 내가 돌리는 기계에서 표현이 가능한 가장 작은 단위의 메모리.
내가 접근하고 데이터를 저장하는 단위의 작은 메모리.

그게 어떤 기기냐에 따라서 1 바이트일 수도 있고, 어떤 기기는 2 바이트에 저장을 할 수도 있다.

여기서 말하는 2바이트는 일반적으로 얘기하는 8비트.
8비트로 저장할 수도 있고 16비트로 저장할 수도 있다.

***이게 char라는 자료형이다. 그럼 C언어에서의 바이트라고 하는 개념은 char의 크기이다.***


-> 컴퓨터의 가장 적게 저장할 수 있는 단위. 지금 사용하고 있는 기기에, 그 단위가 2바이트라면 실제 16비트라면 그 16비트를 1바이트로 한다.

즉, char 사이즈 1바이트. 그게 C표준이 말하는 것. 위에서 계속 8비트, 8비트 적었는데. 비트는 바뀌지 않기 때문. 그래서 비트로 얘기했다.

결국 소형기기에 따라, 구조를 어떻게 잡았냐에 따라, 기계가 어떻게 되어있는지에 따라 기본적으로 저장소는 단위가 다를 수 있다.

하드웨어 설계자의 마음대로이기 때문에, C는 과거에 많은 하드웨어에 쓰였던 것. 그 하드웨어가 지금도 많이 쓰이기 떄문에

8비트 = 1바이트로 굳어졌다.

생각해야 될 건 그 **바이트는 char의 크기이다.**


<br>

----


#### char과 signed/unsigned

- 정수형이니 signed(부호 있음)와 unsigned(부호 없음)가 있음.
- signed/unsigned 를 생략하면?
- signed이라고 보통 생각 (왜? 보통 정수형은 다 그러기 때문)
- 그럼 unsigned 인가? -> ㄴㄴ
- C 표준은 그런걸 정하지 않았다.
- 컴파일러 구현 따라 정해짐.
  - 어디서는 signed, 어디서는 unsigned(clang으로 윈도우에서 확인해보면 signed 출력)
  - clang window에서는 signed.
  - char sign_test = 255;
    - 주고 -1을 확인해보면 signed가 나온다.

<br>
---------

#### char의 기본 부호가 지정 안 된 이유?


- 아스키의 범위는 0~127 이므로 부호 여부는 상관이 없음.
  - 기본 부호 지정 안 된 이유는 char를 아스키 char만 사용한다고 가정하면 부호는 상관이 없음.  그게 0이든 1이든 간에 뒤에는 0,1 쓸 일이 없으니까  아예 첫 번째 비트, 최상위 비트 쓸 일이 없고 하위 일곱 비트만 쓰니까 상관이 없음


- 단, 8비트 정수형으로 쓰려고 할 때는  반드시 char 앞에 signed나 unsigned를 붙이는 게 좋음.  

- 즉, 정수형 쓸 때는 컴파일러에 따라 자기 마음대로 선택이 가능하다.

- 이걸 글자를 표현하는게 아니라 숫자를 표현하기 위해 C언어에서 쓴다면, signed, unsigned를 둘다 명시적으로 써 줘야한다.

- 무시하고 그냥 char a;  이런식으로 쓰면? => 포팅이라는게 이걸 가져다가  다른 컴파일러에 컴파일 해서 다른 플랫폼(기계와 운영체제 합쳐둔걸 플랫폼이라고 여기서는 일단 지칭하자) 에서 돌게하려면? => 아무 문제 없이 코드 작성하려면 7비트에서 표현가능한거로 끝이 나야한다.

그것은 마지막 비트 7비트, 최상위 비트 뺀 최하위 7비트.
0~127밖에 안됨. 이 사이에서만 포팅시 문제가 안나고 이 이상 가려면 signed, unsigned를 다 지정해야 한다.

```
signed char signed_char = -1;
unsigned char unsigned_char = 255;
```

안 그러면 포팅해도 문제 없는 정수 범위는 0~127 뿐.
- 0000 0000(2) ~ 0111 1111(2)



<br>

-----


#### char의 부호를 판단하는 방법

limit.h의 헤더파일에서 CHAR_MIN을 보면

부호 식별자가 없는 char가 signed인지 unsigned인지 알 수 있음.


<br>
-----


#### char로 표현 가능한 숫자의 범위


###### 포팅 문제 없는 범위


|unsigned char|char|signed char|
|------|---|---|
|0~255|0~127|-127~127|



왜 -128이 아니라 -127일까?
2의 보수와 1의 보수가 있는데 2의 보수는 0이 하나.
근데 1의 보수는 -0, +0이 존재한다.(즉 0이 2개 가진 셈.)

만약 2의 보수를 기준으로 짰는데 1의 보수를 가진 컴파일러를  가진 기계나 OS를 만났다.

그럼 -128이 없어진다. 그렇기 때문에 1의 보수를 표준으로 본다(아주아주 옛날기계면 1의 보수 쓸지도).

그래서 일단 표준은 -127~127이 포팅에 문제 없는 범위.

사실 -127~127인 기계는 별로 없으나 혹시라도 만약을 위해 -127~127을 안전한 포팅범위로 설정해둔 것.


-----


#### Char로 표현 가능한 숫자의 범위(보통)

- 표준은 표준. 뭐 일단 이렇게 쓰자의 느낌.
- 실제 보통(일반의 데스크탑 개발시) 안전하게 생각해도 되는 것.
     1. 크기 : 8비트
     2. 부호(unsigned/signed)를 생략할 경우 : signed
    - char  signed_char = -1;
    - 근데 안드로이드 경우 gcc로 컴파일 해보면 unsigned 나옴. 🤔 뭐 그렇다고.
     3. 범위
    - 부호 없는 경우 (unsigned char): 0~255;
    - 부호 있는 경우 (signed char): -128~127;

<!--
----

test)
C 표준에 따르면 char 형의 크기는?

다음 중 signed/unsigned가 생략된 char 형에 대해 옳은 설명을 고르세요.
- 1. C 표준에 따르면 unsigned이다
- 2. C 표준에 따르면 signed이다.
- 3. char형을 사용시 unsigned/signed를 생략할 수 없으며 무조건 명시해야 한다.
- 4. C 표준은 signed/unsigned가 생략된 char형이 signed인지, unsigned인지 정의 안했지만 , 보통 컴파일러가 unsigned로 정의한다.
- 5. C 표준은 igned/unsigned가 생략된 char형이 signed인지, unsigned인지 정의하지 않으며 , 보통 컴파일러 구현에 따라 달라진다.
 -->

<br>

--------


### short

```
short num = -30000; /* 기본 : signed */
unsigned short unsigned_short = 65535;
signed short signed_short = -32767;
```

- 최소 16비트이고, char의 크기 이상인 정수형.(char가 몇비트든 최소 16비트는 되어야 함)
- 포팅 문제 없는 값의 범위
  - 부호 없는 short(unsigned short): 0~ 65535
  - 부호 있는 short(short, signed short): -32767~32767


<br>

-----


### int

```
int num = -32767 /* 기본: signed */
unsigned int unsigned_int = 65535;
signed int signed_int = -32767
```


***표준에 따르면 최소 16비트 그리고 short 이상인 정수형***

왜 16비트? short와 길이가 같은데?




<br>

------

#### int는 기본 정수

- ***int*** 는 그냥 정수라는 의미.

- 따라서 앞 뒤 생략하 정수 처리하라고 하면 CPU는 딱 맞는 크기여야 한다.

- 그게 무엇의 크기인가.
  - CPU의 산술 논리 장치 (ALU, Arimetic Logic Unit) 가 사용하는 기본 데이터
  - 이 데이터를 워드(word)라 하고, 그 크기를 워드 크기라고 함.
  - 워드 크기는 레지스터 크기랑 일치.

- 즉, CPU 따라 다름.
- 예전엔 16비트 CPU가 많았음 -> 그래서 최소 16비트

<br>

------

#### int 와 64bit 플랫폼

- 그 이후 32비트가 나오면서 int의 크기는 32비트가 됨.
- 그러나 이제 64비트 컴퓨터인데? 그래도 32비트로 머묾.
  - 원칙적으로는 C 표준을 어긴 것.(원칙적으로는 C표준은 CPU가 이해하는 사이즈이므로)
    - 그러나 64비트로 올리면 32비트 정수를 어떻게 쓰지? 또 32비트로 알고 그렇게 작성된 코드들도 어어마 무시하게 많다.  그걸 올리면 망가질 코드들이 너무 많다. 그래서 int 32비트라고 무조건 쓰게된 것.
    - 너무 오랫동안 32비트를 int 크기로 사용

  - 32비트에서 64비트로 바꾼다고 성능이 무조건 빨라지지도 않음.(이유: 캐시 메모리 등). 빨라질 수도 있고 그대로일 수 도 있다는 점.
    - 64 비트가 필요할 경우에만

    - 32비트 쓰다가 크기 큰 용량 같은 경우들에만 64비트 사용.
  - 'int'를 64비트로 올리면? short는 32비트가 되나?


<br>

-----


#### int로 표현 가능한 숫자 범위

- 포팅에 안전한 숫자 범위: short와 같음.
- 표준에 상관 없이 보통 안전하게 생각해도 되는 것.
  - 1.
