---
title: "[backend] SpringWeb MVC 만들기"
layout: post
subtitle: backend
date: "2021-06-21-04:42:51 +0900"

categories: study
tags: backend
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---


MVC에서 C인 컨트롤러 부분이
FrontConotroller+Pojo로 이루어져 있었다.


이 서블릿도 클래스.


그리고 이 프론트 컨트롤러가 핸들러매핑과 연결되어있었는데 클라이언트 요청에 대한 pojo가 누구인지 찾아주는 역할이 핸들러 매핑.

이 pojo들이 뷰에 경로 리턴.


pojo가 모델과 연결하고 모델이 db와 연결.

그리고 crud 실행.

이 프론트 컨트롤러가 최종적으로 뷰리졸브에서 얻어오고 jsp에 포워딩한다.

pojo는
1. 객체 바인딩
2. next페이지 준다.

이렇게 리턴해주면 뷰리졸버에 리턴하고 객체바인딩한거 읽어와서 준다. 결과를 슬라이드한테 응답한다.

MVC의 C가 이렇게 변형이 되었다.

![20210621_025333](/assets/20210621_025333.png)

이렇게 전체적인 경로


![20210621_030415](/assets/20210621_030415.png)

근데 스프링에선 이 세 기능들을 미리 하는 기능들이 만들어져있다.

]
기존의 MVC가 스프링으로 넘어가면서 인터페이스 안씀.

![20210621_033811](/assets/20210621_033811.png)

인터페이스 써버리 이름이 똑같아지기 떄문에

스프링 부분에선 인터페이스 부분이 없어진다.

인터페이스를 쓰지 않으면서 메서드 이름을 바꿔도 된다.

핸들러 매핑이 사라지고 어떤 요청이 오면 바로 메서드와 연결이 되게 바뀐다.

![20210621_035739](/assets/20210621_035739.png)

어노테이션을 핸들러매핑이 처리함.

핸들러 매핑은 내부적으로 제공해줌.

프론트 컨트롤러는 pojo와 연결 되는데 프론트 컨트롤러도 핸들러 매핑이 없어지므로 pojo와 내부적으로 연결시킬뿐 프론트 컨트롤러도 없어짐.
뷰 리졸버 또한 스프링에서 제공

![20210621_040139](/assets/20210621_040139.png)

스프링은 그냥 멤버 컨트롤러에서 바로 작업하면 된다.


![20210621_041017](/assets/20210621_041017.png)

스프링은 이렇게 다 어노테이션으로 기호가 바뀐다.



pom.xml이 project object model로서 메이븐 툴에서 가장 중요한 파일로 이게 있어야 설정파일이 다 들어있어서 이걸 기반으로 돌게 된다.

얘로 할수 있는 가장 중요한 것중 하나가 라이브러리 관리이다.ㄴ


![20210621_042917](/assets/20210621_042917.png)

Dependency로 의존하고 자바에서 이런 api를 쓰고싶다는 걸 pom.xml로 적어주면 이 api가 자동으로 다운로드가 된다.

mvnrepository 여기 저장소가 있는데 다운이 된다.


-------


우리가 기존 mvc에서 프론트 컨트롤러로 했지만 스프링은 대신 DispatcherServlet으로 만들어져있다. 이걸 정의해놓은 파일이 xml파일이고 이걸 리딩해서 사전에 작업하게 된다.

root-context파일은 가장 먼저 실행된다.

이 파일을 읽어들여서 이 xml파일 안에 있는 내용 읽음.

![20210621_092335](/assets/20210621_092335.png)


spring이 mybatis연결하고 mybatis가 jdbc연결

root-context.xml에서 디비설정을 한다.


![20210621_095104](/assets/20210621_095104.png)

스프링은 클래스 설정할 떄 bean으로 설정한다.
A class 설정할때
1) A a = new A(); 또는
2) xml-> <bean id = "a" class="A/>이런식으로 만든다.
이런게 리플렉션 기법임.
어떤 클래스 이름만 알면 객체를 내부적으로 생성이 가능.

이 xml에다가 db.properties 파일 연결하도록 bean으로 만들어 둠.

속성이 location인데 이 값을 집어넣으라는 뜻.

![20210621_095756](/assets/20210621_095756.png)

set메서드 setLocations()안에 ()안에 저 value값을 넣어라.

이 설정 정보를 가지게 됨.


파일 associations가 어떤 에디터와 연결이 되어있는지 본다.

이 xml 클릭하고 default를 누르면 딱 바뀜.


mybatis SqlsessionFactory로 커넥션 풀을 만들어낸다.

------

스프링 컨테이너?

스프링은 모든 객체를 컨테이너가 관리한다.

객체를 관리하는 메모리 공간이 컨테이너이다.

스프링의 특징으로 또 A라는 클래스와 B라는 클래가 있는데 A가 B에 객체를 생성해야 한다.

B b= new B();

A안에서 객체를 생성해서 이 객체를 가지고 이  B클래스를 한다.

A와 B가 서로 의존 관계라 부른다.

A가 B가 필요하니까 생성했을것이므로

의존관계가 상당히 문제점이 있다.

스프링은 이 의존관계를 느슨하게 하는 기법이 있는데 이게 DI 기법이다.

스프링에서 가장 중요하게 하는 기법이 DI기법이다.

![20210621_104401](/assets/20210621_104401.png)

![20210621_105446](/assets/20210621_105446.png)

![20210621_110514](/assets/20210621_110514.png)

![20210621_110735](/assets/20210621_110735.png)


![20210621_111024](/assets/20210621_111024.png)

![20210621_113046](/assets/20210621_113046.png)


window=file=preferences=fileassociations 가서 설정editoreselection에서 spring properties editor를 설정한다.

@Autowired나 @Injection으로 자동 주입.

스프링 컨테이너에 가서 memberDAO찾고 변수에 연결.
