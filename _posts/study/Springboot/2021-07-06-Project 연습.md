---
title: "[Springboot] Project 연습"
layout: post
subtitle: Springboot
date: "2021-07-06-04:58:53 +0900"
categories: study
tags: Springboot
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---


### yml파일 이해하기

음료 공장 만드는 기술자.

1. 두번째 공장
2. 공장 입구는 서쪽
3. 음료요청은 전부 한글 문서로 변경해서 받는다.
4. 음료는 전부 콜라로 만들어서 출시된다.
5. 음료 창고는 컨테이너 박스를 사용한다.
6. 음료는 요청에 따라 페트,캔, 병으로 출시된다.
7. 공장이 재 가동시 기존에 만들어진 음료는 버리지 않는다.
8. 음료 요청시 A4용지 2장 이상의 문서는 받지 않는다.
9. 음료 요청은 아무나 할 수 없다. 암호 아는 사람만 요청한다.


yml은 스프링부트로 공장을 만들건데 그 공장을 만들기 위한 문서이다.


뷰 리졸버 설정

![20210706_020842](/assets/20210706_020842.png)

port-8080 = 입구 부분

![20210706_022539](/assets/20210706_022539.png)

결국 yml은 스프링이라는 성을 어떻게 구성할지 정하는게 yml(properties도 마찬가지.)

----------

### 컨트롤러란?(FrontController와 Dispatcher)
1. 요청을 할 때마다 java 파일이 호출된다.
2. 요청의 종류가 3개면 3개의 Java파일이 존재한다.
3. 하나의 Java파일에서 모든 요청을 받는 FrontController 사용
4. 너무 많은 요청이 한 곳으로 모이는 것을 위해 도메인 별로 분기
5. 분기의 일은 Dispatcher가 해준다.



로그인 요청과 회원가입, 게시글 처리를 FrontController에서 하나의 컨트롤러에서 처리 가능.
근데 너무 많은 요청이 한 곳으로 모이게 된다.


##### 도메인이란
이 세상에 남자 여자만 있다 이런 범주를 주는게 도메인이다.

로그인 , 회원가입은 UserController,
글쓰기 삭제, 구정 등 글 관련은 BoardController에서 처리하겠다.
상품 등록 ,목록, 보기 등은 ProductController에서 처리하겠다.

이런식으로 적당한 양이 쌓이게 된다.

![20210706_024016](/assets/20210706_024016.png)

여기서 문제는 로그인이 올떄 이런 요청이 들어올 때 이 요청들을 어디에 보내야 될지 분기가 필요한데 그게 Dispatcher가 한다.(정확히는 ServletDispatcher, RequestDispatcher라고도 한다.)

이 Dispatcher로 분기를 시킨다.

스프링 프레임워크는 이미 만들어져 있고(디스패쳐가) 컨트롤러도 미리 만들어져서 편하게 사용가능.

우리가 만들어야 되는건 컨트롤러만 만들면 된다.

![20210706_024400](/assets/20210706_024400.png)

컨트롤러를 잘 만들면 요청에 대한 처리가 다 가능하다.

----------

### HTTP 4가지 요청 방식

클라이언트가 웹 서버에 요청,
웹서버는 DB에 Select, Insert, Update, Delete 요청을 해서 응답

![20210706_025641](/assets/20210706_025641.png)


get 요청해서 웹서버로 보내면 웹 서버는 select 해서 db로 요청한다( 웹서버가 데이터를 들고 있지는 않기 때문)
그럼 디비가 응답하고 웹서버가 클라이언트로 응답한다.

브라우저는 .html로 이해해서 브라우저는 이해하지만

핸드폰으로 응답되면 망함(핸드폰은 html을 이해 못함)
.html이 파일이 아니라 문자열(데이터) 응답할 때 쿼리에 대한 결과를 레코드라 하고 웹서버(클라이언트)




이 4가지만 알면 거의 다 컨트롤 하고 만들 수 있다.

post,put은 꼭 기억해야되는게 http에 Body가 필요하다.
Body엔 데이터를 담아야 하고 어떤 데이터를 전송해야되는데 그게 Body에 담김, put도 수정해야되서 그 수정정보가 body에 담


![20210706_033521](/assets/20210706_033521.png)


 이걸 이렇게 받게 된다.(바꿔서)

 ![20210706_033838](/assets/20210706_033838.png)


 ------------


### Http 쿼리 스트링(QueryString),  주소 변수 매핑(path variable) (실습)

1. 구체적인 데이터 요청 시에 쿼리스트링이나 주소변수 매핑이 필요하다.

2. 스프링 부트에서는 주소변수 매핑을 주로 사용한다. 훨씬 편리하다.

어떤 구체적으로 전달하는 방식으로는

![20210706_120245](/assets/20210706_120245.png)

1. 쿼리스트링 방식과


![20210706_120350](/assets/20210706_120350_rmgy7szlk.png)

2. PathVariable 방식이 있다.

이 중 좀 더 보기 좋고 간편한 게 PathVariable 방식이다.

![20210706_123834](/assets/20210706_123834.png)

스프링 부트는 쿼리스트링 보다 PathVariable 방식을 더 많이 쓴다.


-----


### http body 데이터 전송하기

- http header의 Content-Type이해

- 스프링 부트는 기본적으로 x-www-form-urlencoded 타입을 파싱(분석)해준다.
- x-www-form-urlencoded
- plain/text
- application/json


여기서 쌀을 바디 데이터, 그리고 문서를 헤더 데이터

쌀이라 적혀있으면 좀 그래서 헤더 분석해보자.

헤더의 문서에 여러개가 있다.


![20210706_131521](/assets/20210706_131521.png)



```
package com.cos.controllerdemo.web;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import com.cos.controllerdemo.domain.User;

@RestController
public class HttpBodyController {



	private static final Logger log = LoggerFactory.getLogger(HttpBodyController.class);

	@PostMapping("/body1")
	public String xwwwformformuerlencoded(String username) {
		log.info(username);
		return "key=value 전송옴 ";
	}


	@PostMapping("/body2")
	public String plaintext(@RequestBody String data) 	{	//평문: 안녕
		log.info(data);
		return "plain/text 전송옴";
	}

	@PostMapping("/body3")
	public String applicationjson(@RequestBody String data) {
		log.info(data);
		return "json 전송옴";
	}

	@PostMapping("/body4") //오브젝트로 바로 받음.
	public String applicationtoObject(@RequestBody User user) {
		log.info(user.getUsername());
		return "json 전송옴";
	}
}



```


![20210706_141244](/assets/20210706_141244.png)

![20210706_141236](/assets/20210706_141236.png)

---


### Http 요청을 json으로 응답하기


예제


```
package com.cos.controllerdemo.web;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HttpResponseJsonController {
	@GetMapping("/resp/json")
		public String respJson() {
			return "{\"username\":\"cos\"}";
	}
}


```



![20210706_141723](/assets/20210706_141723.png)



![20210706_142141](/assets/20210706_142141.png)

이런 경우도 있따. user오브젝트를 리턴했는데 문자열이 나옴.



여기서 원리는 user 오브젝트 리턴하고 싶은데 일일히 데이터를 뺴와서 데이터를 만들어서 리턴.

근데 아래 유저를 그대로 리턴. 리턴이 되면서 클라이언트 웹 브라우저로 통신이 됨(위의 일이 자동으로 일어남.)




그 과정을 MessageConverter가 자동으로 JavaObject를 Json으로 변경해서 통신을 통해 응답을 해준다.

----


### HTML응답

###### http 요청을 file로 응답하기
1. txt파일 응답하기(기본 경로는 resource/static)
2. 스프링부트가 지원하는 .mustache파일 응답하기
3. 스프링부트가 버린 .jsp파일 응답하기

.jsp와 .mustache파일은 템플릿 엔진을 가지고 있다.

템플릿 엔진이란 html 파일에 java코드를 쓸 수 있는 친구들이다.


![20210706_152105](/assets/20210706_152105.png)

이렇게 쓰라고요청하는게 아님(위 기준)



jsp라 치면 client라 하고 요청 .jsp 준다.

브라우저가 자바 코드 이해 못할 텐데?
얘를 누구한테 던지냐면 웹 서버가 톰캣이라는 WAS에 던진다. 이 어플리케이션을(아파치) 쓰는데


![20210706_152350](/assets/20210706_152350.png)

index.jsp에서 자바코드 해석해서 index.html파일로 만든다.


![20210706_152444](/assets/20210706_152444.png)

이렇게 자바코드 해석해서 html 파일 만드는게 템플릿 엔진이라고 한다.

.jsp파일을 스프링부트가 버리긴 했지만 아직까진 대한민국에선 jsp 많이 쓴다.(mustache파일은 하루면 된다.)


```
package com.cos.controllerdemo.web;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller //파일을 리턴할 것이기 때문
public class HttpRespController {
	@GetMapping("/txt")
	public String txt() {
		return "a.txt";	//프레임워크 사용(틀이 이미 정해져 있음)
	}
}


```

localhost:8080/txt 주소창 쳐보면 파일 리턴도 된다.


2. mustache파일도 리턴해보자.

![20210706_153116](/assets/20210706_153116.png)

mvnRepository에서 다운이 필요하다.


![20210706_153733](/assets/20210706_153733.png)

스프링에서 쓰는 mustache 검색 후 제일 최신버전 받아서 쓰자.

![20210706_154749](/assets/20210706_154749.png)

이동이 아니라 다운로드를 받음?
mustache를 스프링에서 인식 못해서


즉 웹 서버가 mustache를 응답해야되는데

![20210706_154916](/assets/20210706_154916.png)

이 톰캣부분에서 응답을 안한 것이다.


```
@GetMapping("/mus")
	public String mus() { 	//2.mustache 파일 응답하기(기본 경로는 resource/static)

		return "b";	//머스테치 템플릿 엔진 라이브러리 등록 완료 - templates폴더 안에 .mustache놔두면 확장자 없이 자동으로 찾아감.
	}

```


![20210706_155132](/assets/20210706_155132.png)

사람들이 많이 받은 9.0.41로 받고 사용하자

![20210706_155221](/assets/20210706_155221.png)

![20210706_155550](/assets/20210706_155550.png)


![20210706_155807](/assets/20210706_155807.png)

여기서 jsp 설정하면 경로가 안 뜸(스프링 부트가 지원 안해서)

application.properties를 yml로 바꾸자.


![20210706_160621](/assets/20210706_160621.png)

이 부분을 ViewResolver라고 한다.

-----




### JSP 파일에 JAVA 코드 사용해보기


- Java 코드 사용
- model 사용


![20210706_174757](/assets/20210706_174757.png)


이렇게 html 페이지로 model을 통해 자바코드를 전달할 수 있다.

그 이유는 jsp가 템플릿 엔진이기 떄문이다.

---------


### Http 요청 재분배하기 - redirection

- http 상태코드 300번대
- 다른 주소로 요청을 재분배한다.

![20210706_182321](/assets/20210706_182321.png)


![20210706_183309](/assets/20210706_183309.png)

여기서 /away로 실행하면

![20210706_183442](/assets/20210706_183442.png)

![20210706_183455](/assets/20210706_183455.png)

이렇게 home으로 가게되고 away,home 2개가 생기는데 home 부분에 200이 뜬다.

이게 리다이렉션(/away로 줬는데 home으로 이동)

더 자세한건 http상태코드를 보자


https://developer.mozilla.org/ko/docs/Web/HTTP/Status


-------


### 회원가입 - SecurityConfig 생성


![20210706_194121](/assets/20210706_194121.png)


localhost:8080갔는데 login 부분으로 간다 왜?


```

<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
```

이 pom.xml에 있는 security dependency 부분에 인증이 되지 않은 모든 사용자를 가로채서 redirection해서 주소요청을 변경해서 다른 주소로 보냄.

![20210706_194728](/assets/20210706_194728.png)

status가 302면 redirection되서 login 페이지가 뜸.

우리가 만든 로그인으로 가고싶다.



```
package config;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@EnableWebSecurity //해당 파일로 시큐리티를 활성화
@Configuration //IOC 등록
public class SecurityConfig extends WebSecurityConfigurerAdapter{
		@Override
		protected void configure(HttpSecurity http) throws Exception {

//			super.configure(http);	//얘가 실행되서 리다이렉션가로챈다 tkrwpgkwk
//			얘를 삭제하면 기존 시큐리티가 가진 기능이 다 비활성화 된다.

		}
}

```

에서 저 super.configure 부분에서 낚아채서 리다이렉션 됐던것.

저 부분을 지워야한다.


![20210706_200125](/assets/20210706_200125.png)

이제 리다이렉션이 안된다.



"/","/user/**", "/image/**", "/subscribe/**","/comment/**

이런 구조로 지정하게 되면 인증이 필요하게 만든다.



![20210706_205649](/assets/20210706_205649.png)

300번대가 뜨면 요청 재분배가 되었다고 생각하면 된다.



-----


### CSRF

##### 인증 구현하기


- 시큐리티 세팅
- 회원가입 구현
- 로그인 구현
- 회원정보 수정 구현


 insert 하기 위해선 post 요청


![20210706_222033](/assets/20210706_222033.png)

 ```
 //회원가입 버튼 -> /auth/signup->auth/signin
 	//회원가입 버튼 클릭했는데 아무것도 안되었네?
 	//form 로그인 할 때 저기 보면 csrf토큰이라는 게 활성화되어있기 떄문.
 	@PostMapping("/auth/signup")
 	public String signup() {	//실제 signup
 		System.out.println("실행됨?");
 		return "auth/signin";	//회원가입이 성공하면 로그인으로 가게 한다.
 	}

 ```


##### CSRF 토큰

클라이언트가 서버에 전송하는데 서버가 받기전 시큐리티가 감싸고 있고 CSRF라는 토큰을 검사를 한다.

CSFR는

회원가입창으로 서버에 요청하는데 회원가입 페이지로 응답한다.

signup.jsp응답할 때 시큐리티가 토큰을 심는다.
CSRF 토큰을 심고 돌려주는데 input 태그들에 임시의 난수값이 생김.

![20210706_223149](/assets/20210706_223149.png)

![20210706_223244](/assets/20210706_223244.png)

만약 kfc를 보낸다 치면 시큐리티가 이런 내용을 달아서 전달해준다.

이 상태에서 다시 요청을 하면 얘가 만든 csrf 토큰이 있는지를 확인한다.



post맨을 열어서

![20210706_223349](/assets/20210706_223349.png)

이렇게 요청하거나(비정상적)

![20210706_223509](/assets/20210706_223509.png)

회원가입 페이지를 요청하는 사람이 있을건데(정상적)
이걸 구분하기 위해 csrf를 사용


근데 이걸 쓰면 자바스크립트로 요청하는 것도 힘들고
비활성화 시켜서 시큐리티에서 안 쓸거


(참고)

```
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
//@Controller
public class ViewControllerTest {

	@GetMapping("/auth/signup")
	public String signupPage() {
		return "auth/signup";
	}

	@GetMapping("/auth/signin")
	public String signinPage() {
		return "auth/signin";
	}

	@GetMapping("/image/story")
	public String storyPage() {
		return "image/story";
	}

	@GetMapping("/image/popular")
	public String popularPage() {
		return "image/popular";
	}

	@GetMapping("/image/upload")
```

여기서 ViewControllerTest한다고 컨트롤러 했었었는데 여기를 주석처리 안하고 계속 post요청하니까 요청을 컨트롤러가 못 잡았다.

컨트롤러 주석처리하고

```
package com.cos.photogramstart.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@EnableWebSecurity //해당 파일로 시큐리티를 활성화

@Configuration //IOC 등록
public class SecurityConfig extends WebSecurityConfigurerAdapter{
		@Override
		protected void configure(HttpSecurity http) throws Exception {


			http.csrf().disable();	//시큐리티의 csrf를 사용하지 않음. 그럼 포스트맨에든 회원가입 창이든 어디서 해도 상관 안하겠다(403 안뜸)
//			super.configure(http);	//얘가 실행되서 리다이렉션가로챈다 삭제하자

//			얘를 삭제하면 기존 시큐리티가 가진 기능이 다 비활성화 된다.
			http.authorizeRequests()
			.antMatchers("/","/user/**", "/image/**", "/subscribe/**","/comment/**").authenticated()
			.anyRequest().permitAll()
			//"/","/user/**", "/image/**", "/subscribe/**","/comment/** 이런 구조로 지정하게 되면 인증이 필요하게 만든다.
			.and()
			.formLogin()	//form login 할텐데 auth의 sigin이 하면 이쪽으로 가게
			.loginPage("/auth/signin")
			.defaultSuccessUrl("/");	//로그인을 정상처리하면 /로 가라
		}
}


```

이부분 다시 컨트롤러 넣고 실행하면 정상 작동이 된다.


------
