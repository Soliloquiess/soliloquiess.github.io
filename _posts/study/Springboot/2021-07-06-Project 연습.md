---
title: "[Springboot] Project 연습"
layout: post
subtitle: Springboot
date: "2021-07-06-04:58:53 +0900"
categories: study
tags: Springboot
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---


### yml파일 이해하기

음료 공장 만드는 기술자.

1. 두번째 공장
2. 공장 입구는 서쪽
3. 음료요청은 전부 한글 문서로 변경해서 받는다.
4. 음료는 전부 콜라로 만들어서 출시된다.
5. 음료 창고는 컨테이너 박스를 사용한다.
6. 음료는 요청에 따라 페트,캔, 병으로 출시된다.
7. 공장이 재 가동시 기존에 만들어진 음료는 버리지 않는다.
8. 음료 요청시 A4용지 2장 이상의 문서는 받지 않는다.
9. 음료 요청은 아무나 할 수 없다. 암호 아는 사람만 요청한다.


yml은 스프링부트로 공장을 만들건데 그 공장을 만들기 위한 문서이다.


뷰 리졸버 설정

![20210706_020842](/assets/20210706_020842.png)

port-8080 = 입구 부분

![20210706_022539](/assets/20210706_022539.png)

결국 yml은 스프링이라는 성을 어떻게 구성할지 정하는게 yml(properties도 마찬가지.)

----------

### 컨트롤러란?(FrontController와 Dispatcher)
1. 요청을 할 때마다 java 파일이 호출된다.
2. 요청의 종류가 3개면 3개의 Java파일이 존재한다.
3. 하나의 Java파일에서 모든 요청을 받는 FrontController 사용
4. 너무 많은 요청이 한 곳으로 모이는 것을 위해 도메인 별로 분기
5. 분기의 일은 Dispatcher가 해준다.



로그인 요청과 회원가입, 게시글 처리를 FrontController에서 하나의 컨트롤러에서 처리 가능.
근데 너무 많은 요청이 한 곳으로 모이게 된다.


##### 도메인이란
이 세상에 남자 여자만 있다 이런 범주를 주는게 도메인이다.

로그인 , 회원가입은 UserController,
글쓰기 삭제, 구정 등 글 관련은 BoardController에서 처리하겠다.
상품 등록 ,목록, 보기 등은 ProductController에서 처리하겠다.

이런식으로 적당한 양이 쌓이게 된다.

![20210706_024016](/assets/20210706_024016.png)

여기서 문제는 로그인이 올떄 이런 요청이 들어올 때 이 요청들을 어디에 보내야 될지 분기가 필요한데 그게 Dispatcher가 한다.(정확히는 ServletDispatcher, RequestDispatcher라고도 한다.)

이 Dispatcher로 분기를 시킨다.

스프링 프레임워크는 이미 만들어져 있고(디스패쳐가) 컨트롤러도 미리 만들어져서 편하게 사용가능.

우리가 만들어야 되는건 컨트롤러만 만들면 된다.

![20210706_024400](/assets/20210706_024400.png)

컨트롤러를 잘 만들면 요청에 대한 처리가 다 가능하다.

----------

### HTTP 4가지 요청 방식

클라이언트가 웹 서버에 요청,
웹서버는 DB에 Select, Insert, Update, Delete 요청을 해서 응답

![20210706_025641](/assets/20210706_025641.png)


get 요청해서 웹서버로 보내면 웹 서버는 select 해서 db로 요청한다( 웹서버가 데이터를 들고 있지는 않기 때문)
그럼 디비가 응답하고 웹서버가 클라이언트로 응답한다.

브라우저는 .html로 이해해서 브라우저는 이해하지만

핸드폰으로 응답되면 망함(핸드폰은 html을 이해 못함)
.html이 파일이 아니라 문자열(데이터) 응답할 때 쿼리에 대한 결과를 레코드라 하고 웹서버(클라이언트)




이 4가지만 알면 거의 다 컨트롤 하고 만들 수 있다.

post,put은 꼭 기억해야되는게 http에 Body가 필요하다.
Body엔 데이터를 담아야 하고 어떤 데이터를 전송해야되는데 그게 Body에 담김, put도 수정해야되서 그 수정정보가 body에 담


![20210706_033521](/assets/20210706_033521.png)


 이걸 이렇게 받게 된다.(바꿔서)

 ![20210706_033838](/assets/20210706_033838.png)


 ------------


### Http 쿼리 스트링(QueryString),  주소 변수 매핑(path variable) (실습)

1. 구체적인 데이터 요청 시에 쿼리스트링이나 주소변수 매핑이 필요하다.

2. 스프링 부트에서는 주소변수 매핑을 주로 사용한다. 훨씬 편리하다.

어떤 구체적으로 전달하는 방식으로는

![20210706_120245](/assets/20210706_120245.png)

1. 쿼리스트링 방식과


![20210706_120350](/assets/20210706_120350_rmgy7szlk.png)

2. PathVariable 방식이 있다.

이 중 좀 더 보기 좋고 간편한 게 PathVariable 방식이다.

![20210706_123834](/assets/20210706_123834.png)

스프링 부트는 쿼리스트링 보다 PathVariable 방식을 더 많이 쓴다.


-----


### http body 데이터 전송하기

- http header의 Content-Type이해

- 스프링 부트는 기본적으로 x-www-form-urlencoded 타입을 파싱(분석)해준다.
- x-www-form-urlencoded
- plain/text
- application/json


여기서 쌀을 바디 데이터, 그리고 문서를 헤더 데이터

쌀이라 적혀있으면 좀 그래서 헤더 분석해보자.

헤더의 문서에 여러개가 있다.


![20210706_131521](/assets/20210706_131521.png)



```
package com.cos.controllerdemo.web;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import com.cos.controllerdemo.domain.User;

@RestController
public class HttpBodyController {



	private static final Logger log = LoggerFactory.getLogger(HttpBodyController.class);

	@PostMapping("/body1")
	public String xwwwformformuerlencoded(String username) {
		log.info(username);
		return "key=value 전송옴 ";
	}


	@PostMapping("/body2")
	public String plaintext(@RequestBody String data) 	{	//평문: 안녕
		log.info(data);
		return "plain/text 전송옴";
	}

	@PostMapping("/body3")
	public String applicationjson(@RequestBody String data) {
		log.info(data);
		return "json 전송옴";
	}

	@PostMapping("/body4") //오브젝트로 바로 받음.
	public String applicationtoObject(@RequestBody User user) {
		log.info(user.getUsername());
		return "json 전송옴";
	}
}



```


![20210706_141244](/assets/20210706_141244.png)

![20210706_141236](/assets/20210706_141236.png)

---


### Http 요청을 json으로 응답하기


예제


```
package com.cos.controllerdemo.web;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HttpResponseJsonController {
	@GetMapping("/resp/json")
		public String respJson() {
			return "{\"username\":\"cos\"}";
	}
}


```



![20210706_141723](/assets/20210706_141723.png)



![20210706_142141](/assets/20210706_142141.png)

이런 경우도 있따. user오브젝트를 리턴했는데 문자열이 나옴.



여기서 원리는 user 오브젝트 리턴하고 싶은데 일일히 데이터를 뺴와서 데이터를 만들어서 리턴.

근데 아래 유저를 그대로 리턴. 리턴이 되면서 클라이언트 웹 브라우저로 통신이 됨(위의 일이 자동으로 일어남.)




그 과정을 MessageConverter가 자동으로 JavaObject를 Json으로 변경해서 통신을 통해 응답을 해준다.

----


### HTML응답

###### http 요청을 file로 응답하기
1. txt파일 응답하기(기본 경로는 resource/static)
2. 스프링부트가 지원하는 .mustache파일 응답하기
3. 스프링부트가 버린 .jsp파일 응답하기

.jsp와 .mustache파일은 템플릿 엔진을 가지고 있다.

템플릿 엔진이란 html 파일에 java코드를 쓸 수 있는 친구들이다.


![20210706_152105](/assets/20210706_152105.png)

이렇게 쓰라고요청하는게 아님(위 기준)



jsp라 치면 client라 하고 요청 .jsp 준다.

브라우저가 자바 코드 이해 못할 텐데?
얘를 누구한테 던지냐면 웹 서버가 톰캣이라는 WAS에 던진다. 이 어플리케이션을(아파치) 쓰는데


![20210706_152350](/assets/20210706_152350.png)

index.jsp에서 자바코드 해석해서 index.html파일로 만든다.


![20210706_152444](/assets/20210706_152444.png)

이렇게 자바코드 해석해서 html 파일 만드는게 템플릿 엔진이라고 한다.

.jsp파일을 스프링부트가 버리긴 했지만 아직까진 대한민국에선 jsp 많이 쓴다.(mustache파일은 하루면 된다.)


```
package com.cos.controllerdemo.web;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller //파일을 리턴할 것이기 때문
public class HttpRespController {
	@GetMapping("/txt")
	public String txt() {
		return "a.txt";	//프레임워크 사용(틀이 이미 정해져 있음)
	}
}


```

localhost:8080/txt 주소창 쳐보면 파일 리턴도 된다.


2. mustache파일도 리턴해보자.

![20210706_153116](/assets/20210706_153116.png)

mvnRepository에서 다운이 필요하다.


![20210706_153733](/assets/20210706_153733.png)

스프링에서 쓰는 mustache 검색 후 제일 최신버전 받아서 쓰자.

![20210706_154749](/assets/20210706_154749.png)

이동이 아니라 다운로드를 받음?
mustache를 스프링에서 인식 못해서


즉 웹 서버가 mustache를 응답해야되는데

![20210706_154916](/assets/20210706_154916.png)

이 톰캣부분에서 응답을 안한 것이다.


```
@GetMapping("/mus")
	public String mus() { 	//2.mustache 파일 응답하기(기본 경로는 resource/static)

		return "b";	//머스테치 템플릿 엔진 라이브러리 등록 완료 - templates폴더 안에 .mustache놔두면 확장자 없이 자동으로 찾아감.
	}

```


![20210706_155132](/assets/20210706_155132.png)

사람들이 많이 받은 9.0.41로 받고 사용하자

![20210706_155221](/assets/20210706_155221.png)

![20210706_155550](/assets/20210706_155550.png)


![20210706_155807](/assets/20210706_155807.png)

여기서 jsp 설정하면 경로가 안 뜸(스프링 부트가 지원 안해서)

application.properties를 yml로 바꾸자.


![20210706_160621](/assets/20210706_160621.png)

이 부분을 ViewResolver라고 한다.

-----




### JSP 파일에 JAVA 코드 사용해보기


- Java 코드 사용
- model 사용


![20210706_174757](/assets/20210706_174757.png)


이렇게 html 페이지로 model을 통해 자바코드를 전달할 수 있다.

그 이유는 jsp가 템플릿 엔진이기 떄문이다.

---------


### Http 요청 재분배하기 - redirection

- http 상태코드 300번대
- 다른 주소로 요청을 재분배한다.

![20210706_182321](/assets/20210706_182321.png)


![20210706_183309](/assets/20210706_183309.png)

여기서 /away로 실행하면

![20210706_183442](/assets/20210706_183442.png)

![20210706_183455](/assets/20210706_183455.png)

이렇게 home으로 가게되고 away,home 2개가 생기는데 home 부분에 200이 뜬다.

이게 리다이렉션(/away로 줬는데 home으로 이동)

더 자세한건 http상태코드를 보자


https://developer.mozilla.org/ko/docs/Web/HTTP/Status


-------


### 회원가입 - SecurityConfig 생성


![20210706_194121](/assets/20210706_194121.png)


localhost:8080갔는데 login 부분으로 간다 왜?


```

<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
```

이 pom.xml에 있는 security dependency 부분에 인증이 되지 않은 모든 사용자를 가로채서 redirection해서 주소요청을 변경해서 다른 주소로 보냄.

![20210706_194728](/assets/20210706_194728.png)

status가 302면 redirection되서 login 페이지가 뜸.

우리가 만든 로그인으로 가고싶다.



```
package config;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@EnableWebSecurity //해당 파일로 시큐리티를 활성화
@Configuration //IOC 등록
public class SecurityConfig extends WebSecurityConfigurerAdapter{
		@Override
		protected void configure(HttpSecurity http) throws Exception {

//			super.configure(http);	//얘가 실행되서 리다이렉션가로챈다 tkrwpgkwk
//			얘를 삭제하면 기존 시큐리티가 가진 기능이 다 비활성화 된다.

		}
}

```

에서 저 super.configure 부분에서 낚아채서 리다이렉션 됐던것.

저 부분을 지워야한다.


![20210706_200125](/assets/20210706_200125.png)

이제 리다이렉션이 안된다.



"/","/user/**", "/image/**", "/subscribe/**","/comment/**

이런 구조로 지정하게 되면 인증이 필요하게 만든다.



![20210706_205649](/assets/20210706_205649.png)

300번대가 뜨면 요청 재분배가 되었다고 생각하면 된다.



-----


### CSRF

##### 인증 구현하기


- 시큐리티 세팅
- 회원가입 구현
- 로그인 구현
- 회원정보 수정 구현


 insert 하기 위해선 post 요청


![20210706_222033](/assets/20210706_222033.png)

 ```
 //회원가입 버튼 -> /auth/signup->auth/signin
 	//회원가입 버튼 클릭했는데 아무것도 안되었네?
 	//form 로그인 할 때 저기 보면 csrf토큰이라는 게 활성화되어있기 떄문.
 	@PostMapping("/auth/signup")
 	public String signup() {	//실제 signup
 		System.out.println("실행됨?");
 		return "auth/signin";	//회원가입이 성공하면 로그인으로 가게 한다.
 	}

 ```


##### CSRF 토큰

클라이언트가 서버에 전송하는데 서버가 받기전 시큐리티가 감싸고 있고 CSRF라는 토큰을 검사를 한다.

CSFR는

회원가입창으로 서버에 요청하는데 회원가입 페이지로 응답한다.

signup.jsp응답할 때 시큐리티가 토큰을 심는다.
CSRF 토큰을 심고 돌려주는데 input 태그들에 임시의 난수값이 생김.

![20210706_223149](/assets/20210706_223149.png)

![20210706_223244](/assets/20210706_223244.png)

만약 kfc를 보낸다 치면 시큐리티가 이런 내용을 달아서 전달해준다.

이 상태에서 다시 요청을 하면 얘가 만든 csrf 토큰이 있는지를 확인한다.



post맨을 열어서

![20210706_223349](/assets/20210706_223349.png)

이렇게 요청하거나(비정상적)

![20210706_223509](/assets/20210706_223509.png)

회원가입 페이지를 요청하는 사람이 있을건데(정상적)
이걸 구분하기 위해 csrf를 사용


근데 이걸 쓰면 자바스크립트로 요청하는 것도 힘들고
비활성화 시켜서 시큐리티에서 안 쓸거


(참고)

```
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
//@Controller
public class ViewControllerTest {

	@GetMapping("/auth/signup")
	public String signupPage() {
		return "auth/signup";
	}

	@GetMapping("/auth/signin")
	public String signinPage() {
		return "auth/signin";
	}

	@GetMapping("/image/story")
	public String storyPage() {
		return "image/story";
	}

	@GetMapping("/image/popular")
	public String popularPage() {
		return "image/popular";
	}

	@GetMapping("/image/upload")
```

여기서 ViewControllerTest한다고 컨트롤러 했었었는데 여기를 주석처리 안하고 계속 post요청하니까 요청을 컨트롤러가 못 잡았다.

컨트롤러 주석처리하고

```
package com.cos.photogramstart.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@EnableWebSecurity //해당 파일로 시큐리티를 활성화

@Configuration //IOC 등록
public class SecurityConfig extends WebSecurityConfigurerAdapter{
		@Override
		protected void configure(HttpSecurity http) throws Exception {


			http.csrf().disable();	//시큐리티의 csrf를 사용하지 않음. 그럼 포스트맨에든 회원가입 창이든 어디서 해도 상관 안하겠다(403 안뜸)
//			super.configure(http);	//얘가 실행되서 리다이렉션가로챈다 삭제하자

//			얘를 삭제하면 기존 시큐리티가 가진 기능이 다 비활성화 된다.
			http.authorizeRequests()
			.antMatchers("/","/user/**", "/image/**", "/subscribe/**","/comment/**").authenticated()
			.anyRequest().permitAll()
			//"/","/user/**", "/image/**", "/subscribe/**","/comment/** 이런 구조로 지정하게 되면 인증이 필요하게 만든다.
			.and()
			.formLogin()	//form login 할텐데 auth의 sigin이 하면 이쪽으로 가게
			.loginPage("/auth/signin")
			.defaultSuccessUrl("/");	//로그인을 정상처리하면 /로 가라
		}
}


```

이부분 다시 컨트롤러 넣고 실행하면 정상 작동이 된다.


------

### User모델 만들기

Singup하는데 요청  DTO와 응답 DTO만들 거
DTO는 통신을 위해 담는 데이터

```
@PostMapping("/auth/signup")
	public String signup(SignupDto signupDto) {	//key =value(x-www-form-urlencoded)방식이라고 했었따.

		log.info(signupDto.toString());	//문자열만 받을 수 있는 toString
		return "auth/signin";
	}
```

이렇게 바꾸고 info를 확인해보면

![20210707_004042](/assets/20210707_004042.png)

잘 넘어온게 확인이 된다.

이제 이걸 디비에 인서트 해야된다.
insert하기위해선 model이 필요하다.
userModel을 만들어보자.


create user 'root'@'%' identified by 'root';
GRANT ALL PRIVILEGES ON *.* TO 'root'@'%';
create database photogram;


자바에서 오브젝트를 만들면 이 오브젝트를 기준으로 테이블이 만들어진다.

![20210707_011729](/assets/20210707_011729.png)


---------

### 회원가입 완료

- User라는 오브젝트에 SignUpDto를 넣을 것.(SignupDto의 4개 값을 User에 집어넣을 거)
-	담을때 DTO에서 함수를 하나 만들어서 전달.

```
public User toEntity() {
		return User.builder() //빌더패턴 사용
				.username(username)
				.password(password)
				.email(email)
				.name(name)
				.build();
	}
```


![20210707_015607](/assets/20210707_015607.png)

받아온 거 잘 넘겼다.

여기서 User에 role은 좀 있다해도 된다.

이걸 DB에 집어넣을건데 집어넣을 때 service가 된다.


그리고 서비스를 만들고 서비스를 쓰기 위해선 Repository를 만들어야 한다.


```

import com.cos.photogramstart.domain.user.User;

@Service	//1. IOC 관리 2.트랜잭션 관리
public class AuthService {

	public void 회원가입(User user) {
		//회원가입 진행(Repository가 필요)


	}
}


```

```
package com.cos.photogramstart.domain.user;

import org.springframework.data.jpa.repository.JpaRepository;

//어노테이션이 없어도 IOC등록이 자동으로 된다.
public interface UserRepository extends JpaRepository<User, Integer>{
	//첫번쨰는 오브젝트를 적어주고 두번쨰는 프라이머리 키의 타입을 적어준다.

}

```
auth서비스를 요청해야되는데 이걸 DI에서 불러와야한다.

![20210707_021130](/assets/20210707_021130.png)

![20210707_021051](/assets/20210707_021051.png)

전역변수에 final걸려있으면 무조건 생성자 실행 될때 초기화를 무적권 해줘야하는데

@RequiredArgsConstructor를 만들면 final이 걸린 모든 객체에 대한 생성자를 만들어준다.
이건 final 필드를 di 할떄 사용한다.

save되면 s타입 리턴한다 s를 집어넣고 (내가넣은 타입) 그 타입으로 리턴받음.



![20210707_023210](/assets/20210707_023210.png)

![20210707_024725](/assets/20210707_024725.png)

실행시 이게 안 들어갔다고 에러가 났었는데

이유는 얘를 만들기 전에 디비에 테이블 만들고 얘를 만들어서 저장함.
그래서 테이블에 저장을 하려면 yml의

![20210707_024810](/assets/20210707_024810.png)

이 부분을 update에서 create로 바꾸고 저장해야한다.
그리고 다시 데이터가 안 사라지게 update로 바꾸고 저장해야 한다.

![20210707_025035](/assets/20210707_025035.png)

insert가 잘 되었다고 나오고 실제 디비에도 보면

![20210707_025126](/assets/20210707_025126.png)

정상적으로 들어간 게 보인다.

여기서 문제는 패스워드가 암호화 되지 않아서 들어갔다고,
권한을 넣어줘야한다(role)


-----  

### 회원가입 - 비밀번호 해시화

@Transactional붙여주면 이 함수가 실행되고 종료될때까지 트랜잭션 관리를 해준다.
Write 할떄 트랜잭션 붙여줄 것(insert, update,delete)


BCrypt를 사용해 암호화 할 거


```
private final UserRepository userRepository;
private final BCryptPasswordEncoder bCryptPasswordEncoder;
@Transactional
//붙여주면 이 함수가 실행되고 종료될때까지 트랜잭션 관리를 해준다.Write 할떄 트랜잭션 붙여줄 것(insert, update,delete)

public User  회원가입(User user) {	//타입도 User로 바꿔야
  //회원가입 진행(Repository가 필요)
  //여기서 받아서 인서트가 필요하고 그게 service 역할
  String rawPassword =user.getPassword();
  String encPassword = bCryptPasswordEncoder.encode(rawPassword);//암호화된 패스워드
  user.setPassword(encPassword);
  user.setRole("Role_User"); //관리자 Role_admin

```

이 부분 서비스에 추가하고 실행해보자

그리고 Securityconfig부분에

```
@Bean
  public BCryptPasswordEncoder encode() {
      return new BCryptPasswordEncoder();
  }

```

이 부분이 없어서 에러났었는데 이 부분도 넣어주자

![20210707_123130](/assets/20210707_123130.png)

회원가입 하면 디비에 들어가고 비밀번호도 알아볼 수 없게 암호화가 잘 되었다.

![20210707_124459](/assets/20210707_124459.png)

근데 아이디와 패스워드, 유저네임 이런게 같으면 중복이라 안되기 떄문에 이거또한 처리해 줘야한다.


![20210707_124146](/assets/20210707_124146.png)



![20210707_130644](/assets/20210707_130644.png)


이부분은 에러가 나는데 유니크한 제약조건을 위배했다고 에러를 뱉는다.(이게 정상)
근데 이렇게 사용자한테 보여줄 수는 없으니까 고쳐야 한다.

---------




### 전처리 후처리 개념잡기

서버가 데이터 받아서 JPA통해 DB에 인서트(기본)

![20210707_142525](/assets/20210707_142525_lda87ojqp.png)

![20210707_142447](/assets/20210707_142447.png)

![20210707_142938](/assets/20210707_142938.png)

이걸 바꾸면 스키마를 바꾼거라(디비 테이블을) 다시 반영해야되서 이걸 create로 해야 적용이 된다.


디비에 물어볼게 있고 안물어 볼게 있는데

1번에서는 유저네임이 동일한지는 판단 못하고 2번에서만 가능하다.

20자 이상인지는 1에서도 가능하다.
그럼 유저네임이 중복되면 로직이


그래서 1번에서 처리가 가능해서 처리하는걸 전처리라 하고 Validation을 이용할것이다

2번에서 하는걸 후처리라 하며, ExceptionHandler를 사용 할 것


-------------


### 유효성 검사하기


![20210707_143956](/assets/20210707_143956.png)
이게 validation cpzmek.

근데 이렇게 하면 굉장히 길어짐


![20210707_144431](/assets/20210707_144431.png)


전처리 하기위해서 startert Validation을 설치하자.(pom.xml)


![20210707_144859](/assets/20210707_144859.png)

![20210707_150149](/assets/20210707_150149.png)

![20210707_150203](/assets/20210707_150203.png)
테이블이 생성되고 notnull이 들어간게 보인다.

-----------------


### @ResponseBody 사용하기


만약 프론트단에서 막아도(localhost:8080/auth/signup)
포스트맨에서 넣을 수도 있는데 이걸 막아야 한다.

![20210707_165809](/assets/20210707_165809.png)


프론트 단에서 막는건

![20210707_170115](/assets/20210707_170115.png)

이렇게 required를 넣어주면 글자를 안 넣을 시 안 넘어가게 된다.


@ResponseBody를 사용하면 컨트롤러지만 데이터를 받을 수 있다.

오류 나면 이제 콘솔이 아닌 페이지로 이동시켜주게 만들 것이다.


```
@PostMapping("/auth/signup")
public @ResponseBody String signup(@Valid SignupDto signupDto, BindingResult bindingResult) {	//key =value(x-www-form-urlencoded)방식이라고 했었따.
  //signupDto에서 오류가 있으면 bindingResult에 다 모아준다.
  //getFieldErrors에 다 모아주고 그걸 errors로 담는다.

  if(bindingResult.hasErrors()) {//에러가 있으면(유저길이가 넘어가거나 빈칸이 있으면
    Map<String, String> errorMap = new HashMap<>();

    for(FieldError error : bindingResult.getFieldErrors()) {
      errorMap.put(error.getField(), error.getDefaultMessage());
    }
    return "오류남";
  }else {
```

---------

### 글로벌 예외처리하기 (Validation 체크)

다시 @ResponseBody를 지우자


전체 예외 처리를 하는 핸들러를 만든다.



```
@ControllerAdvice	//이걸 붙이면 모든 Exception을 다 낚아챈다.

```


![20210707_170724](/assets/20210707_170724.png)
그리고 데이터를 응답하기 위해 RestController 어노테이션 사용


![20210707_171026](/assets/20210707_171026.png)

이제 실행해보면 UI가 더 나아진게 보인다.


유효성 검사 실패하면(DTO중 유효성 하나라도 실패하면) bindingresult 에 다 담기고, bindingResult에 에러가 하나라도 있으 얘가 만든 해쉬맵에 throw 해서 Exception 강제로 발생시킴.


```
throw new CustomValidationException("유효성 검사 실패", errorMap); //강제 예외 발생

```

익셉션 강제로 throw 로 발생시키고 실행해보자.

------
