---
title: "[Springboot] Springboot 스터디 1일차"
layout: post
subtitle: Springboot
date: "2021-06-14-04:58:53 +0900"
categories: study
tags: Springboot
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---

브라우저에서 요청을 보냄 = url경로를 주소창에 보냄. 그 때 네이버 서버에 요청을 보내게 되고 요청이 왔으니까 네이버 메인페이지 보여줌

요청 오면 요청 받아서 서버에서 응답해줌. 그걸 컨트롤러가 해줌.
컨트롤러가 어떤 요청에 어떤 메서드가 오는지 매핑하는걸 컨트롤러에서
그 메서드 안에서 데이터 글쓰기 아니면 글 조회 목록조회 이런게 들어온다(board에 리스트라 요청하면)

ex)localhost:8080/board/list
하면 view 페이지 보여줘야한다

1. 요청경로 매핑
   저 요청과 어떤 메서드가(컨트롤러의) 그 메서드 안에서의 역할은
2. 서비스 호출- 게시글 목록을 DB에 조회
3. 데이터가 컨트롤러까지 오면 모델에 담는 역할 하고 그리고
4. 게시글 목록 담아두고 (모델에) 어떤 뷰페이지에 담을지 뷰를 선택하는 작업.

이 작업을 컨트롤러에서 하게 된다.

모델에 속성 추가하고 그걸 뷰에서 꺼내와서 jsp나 타임리프 html등등

서비스에 추상 메서드를
어떤 dao어떤 매퍼에 오는거 인지 정해준다.

최종적으로 html에 요청을 보낸다.

컨트롤러로 쭉 보내게 됨.

톱니바퀴 모양 쓰면 스프링 부트 빠를게 설치 가능.

pespective- customperspective

spring start Project

war,jar는 배포할 때 호스팅할떄 편하긴 함.
지금은 신경 안쓸거라 jar(나중엔 war로)

스프링 web이 동작하기 위한 기본 의존성
Dependency가 의존성
어떤 플젝을 만들기 위해서 외부라이브러리를 만들고 임포트해야 사용가능한데
스프링은 그레이들이나 메이븐으로 의존성으로 어떤 라이브러리가 한줄만 넣어도 다운 받아서 임포트 하면 대신 해준다.

thymeleaf 는 템플릿엔진(스프링부트에서 기본)
devtools는 라이브리로드가 됨. 서버 껐다가 안켜도 서버 켜놓은 상태에서 바로 반영이 됨.
그걸 데브툴스가 도와줌.
jsp 만들면 코드 클래스 수정하면 서버 껐다켜야되지만
톰캣에서 리로드 키거나 근데 스프링부트 데브툴스로도 라이브리로드가 된다.

![20210614_231346](/assets/20210614_231346.png)

- static은 정적파일
- templates은 html,jsp 같은 뷰파일
- application은 설정 정보 기록하는 파일.

build.gradle이 의존성 관리
만약 더 의존성이 필요하면 mvn repository로 가서 다운받으면 된다. 예아
안녕하세요라는 문자를 데이터에 담음

---

board 만들고 aloha

3306은 설정 정보 url 은 스키마.
그리고 뒤에ㅏ나오는건 쿼리스트링(서버타임존부터)

그 밑은 마이바티스 관련설정

데이터 조회해서 가져올떄 보드라든 데이터 가져옴

매퍼에는 인터페이스, 서비스에는 보드 서비스, 보드서비스 임플작성

그리고 html에는  
.

---

프로세스 설명

1. 컨트롤러ㅓ에 get메핑과 포스트매핑해서 url 매핑할 것
   화면 불러올떄 get하고 post는 처리 요청할 떄

1-1 /board/register 글쓰기 화면
1-2 post로
서비스 가서 메서드 정의 3. 매퍼에 가서 메서드 정의

4. html

컨트롤러 -서비스 -매퍼 -html

---

Model객체가 실질적으로 MVC에서 사용

RequsetMapping과 GetMapping은 같은데 버전차이

board에 register경로에 있는 걸 응답해줌.

게시글 쓰기 처리는 post방식으로 매핑할 것

롬복은 생성자를 자동으로 생성한다.

---

#### 제어의 역전(DI)

제어의 권한이 개발자가 갖고있는데

언제 소멸하고 언제 생성하고 언제 의존성 하고 종속성 하는지 다 개발자가 만드는 건데 그런거 하나하나 다 만들면 진짜 핵심 로직에 투자할 시간이 줄어듬.
객체 생성해서 하는거 그런걸 다 프레임 워크에 넘기는 거.

객체의 생명주기를 다 프레임 워크에 맡기고 핵심 로직에 집중한다. 그 개념 아래에 의존성 주입이 있다.

객체가 new 해서 무한생성 되지않고 스프링 컨테이너 하나에 객체 하나 등록되면 그 컨테이너 하나에서 가져다 쓸 수 있음.

우리가 해줄 일은 변수에 @Autowired 라는 변수를 붙여주면 그 의존성 주입이 실현된다.

위에서 추상메서드로 정의해둔 걸 자동으로 가져옴

암호화같은 작엄을 하고 매퍼로 넘김.

#### 컨트롤러 -서비스 -매퍼 -html

매퍼 = 네임스페이스 보드매퍼 인터페이스에 대한 경로

이게 xml 과 연결되어있다고 지정.
보드 컨트롤러에서 서비스에 reigster넘겨줌.

그럼 화면에서 서버로 념겨오니까 서비스로 요청을 보내면 레지스터가 실행되고 그게 구현클래스인 레지스터가 동작하고
그게 매퍼 인서트라는 메서드를 호출하면 insert가 실행 될 때 매퍼 xml라는 파일에서 insert라는 아이디를 가진 쿼리 실행.

이거의 연결되는 방식은 인서트 쿼리 요청할 떄 마이바티스 요청

아이디가 insert인데 insert 아이디와 board 매퍼 인터페이스와 일치시켜주면 됨.

BoardMapper

board컨트롤러에서 레지스터 호출 - 서비스의 레지스터 실행 - 임플에 있는 insert실행 보드 매퍼에 있는 인서트가 실행 될떄 얘랑 매핑되어있는 xml의 쿼리가 실행이 됨. 이때 보드 객체담고 있는데 이 객체속의 파라미터를 가져옴.

utf8mb4 , utf8mb4

![20210614_231430](/assets/20210614_231430.png)

board라 테이블 만들고나서
utf8mb4, utf8mb4*900*먀

\_

원래는 DAO에서 pstmt 해서 요청 DA

DAO

DTO 는 디비로 전송할 때 그냥 그 전송되는 사이에서 데이터를 감싸는 그거

타이틀이라는 변수도 컨텐츠 보드라는 객체 하나로 묶으면 디비에서 조회되는 데이터 한건은 보드 하나로 묶음. 그걸 리스트로 받아옴()

DTO는 데이터를 전송하기 위해서 데이터베이스에 있는 컬럼이랑 자바 객체를 매핑한다.

테이블을 저장한 걸 그대로 가져온다.

(DAO, DTO, VO)

DAO를 매퍼가 대신 해준다.

---

.
DAO는 바구니에 보내주는거 여러개의 컬럼이 담긴 그걸 그대로 가져오는 거.
그걸 매퍼가 대신한다.(Mapper)
?, ?, ? 를 매퍼가 대신해준다.
(mybatis 프레임 워크가 대신해준다.)
그거 플러스 쿼리와 자바코드 분리해준다.
.

---
