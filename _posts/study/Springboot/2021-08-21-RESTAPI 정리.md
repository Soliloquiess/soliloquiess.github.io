---
title: "[Springboot] REST API 정리"
layout: post
subtitle: Springboot
date: "2021-08-21-14:58:53 +0900"
categories: study
tags: Springboot
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---

### 스프링 MVC 구조

- 스프링 MVC는 DispatcherServlet, View Resolver, Handler, View 등으로 구성되어 있다.

스프링 요청처리 흐름도
![20210821_022001](/assets/20210821_022001.png)

1. 클라이언트( 브라우저) 의 요청을 DispatcherServlet이 받는다.

2. 받은 요청을 처리할 수 있는 Handler 의 이름을 HandlerMapping에게 물어본다.

3. HandlerMapping은 요청 URL을 비롯한 여러 요청정보를 가지고 Handler를 판단한다.
4. DispatcherServlet은 HandlerMapping으로부터 선택받은 Handler에게 요청을 보낸다.

5. Handler는 요청을 적절히 처리하고 응답에서 렌더링 해야하는 ViewName을 판단해서 DispatcherServlet에 전송한다.

6. DispatcherServlet은 논리적인 ViewName을 ViewResolver에 전달한다.

7. ViewResolver는 응답에 필요한 View를 생성하여 DispatcherServlet에 보낸다.

8. DispatcherServlet은 해당하는 View에 Model을 전달한다.

9. View는 Model을 참조해서 응답을 생성한다.

10. DispatcherServlet는 생성된 응답을 클라이언트(브라우저)에 반환한다.

---

### 자바 빈즈

자바빈즈(JavaBeans)는 자바로 작성된 소프트웨어 컴포넌트이다.

자바빈즈의 사양은 썬 마이크로시스템즈에서 다음과 같이 정의되었다.

"빌더 형식의 개발도구에서 가시적으로 조작이 가능하고 또한 재사용이 가능한 소프트웨어 컴포넌트이다."

자바빈즈는 많은 측면에서 유사하지만 엔터프라이즈 자바빈즈 (EJB)와 혼동하지 말아야 한다. EJB는 자바 플랫폼, 엔터프라이즈 에디션 (Java EE)의 일부로서 서버계열의 컴포넌트이다.

##### 자바 빈즈의 관례

- 자바 빈즈 클래스로서 작동하기 위해서, 객체 클래스는 명명법, 생성법 그리고 행동에 관련된 일련의 관례를 따라야만 한다.

이러한 관례는 (빌더형식의) 개발도구에서 자바 빈즈와의 연결을 통해 클래스의 사용과 재사용 그리고 클래스의 재배치를 가능하게 한다.

지켜야 할 관례에는 다음과 같은 것이 있다.

1. 클래스는 직렬화 되어야 한다(클래스의 상태를 지속적으로 저장 혹은 복원시키기 위해)

2. 클래스 기본 생성자를 가지고 있어야 한다.
3. 클래스의 속성들은 get, set 혹은 표준 명명법을 따르는 메서드들을 사용해 접근할 수 있어야 한다.

4. 클래스는 필요한 이벤트 처리 메서드들을 포함하고 있어야 한다.

---

##### 자바 빈즈의 직렬화

- 자바 빈즈는 반드시 직렬화 할 필요는 없으나 미리 구현해 두는 것이 무난하다.

본서에서는 편의상 직렬화는 반드시 구현해야 하는 경우가 아니면 구현하지 않는다.

직렬화가 필요한 경우는 다음과 같다.

1. JPA 프로바이더 제공하는 캐시기술이 Serializable 인터페이스를 요구하는 경우

2. 자바 빈즈 객체를 스코프에서 관리하는 경우

3. 다수의 서버에서 세션 객체를 공유해야 하는 경우

---

### 롬복 어노테이션

- 롬복(Lombok) 을 활용하면 약간의 애너테이션 설정만으로 소스 코드가 컴파일 될때 자동으로 추가 코드를 만들 수 있다.

- 롬복 어노테이션의

| 어노테이션              | 설명                                                                                                           |
| ----------------------- | -------------------------------------------------------------------------------------------------------------- |
| @Getter/@Setter         | 객체의 게터와 세터를 생성한다.                                                                                 |
| @ToString               | toString() 메서드를 생성한다.                                                                                  |
| @EqualsAndHashCode      | 자바의 equals() 메서드와 hashCode()메서드를 생성한다.                                                          |
| @NoArgsConstructor      | 인자가 없는 기본 생성자를 생성한다.                                                                            |
| @RequiredArgsConstuctor | @NonNull이 적용된 필드 값이나 final로 선언된 필드값만 인자로 받는 생성자를 생성한다.                           |
| @AllArgsConstructor     | 객체의 모든 필드값을 인자로 받는 생성자를 생성한다.                                                            |
| @Data                   | @ToString, @Getter, @Setter, @EqualsAndHashCode, @RequiredArgsConstuctor 어노테이션을 합쳐노은 어노테이션이다. |
| @Builder                | 빌더 패턴을 사용할 수 있도록 코드를 생성한다.                                                                  |
| @Log(Slf4j)             | 자동으로 생기는 log라는 변수를 이용해서 로그를 출력할 수 있다.                                                 |

---

### REST 소개

REST(Representational State Transfer)는 월드 와이드 웹과 같은 분산 하이퍼 미디어 시스템을 위한 소프트웨어 아키텍쳐의 한 형식이다.

엄격한 의미로 REST는 네트워크 아키텍쳐 원리의 모음이다. 여기서 "네트워크 아키텍쳐""란 자원을 정의하고 자원에 대한 주소를 지정하는 방법 전반을 일컫는다.

간단한 의미로는 웹상의 자료를 HTTP위에서 SOAP이나 쿠키를 통한 세션 트랙킹 같은 별도의 전송 계층 없이 전송하기 위한 아주 간단한 인터페이스를 말한다.

REST 아키텍쳐 형식을 따르면 HTTP나 WWW이 아닌 아주 커다란 소프트웨어 시스템을 설계도 가능하다.

또한 리모트 프로시저 콜 대신 간단한 XMㅣ과 HTTP 인터페이스를 이용해 설계하는 것 또한 가능하다.

### RESTFUL 제약조건

REST 제약조건들을 제대로 지키면서 REST아키텍쳐를 만드는 것을 RESTful이라고 한다.

다음 제약 조건들을 준수하는 한 개별 컴포넌트들을 자유로이 구현할 수 있다.

- 클라이언트-서버 구조: 일관적인 인터페이스로 분리되어야 한다.

- 무상태성(stateless): 서버에 클라이언트의 상태정보를 저장하지 않는다.

- 캐시기능(cacheable): 클라이언트의 응답을 캐시할 수 있어야 하며, 캐싱은 클라이언트-서버간 상호작용을 부분적으로 또는 완전하게 제거하여 scalability와 성능을 향상시킨다.

- 계층화 시스템(layered system)
  : 중간서버는 로드밸런싱 기능이나 공유캐시기능을 제공함으로서 확장성 있는 시스템을 구성하는데 유용하다

- 코드 온 디맨드(code on demand)
  : 서버가 자바 애플릿이나 자바스크립트 실행코드의 제공을 통해 클라이언트가 실행시킬수 있는 로직을 전송하여 기능을 확장시킬 수 있다.

- 인터페이스 일관성(uniform interface)
  : 아키텍처를 단순화 시키고 작은 단위로 분리함으로써 클라이언트- 서버 각 파트가 독립적으로 개선되게 해준다.

### REST 인터페이스 원칙에 대한 가이드

가이드를 충실히 이행했는지에 따라 REST를 제대로 썼는지 판단할 수 있다.

1. 자원식별
   : 요청 내의 기술된 개별자원을 식별할 수 있어야 한다. 웹 기반의 REST 시스템에서의 URI 사용을 예로 들 수 있다.

2. 메시지 통한 리소스 조작
   : 클라이언트가 어떤 자원을 지칭하는 메시지와 특정 메타데이터만 가지고 있다면 이것으로 서버상의 해당 자원을 수정, 삭제하는 충분한 정보를 갖고 있다고 볼 수 있다.

3. 자기 서술적 메시지
   : 각 메시지에는 처리방법에 대한 충분한 정보가 들어있어야 한다.

4. 애플리케이션 상태에 대한 엔진으로서의 하이퍼미디어(HATEOAS)
   : 클라이언트에 응답할 떄 단순히 결과 데이터만을 제공하는 것이 아니라 URI를 함꼐 제공해야한다는 것이다.

---

### REST API 설계

- 서버 한대가 여러 클라이언트에 대응하려면 REST API가 필요하다.

#### REST API의 구성

- 자원(resource) : URI
- 행위(verb) : HTTP 메서드
- 표현(representations): 리소스에 대한 표현(HTTP MESSAGE BODY)

#### URI 설계

- 리소스는 서비스를 제공하는 시스템의 자원을 의미하며 URI로 정의된다.

URI는 웹에 있는 자원의 이름과 위치를 식별한다.

#### 명사를 사용하라.

URI 는 명사를 사용해야하며 동사는 피해야한다.
명사만으로는 세부적인 동작을 표현하는데 한계가 있을 떄 동사를 URI에 포함 할 수 있다.

#### 동사는 HTTP 메서드로 표현한다.

- 동사를 표현할 떄는 HTTP 메서드인 GET, POST, PUT, DELETE 등으로 대체해야한다.

#### 복수형을 사용하라.

- URI에서는 명사에 단수형보다는 복수형을 사용해야한다.

/book도 물론 명사고 사용 가능하지만 /books 로 리소스를 표현하려면 컬렉션(collection)으로 명확히 표현할 수 있어 확장성 측면에서 유리하다.

#### 슬래시로 계층 관계를 표현한다.

#### URI의 마지막에 슬래시를 넣지 않는다.

- 넣어도 문제는 없지만 다음 계층이 있다는 오해를 부를 수 있다.

#### URI는 소문자로 작성한다.

![20210821_190845](/assets/20210821_190845.png)

---

### 제이슨 소개

- 제이슨은 영문표기로 JSON(JavaScript Object Notation)이라 하며, 플랫폼이나 언어와 무관하게 자바스크립트 내 자료교환을 목적으로 만들어진 포맷이다.

#### REST 서버에서 제공하는 자원의 타입중 XML 보다 제이슨을 더 선호하는 이유

- 제이슨은 표현의 완전성과 가독성 좋을 뿐 아니라 자바스크립트의 기본형식이다.
- 제이슨은 XML 보다 표현이 간단하다. 또한 제이슨은 XML 스키마나 XML DTD에 대한 구분이 필요없다.

#### 제이슨의 문법

- 제이슨은 바이너리(binary)코드가 아닌 무자로만 이루어져있다.
- 문자의 인코딩은 유니코드이다.
- 제이슨의 마임타입(MIME) 은 'application/json'이다.
- 제이슨은 시작'{' 중괄호로 시작하고 마무리 중괄호로 끝난다.'}'
- 콤마는 두개의 제이슨 또는 제이슨 값을 구분하는 구분자로 사용한다.
- 키와 값의 구분은 . 를 사이에 두고 하는데 만약 일반 문자열을 읽고 해석할 떄는 '='또는 '=>'도 같은 무구분자로 인식한다.
- 제이슨 키와 문자열 타입의 값은 "" 큰 따옴표를 사용하여 표기한다.
- 값으로 들어가는 자료타입은 숫자를 표현한 문자(int, long, double), 문자열(string), 불린(boolean), 제이슨 배열(JSONARRAY), 제이슨 객체가 된다.

#### JSON자료타입

- JSON은 2개의 구조를 기본으로 가지고 있다.

- name/value 형태의 쌍으로 컬렉션타입, 다양한 언어에서 이는 object, record, struct(구조체), dictionary, hashtable, 키가 있는 list, 또는 연상배열에서 실현되었다.

###### Object

- object는 name/value 쌍들의 비순서화된 set이다. object는 좌중괄호로 시작하고 우중괄호로 끝내어 표현한다.
  각 name 뒤에 : 콜론을 붙이고, 콤마로 name/value쌍들 간을 구분한다.

![20210821_195713](/assets/20210821_195713.png)

###### array

- array는 값들의 순서화된 컬렉션이다.

![20210821_195741](/assets/20210821_195741.png)

###### value

- value 는 큰 따옴표 안에 string, number, true, false, null, object ,array등이 올 수 있다. 이러한 구조들을 포함한다.

![20210821_195841](/assets/20210821_195841.png)

###### String

- 큰 따옴표 안에 둘러싸인 zero이상 unicode 문자들의 조합이며, 쌍따옴표 안에 감싸지며 백슬래쉬 이스케이프가 적용된다. 하나의 문자도 하나의 문자열로서 표현된다.

![20210821_195907](/assets/20210821_195907.png)

---

### JQUERY Ajax 통신

1. $.get()

- Http Get 요청을 사용하여 서버에서 데이터를 로드한다.

$.get(Uril, parameters, callback)

매개변수로 명시된 URL을 사용하여 서버에 대한 GET요청을 전송한다. 매개변수는 쿼리 문자열로 전달한다.

- 매개변수

| 변수명    | 타입           | 설명                                                                                                                      |
| --------- | -------------- | ------------------------------------------------------------------------------------------------------------------------- |
| URL       | String         | GET 메서드로 연결하는 서버측 자원의 URL                                                                                   |
| parameter | Object, String | URL에 덧붙이는 쿼리문자열을 구성하려고 이름과 값의 쌍으로 프로퍼티를 지닌 객체, 미리 구성 및 인코딩 된 쿼리 문자열        |
| callback  | Function       | 요청이 완료되면 호출되는 함수. 응답 본문은 이 콜백 함수의 첫번째 매개변수로 전달되며 상태값은 두번째 매개변수로 전달된다. |

반환값 : XHR 인스턴스

---

2. $.getJson()

- Http Get 요청을 사용하여 서버에서 JSON 형식으로 인코딩 된 데이터를 로드한다.

$.getJSON(Uril, parameters, callback)

매개변수로 명시된 URL을 사용하여 서버에 대한 GET요청을 전송한다. 매개변수는 쿼리 문자열로 전달한다. 응답은 JSON문자열로 해석되며, 결과로 만들어진 데이터는 콜백함수에 전달된다.

- 매개변수

| 변수명    | 타입           | 설명                                                                                                                      |
| --------- | -------------- | ------------------------------------------------------------------------------------------------------------------------- |
| URL       | String         | GET 메서드로 연결하는 서버측 자원의 URL                                                                                   |
| parameter | Object, String | URL에 덧붙이는 쿼리문자열을 구성하려고 이름과 값의 쌍으로 프로퍼티를 지닌 객체, 미리 구성 및 인코딩 된 쿼리 문자열        |
| callback  | Function       | 요청이 완료되면 호출되는 함수. 응답 본문은 이 콜백 함수의 첫번째 매개변수로 전달되며 상태값은 두번째 매개변수로 전달된다. |

반환값 : XHR 인스턴스

---

3. $.post()

- HTTP POST 요청을 사용하여 서버에서 데이터를 로드한다.

$.post(url, parameters, callback)

| 변수명    | 타입           | 설명                                                                                                                      |
| --------- | -------------- | ------------------------------------------------------------------------------------------------------------------------- |
| URL       | String         | GET 메서드로 연결하는 서버측 자원의 URL                                                                                   |
| parameter | Object, String | URL에 덧붙이는 쿼리문자열을 구성하려고 이름과 값의 쌍으로 프로퍼티를 지닌 객체, 미리 구성 및 인코딩 된 쿼리 문자열        |
| callback  | Function       | 요청이 완료되면 호출되는 함수. 응답 본문은 이 콜백 함수의 첫번째 매개변수로 전달되며 상태값은 두번째 매개변수로 전달된다. |

4. $.ajax()

- 비동기 HTTP (Ajax) 요청을 수행한다.
- $.ajax(options)
  요청의 생성방법 과 통보 받을 콜백을 제어하고자 전달된 options를 사용하여 Ajax요청을 전송한다.

매개변수

| 변수명 | 타입   | 설명                                                            |
| ------ | ------ | --------------------------------------------------------------- |
| option | object | 요청에 대한 매개변수를 정의하는 프로퍼티를 소유한 객체 인스턴스 |

- 반환값 : XHR 인스턴스

함수의 옵션

| 변수명      | 타입     | 설명                                                                                                                                                                                                                             |
| ----------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| url         | String   | 요청 URL                                                                                                                                                                                                                         |
| type        | String   | 사용할 HTTP 메서드, 일반적으로 POST나 GET을 사용한다. 생략하면 기본값으로 GET을 사용한다.                                                                                                                                        |
| data        | Object   | 요청에 전달되는 프로퍼티를 가진 객체. GET요청이면 데이터는 쿼리 문자열로 제공된다.POST 요청이면 데이터는 요청의 본문으로 제공된다.                                                                                               |
| datatype    | String   | 응답의 결과로 반환되는 데이터의 종류를 식별하는 키워드. 유효한 xml, html, json, jsonp, script, text이다.                                                                                                                         |
| timeout     | Number   | Ajax의 요청제한 시간을 밀리초 단위로 설정한다.                                                                                                                                                                                   |
| global      | Boolean  | true나 false냐에 따라 전역함수를 활성화 하거나 비활성화 한다.                                                                                                                                                                    |
| content     | String   | 요청에 명시되는 타입 생략하면 'application'/ x-www-form-urlencoded' 가 기본값으로 설정된다.                                                                                                                                      |
| headers     | Object   | 요청헤더 XMLHttpRequest 전송을 사용하여 요청과 함꼐 추가로 전송할 헤더키/ 값 쌍의 객체                                                                                                                                           |
| success     | Function | 응답이 성공상태의 코드를 반환하면 호출되는 함수. 응답 본문은 이 함수의 첫번째 매개변수로 전달되며, dataType 프로퍼티에 명시한 형태로 구성된다. 두번째 매개변수는 상태값을 나타내는 문자열이며, 이번 경우에는 항상 'success'이다. |
| error       | Function | 응답이 에러상태의 코드를 반환하면 호출되는 함수. 매개변수가 세개 전달되는데, 각각 XHR인스턴스, 상태값이 항상 'error' 인 메시지 문자열, 선택사항으로 XHR인스턴스가 반환되는 예외객체이다.                                         |
| complete    | Function | 요청이 완료되면 호출되는 함수, 매개변수 두개가 전달되는데 각각 XHR인스턴스와 success또는 error 를 나타내는 상태 메시지 문자열이다. success 나 error 콜백을 명시했다면, 이 함수는 해당 콜백이 호출된 후에 실행된다.               |
| beforeSend  | Function | 요청이 전송되기에 앞서 먼저 호출되는 함수, 이 함수는 XHR 인스턴스를 전달받으며 사용자 정의헤더를 설정하거나 요청 전에 필요한 연산을 수행하는 데 사용할 수 있다.                                                                  |
| async       | Boolean  | 요청이 전송되기에 앞서 먼저 호출되는 함수, 이 함수는 XHR 인스턴스를 전달받으며 사용자 정의헤더를 설정하거나 요청 전에 필요한 연산을 수행하는 데 사용할 수 있다.                                                                  |
| ProcessData | Boolean  | 요청이 전송되기에 앞서 먼저 호출되는 함수, 이 함수는 XHR 인스턴스를 전달받으며 사용자 정의헤더를 설정하거나 요청 전에 필요한 연산을 수행하는 데 사용할 수 있다.                                                                  |
| ifModified  | Boolean  | true일때 Last-Modified 헤더를 확인하며 마지막 요청 이후에 응답 컨텐츠가 변경되지 않았다면 요청이 성공한다. 만일 생략하면 헤더를 확인하지 않는다.                                                                                 |

---

### 컨트롤러 메서드 매개변수

##### 주요 매개 변수

- Model : 이동 대상 에 전달할 데이터를 가지고 있는 인터페이스.
- RedirectAttributes : 리다이렉트 대상에 전달할 데이터를 가지고 있는 인터페이스
- 자바 빈즈 클래스 : 요청 파라미터 가지고 있는 자바빈즈 클래스
- MultipartFile : 멀티파트 요청을 사용해 업로드 된 파일 정보를 가지고 있는 인터페이스
- BindingResult : 도메인 클래스의 입력값 검증 결과 가지고 있는 인터페이스
- Java.util.Locale: 클라이언트 로캘
- java.security.Principal : 클라이언트 인증을 위한 사용자 정보를 가지고 있는 인터페이스.

##### 요청 데이터 처리 어노테이션

- @PathVariable : URL 에서 경로변수 값을 가져오기 위한 어노테이션
- @RequestParam : 요청 파라미터 값을 가져오기 위한 어노테이션
- @RequestHeader : 요청 헤더 값을 가져오기 위한 어노테이션.
- @RequestBody : 요청 본문 내용을 가져오기 위한 어노테이션
- @CookieValue : 쿠키 값을 가져오기 위한 어노테이션.

---

### 입력값 검증

- 스프링 MVC는 Bean Validation기능을 이용해 요청 파라미터 값이 바인딩 된 도메인 클래스(또는 커맨드 클래스)의 입력값을 검증한다.

##### 입력값 검증 활성화

- 입력값 검증을 하기 위해서는 메서드 매개변수에 도메인 클래스를 정의하고 @Validated를 지정한다.
- 입력값 검증 대상의 도메인 클래스 직후에 BindingResult를 정의한다. BindingResult에는 요청 데이터의 바인딩 오류와 입력값 검증 오류정보가 저장된다.

###### Validated 어노테이션을 지정하여 입력값 검증 기능을 활성화한다.

---

### 입력값 검증 결과

- 입력값 검증 대상의 도멘인 클래스 직후에 BindingResult를 정의한다. BindingResult에는 요청 데이터의 바인딩 에러와 입력값 검증 에러 정보가 저장된다.

###### 에러 정보 확인을 위한 BindingResult 메서드

- hasError() : 에러가 발생한 경우 true를 반환한다.
- hasGlobalErrors() : 객체레벨의 에러가 발생한 경우 true를 반환한다.
- hasFieldErrors(): 필드레벨의 에러가 발생한 경우 true를 반환한다.
- hasFiledErrors(String): 인수에서 지정한 필드서 에러가 발생시 true를 반환한다.

---

### 메시지 소스 정의

- MessageSource는 메시지 정보의 출처를 추상화하기 위한 것이고 getMessage메서드를 제공하여 메시지 정보를 가져온다.

### 국제화

- MessageResource의 구현클래스는 국가별로 메시지 언어를 다르게 적용할 수 있는 국제화 기능을 가지고 있다.

---

### 의존성 주입 설명

- 의준성 주입(DI)는 객체가 생성자 인수, 팩터리 메서드에 대한 인수 또는 팩토리 메서드에서 생성되거나 반환된 후 객체 인스턴스에 설정된 속성을 통해서만(즉, 작업하는 다른 객체)를 정의하는 프로세스이다. 컨테이너는 빈을 생성할 때 이런 의존성을 주입한다.

일반적으로 세가지 의존성 주입방법을 사용할 수 있다.

- 필드 기반 의존성 주입
- 생성자 기반 의존성 주입
- 세터 기반 의존성 주입.

### 필드 기반 의존성 주입

- 필드 기반의 의존성 주입 방식은 생성자나 세터 메서드를 사용하지 않고 DI 컨테이너의 기능을 이용하여 의존성을 주입하는 방식이다.

@Autowired 어노테이션을 지정하여 필드에 대한 의존성을 주입한다.

### 생성자 기반 의존성 주입

- 생성자 기반의 의존성 주입방식은 생성자의 인수를 사용하여 의존성을 주입하는 방식이다.

### 세터기반 의존성 주입

- 세터 기반의 의존성 주입 방식은 세터 메서드의 인수를 통해 의존성을 주입하는 방식이다.

### 자동연결

자동연결(Autowireing)은 @Bean 메서드를 사용하는 것 처럼 명시적으로 빈을 정의하지 않고도 DI 컨테이너에 빈을 자동으로 주입하는 방식이다.

---

### MYSQL 워크벤치 계정 추가(권한까지)

![20210823_001538](/assets/20210823_001538.png)

루트 계정으로 들어간다.

![20210823_001614](/assets/20210823_001614.png)

네비게이터 하단의 Administration으로 가서 Userand Privileges를 간다.
그리고 하단의 Add Account를 누른다.

![20210823_001706](/assets/20210823_001706.png)

그리고 저 3군데를 체크해주며 %부분은 그대로 둔다. 지우면 로컬에서만 쓰겠다는 뜻이 된다.

![20210823_002906](/assets/20210823_002906.png)

그리고 모든 권한을 다 주기 위해 ROle과 Global Privileges 부분을 체크해준다.

![20210823_004247](/assets/20210823_004247.png)

근데 계속 root계정의 디비가 다 접근 가능하다 이거 왜 이러지. 직접 터미널에서 권한 줘서 해보자

```
create user RESTUSER identified by 'RESTUSER';


grant all privileges on RESTUSER.* to RESTUSER;

```

![20210823_005614](/assets/20210823_005614.png)

![20210823_005457](/assets/20210823_005457.png)

![20210823_005447](/assets/20210823_005447.png)

직접 root 계정 들어가고 쿼리창에서 유저 생성 및 권한 주니까 이제 스키마가 다 깨끗한 상태의 유저가 보인다.(RESTUSER)

---

### 데이터 소스 설정

어플리케이션이 데이터베이스에 접근하기 위한 추상화된 연결을 제공하는 역할을 한다.

#### 스프링에서 설정할 수 있는 데이터 소스

- JDBC 드라이버를 통해 선언된 데이터 소스
- JNDI에 등록된 데이터소스
- 커넥션을 풀링하는 데이터 소스

###### JNDI(JAVA NAMING AND DIRECTORY INTERFACE)

- 디렉터리 서비스에서 제공하는 데이터 및 객체를 발견(discover)하고 참고(lookup)하기 위한 자바 API다.

![20210823_012945](/assets/20210823_012945.png)

SQL 쿼리문(Board 생성)

```
create table board(
board_no int not null auto_increment,
title varchar(200) not null,
content TEXT null,
writer varchar(50) not null,
reg_date timestamp not null default now(),
primary key(board_no)
);

```

---

### 스프링 JDBC

- SQL로만 데이터베이스를 쉽게 처리하도록 도와주는 JdbcTemplate 클래스를 제공한다.

JdbcTemplate 클래스가 제공하는 주요 메서드로

- queryForObject : 하나의 결과 레코드 중에서 하나의 컬럼값을 가져온다.
- queryForMap : 하나의 결과 레코드 정보를 Map 형태로 매핑할 수 있다.
- queryForList : 여러개의 결과 레코드를 처리할 수 있따.
- query: ResultSetExtractor.RowCallbackHandler와 함께 조회시 사용한다.
- update: 데이터를 변경하는 SQL을 실행시 사용한다.

데이터 테이블

![20210823_094103](/assets/20210823_094103.png)

데이터 흐름도

![20210823_094123](/assets/20210823_094123.png)

---

### JPA

- JPA(Java Persistence API)는 자바 표준 ORM(Object-Relational Mapping, Object-Relational Mapper)다

ORM:
객체에 데이터를 읽고 쓰는 방법으로 관계형 데이터베이스에 데이터를 읽고 쓰는 기술이다.

##### Entity

데이터 베이스에서 지속적으로 저장된 데이터를 자바 객체에 매핑한것이다.
메모리 상에 자바 객체의 인스턴스 형태로 존재하며, EntityManager에 의해 데이터베이스의 데이터와 동기화 된다.

##### EntityManager

필요에 따라 Entity와 데이터베이스의 데이터를 동기화한다.
EntityManager에서 제공하는 Entity 조작 API를 통해 Entity에 대해 CRUD 작업을 할 수 있다.

##### Entity 상태

- new 상태
- 관리 상태
- 분리 상태
- 삭제된 상태

데이터 흐름도
![20210823_100213](/assets/20210823_100213.png)

---

### Mybatis 소개

- 마이바티스는 자바 퍼시스턴스 프레임워크의 하나로 XML 서술자나 어노테이션을 사용하여 저장 프로시저나 SQL문으로 객체들을 연결시킨다.

마이바티스는 아파치 라이선스 2.0으로 배포되는 자유 소프트웨어이다.

#### 마이바티스를 사용함으로서 얻을 수 있는 이점.

- SQL 의 체계적인 관리
- 자바 객체와 SQL 입출력 값의 투명한 바인딩
- 동적 SQL 조합.

SQL 쿼리문

```
use dev_db;


create table member(
user_no integer(5) auto_increment,
user_id varchar(50) not null,
user_pw varchar(100) not null,
user_name varchar(100) not null,
coin integer(10) default 0,
reg_date timestamp default now(),
upd_date timestamp default now(),
enabled char(1) default '1',
primary key(user_no)
);

create table member_auth(
user_no integer(5) not null,
auth varchar(50) not null
);


alter table member_auth add constraint fk_member_auth_user_no
foreign key(user_no)references member(user_no);


```

![20210823_104314](/assets/20210823_104314.png)

### 매퍼 설정

mybatis 구성에는 mybatis 동작에 영향을 주는 설정 및 프로퍼티가 있다.

- Configuration
  - Properties
  - settings
  - typesAliases
  - typeHandlers
  - ObjectFactory
  - plugins
  - environments
    1. environment
       1.1 transactionManager
       1.2 datasource
  - databaseIdProvider
  - mappers

.
![20210823_122925](/assets/20210823_122925.png)

![20210823_122936](/assets/20210823_122936.png)

![20210823_123001](/assets/20210823_123001.png)

![20210823_123018](/assets/20210823_123018.png)

![20210823_123035](/assets/20210823_123035.png)

![20210823_123123](/assets/20210823_123123.png)

![20210823_123920](/assets/20210823_123920.png)

---

### Mapper XML 파일

- Mybatis의 진정한 힘은 매핑 구문에 있다. Mapper XML 파일은 모든 기능에 있어서 비교적 간단하다. 물론 그들을 동등한 JDBC 코드와 비교하면 95%의 코드가 절약된다. Mybatis는 SQL에 중점을 두고 개발되었다.

매퍼 XML 파일에는 몇가지 첫번째 요소만 있다.

- cache : 지정된 네임스페이스에 대한 캐시 구성
- cache-ref : 다른 네임스페이스의 캐시 구성에 대한 참조
- resultMap : 데이터베이스 결과 세트에서 객체를 로드하는 방법을 설명하는 요소이다.
- sql : 다른 구문에서 참조할 수 있는 재사용이 가능한 SQL 블록
- insert : 매핑된 insert 구문
- update : 매핑된 update 구문
- delete : 매핑된 delete 구문
- select : 매핑된 select 구문

---

#### select

- select 구문은 mybatis에서 가장 많이 사용되는 요소 중 하나입니다. 데이터베이스에 데이터를 넣는 것은 데이터를 다시 얻을 때 까지 별로 중요하지 않으므로 대부분의 응용프로그램은 데이터를 수정하는 것보다 훨씬 더 많이 조회한다. 이것이 Mybatis의 기본 원칙 중 하나이며, 쿼리 및 결과 매피엥 많은 초점과 노력이 집중된 이유이다. select 요소는 간단한 경우는 매우 단순하다. 예를 들면 다음과 같다.

![20210823_150614](/assets/20210823_150614.png)

##### select 요소 속성

![20210823_150625](/assets/20210823_150625.png)

#### insert, update and delete

- 데이터 변경 구문 insert, update 및 delete 는 구현이 매우 비슷하다.

![20210823_154812](/assets/20210823_154812.png)

![20210823_164352](/assets/20210823_164352.png)

---

### 기본키 취득

- 마이바티스는 useGeneratedKeys 속성을 이용하여 Insert 할 때 데이터베이스 측에서 채번된 기본키를 취득할 수 있다.

![20210823_164922](/assets/20210823_164922.png)

---

### SQL

- 이 요소는 다른 구문에 포함될 수 있는 재사용 가능한 SQL 코드 조각을 정의하는 데 사용할 수 있다. 로드 단계에서 정적으로 매개변수화 할 수 있다. 다른 프로퍼티 값은 포함한 인스턴스에 따라 달라질 수 있다.

![20210823_170310](/assets/20210823_170310.png)

---

### Parameters

- 지금까지의 모든 문에서 간단한 매개 변수의 예를 보았다. 매개변수는 Mybatis는 매우 강력한 요소이다. 대략 90% 정도 간단한 경우 이러한 형태로 설정할것이다.

![20210823_171940](/assets/20210823_171940.png)

---

### Result Maps

resultMap 요소는 Mybatis에서 가장 중요하고 강력한 요소입니다. JDBC 가 ResultSet에서 데이터를 검색하는데 필요한 코드의 90%를 제거할 수 있으며 , 경우에 따라 JDBC 가 지원하지 않는 작업도 수행할 수 있다.

실제로 복잡한 구문의 조인 매핑과 같은 코드를 작성하려면 수천 줄의 코드가 포함 될 수 있다.

ResultMaps 설계는 간단한 구문에는 명시적인 결과 매핑이 전혀 필요하지 않으며 복잡한 구문은 관계를 설명하는 데 필요하다.

![20210823_175638](/assets/20210823_175638.png)

![20210823_175647](/assets/20210823_175647.png)

![20210823_175656](/assets/20210823_175656.png)

---

### 동적 SQL에

- Mybatis 의 가장 강력한 기능 중 하나는 동적 SQL 기능이였다. JDBC 또는 이와 유사한 프레임워크에 대한 경험이 있는 경우 공백을 잊지 않거나 컬럼 목록의 끝에 쉼표를 생략하지 않도록 하여 SQL 문자열을 조건부로 연결하는 것이 얼마나 고통스러운지 알게 된다.

동적 SQL 은 다루기가 매우 어려울 수 있다.

동적 SQL 을 사용하는 것은 결코 쉽지 않지만 Mybatis 는 매핑된 SQL 문에서 사용할 수 있는 강력한 동적 SQL 언어로 상황을 개선한다.

동적 SQL 요소는 JSTL 또는 유사한 XML 기반 텍스트 프로세서를 사용한 모든 사람에게 친숙해야 한다. 이전버전의 Mybatis는 알고 이해해야할 요소가 많이 있었지만 mybatis3은 이 기능을 향상시켜서 작업할 요소가 절반 미만이 됐다.

- if
- choose(when, otherwise)
- trim (where, set)
- foreach

---

### 동적 SQL 사용

조립하기 위한 요소

- <where> : 조건을 만족할 시에만 SQL을 조립하도록 하는 요소
- <choose> : 여러 선택 항목에서 조건에 만족시만 SQL을 조립하게 만드는 요소
- <foreach> : 컬렉션이나 배열에 대해 반복처리를 하기 위한 요소
- <set> : SET 절 앞 뒤에 내용을 더 추가하거나 삭제시 사용하는 요소

---

### REST 서버 설계

### 스프링 부트 데이터 레스트

스프링 부트 데이터 레스트는 MVC 패턴에서 VC를 생략하고 도메인과 리포지토리로만 REST API를 제공한다.

스프링 부트 데이터레스트에서 지원하는 @RepositoryRestResource 어노테이션을 사용하여 해당 도메인의 정보를 매핑하여 REST API를 제공한다.

요구사항

- 게시글을 등록/보기/수정/삭제할 수 있어야 한다.
- 게시글의 목록을 조회할 수 있는 기능을 구현한다.

![20210824_033729](/assets/20210824_033729.png)

---

### @RestController를 통한 REST API 구현

- MVC 패턴 기반으로 RESTController를 생성하여 RESTAPI를 구현한다.

컨트롤러와 서비스를 사용하는 MVC 패턴은 세부적인 처리가 가능하고 복잡한 서비스도 처리할 수 있다.
클라이언트에 반드시 필요한 정보만 전달하고 응답상태 코드도 단순하게 설정한다.

요구사항

- 게시글 등록/보기/수정/삭제
- 게시글 목록 조회

---

### HATEOAS 적용

HATEOAS 원칙을 적용하여 클라이언트에 응답할 때 결과 데이터와 함께 관련 URI를 함께 제공한다.

REST API를 개발 HATEOAS는 반드시 구현해야 되는 것은 아니다.

![20210824_162129](/assets/20210824_162129.png)

---

### 서버 애플리케이션 패키징

- 단독서버 어플리케이션 실행을 위한 jar 파일로 패키징을 한다.

패키징
메이븐 래퍼 스크립트 실행해서 패키징.

---

### Vue.js 연동

Axios : HTTP 클라이언트 라이브러리로 비동기 방식으로 HTTP 데이터 요청을 실행한다. 내부적으로 axios는 직접적으로 XMLHttpRequest를 다루지 않고 Ajax호출할 수 있다.

- Rest Api 서버와 HTTP통신을 구현한다.
- axios 라이브러리를 설치한다.
- axios 객체를 생성하는 모듈을 구현한다
- 게시글 등록기능을 구현한다.

---

### AOP 설명

- 관점지향 프로그래밍을 의미하는 약자이다.

#### 관점지향 프로그래밍

: 소스코드의 여기저기에 흩어져 있는 횡단 관심사를 중심으로 설계와 구현을 하는 프로그래밍 기법이다.
간단하게 설명하면 관점지향 프로그래미응 ㄴ횡단 ㅗ간심사를 분리를 실현하는 방버빙다.

- 횡단 관심사(Cross- Cutting Concern)
  : 핵심 비즈니스 로지고가 다소 거리가 있지만 여러 모듈에서 공통적이고 반복적인 처리를 요구하는 내용이다.

#### AOP개발순서

1. 핵심 비즈니스 로직만 근거해서 코드를 작성한다.
2. 주변 로직에 해당하는 관심사들을 분리해서 따로 작성한다.
3. 핵심 비즈니스로직 대상 객체에 어떤 관심사들을 결합할 지 설정한다.

#### AOP 사용 예

- 로깅
- 보안적용
- 트랜잭션 관리
- 예외처리

---

### 트랜잭션

- 한번에 이뤄지는 작업의 단위를 의미한다.

#### 트랜잭션 성격 (ACID 원칙)

1. 원자성(Atomicity)
   : 하나의 트랜잭션은 모두 하나의 단위로 처리되어야 한다.
2. 일관성(Consistency)
   : 트랜잭션이 성공했다면 모든 데이터는 일관성을 유지해야 한다.
3. 격리(Isolation)
   : 트랜잭션으로 처리되는 동안에는 외부에서의 간섭이 없어야한다.
4. 영속성(Durability)
   : 트랜잭션이 성공적으로 처리되면 그 결과는 영속적으로 보관되어야 한다.

---

### 예외처리

일반적으로 프로그램이 처리되는 동안 특정한 문제가 일어났을 때 처리를 중단하고 다른 처리를 하는 걸 예외처리라고 한다.

웹 컨테이너는 기본적으로 예외처리를 하여 기본 에러 페이지를 표시해준다.

하지만 페이지에 앱서버의 내부 정보가 일반 사용자들에게 노출되어 프레임워크 보안 취약점을 노린공격을 받을 수 있따.

이런 점을 고려해서 사용자가 직접 예외 처리를해서 에러페이지를 표시하게 해야한다.

---

### 사용자 정의 예외처리를

@ExceptionHandler와 @ControllerAdvice를 이용하여 처리한다.

#### 예외처리 방법

@ControlleAdvice 어노테이션은 스프링 컨트롤러에서 발생하는 예외를 처리하는 핸들러 클래스임을 명시한다.
@ExceptionHandler 어노테이션은 괄호 안에 설정한 예외타입을 해당 메서드가 처리한다는 것을 의미한다.

#### 처리할 수 있는 예외

- 등록할 떄 제목에 빈 값을 입력하여 유효값 검증 예외 발생
- 존재하지 않는 게시물을 조회

#### 시스템 예외 처리

@ExceptionHandler와 @ControlleAdvice를 이용하여 처리한다.

예외처리방법

@ControllerAdvice 어노테이션은 스프링 컨트롤러에서 발생하는 예외를 처리하는 핸들러 클래스임을 명시한다.

@ExceptionHandler 어노테이션은 괄호안에 설정한 예외타입을 해당 메서드가 처리하는 것을 의미한다.

.
-----------


### 인터셉터

#### 인터셉터란

- 인터셉터는 웹 어플리케이션에서 특정 URI 호출을 가로채는 역할을 한다.
