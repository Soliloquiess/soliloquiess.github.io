<!-- ---
title: "[js] Node js & MongoDB part2"
layout: post
subtitle: JS
date: "2021-09-10-23:45:51 +0900"

categories: study
tags: JS
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---


### MongoDB 셋팅하기

★ 참고사항 :

접속 URL 복붙하실 때 mongodb+srv://디비계정아이디:디비계정패스워드@cluster0-qaxa3.mongodb.net/데이터베이스이름?retryWrites=true&w=majority

이거 3개를 잘 입력해야합니다.


MongoDB Atlas 가입/초기셋팅 방법


1. 구글에 Mongodb atlas 라고 검색해서 홈페이지를 방문합니다 .



2. 가입합니다. 아마 메일인증 필요





▼ 3. 뭐 채우라고 하면 잘 채워봅니다 (나중에 변경가능)

![20220405_153322](/assets/20220405_153322.png)

▼ 4. 무료 티어를 선택합니다

![20220406_124615](/assets/20220406_124615.png)

▼ 5. 서버위치를 선택합니다. 한국과 물리적으로 가장 가까운 곳을 골라줍니다.

그 밑 내용들은 아마 안건드려도 될듯요 그리고 계속 진행하면 Cluster가 생성됩니다.

![20220406_124730](/assets/20220406_124730.png)



▼ 6. Database Access 메뉴에서 DB 접속용 아이디/비번을 생성합니다.

데이터베이스 접속할 수 있는 아이디/비번을 새로 만들어주는겁니다.

왜냐면 하나의 데이터베이스를 여러사람이 사용할 수도 있으니까요.  

아주 안전해보이는 admin/qwer1234 이런 아이디 비번은 어떨까요 아무튼 만들고 잘 기억해두십시오.

![20220406_124759](/assets/20220406_124759.png)

![20220406_124814](/assets/20220406_124814.png)


▼7. Network Access 메뉴에서 IP를 추가합니다.

데이터베이스 접속할 수 있는 IP를 미리 정의해놓는 일종의 보안장치입니다.

스타벅스에서 코딩하실게 분명하니 Allow access from anywhere을 누르시거나 0.0.0.0/0 을 추가합니다.

![20220406_124839](/assets/20220406_124839.png)

![20220406_124847](/assets/20220406_124847.png)

▼8. Database / collection 만들기를 진행합니다.

Cluster는 하나의 호스팅 공간이고

거기 안에 여러분의 데이터베이스를 만들어야 데이터를 저장할 수 있습니다.

다음시간에 할 것이긴 한데 아무튼 먼저 합시다.

![20220406_124920](/assets/20220406_124920.png)

![20220406_124941](/assets/20220406_124941.png)

![20220406_124948](/assets/20220406_124948.png)
▲ 데이터베이스 이름을 맘대로 설정해주면 됩니다.

저는 이렇게 했는데 이러면 todoapp 이라는 이름의 데이터베이스가 하나 생성됩니다.

이제 이 데이터베이스를 여러분의 컴퓨터에서 접속하려면

강의에서 설명하는 접속 url을 여러분 코드에 복붙해주면 됩니다.

접속 url엔 여러분의 디비 접속용 아이디/비번/데이터베이스 이름이 들어가야합니다.

-----

###  Database라고 부르는 것이 있습니다.

그냥 데이터를 일정한 형식으로 저장할 수 있게 도와주는 곳이라고 보시면 되겠습니다.

가장 쉽게볼 수 있는게 바로 엑셀입니다.

엑셀에선 시트를 하나 만드신 후 행과 열에 원하는 데이터를 기입하면 자료 저장 끝이죠?

데이터베이스도 동일합니다.

하지만 데이터베이스는 간지나는 SQL이라는 언어를 써서 데이터를 입력, 출력합니다.




 ![20220406_141128](/assets/20220406_141128.png)

 대문자로 쓰는 이상한 언어입니다.

하지만 이걸 또 배우고 그럴 시간이 없기 때문에 우린 NoSQL이라는

SQL언어를 쓰지 않고도 쓸 수 있는 쉬운 DB를 배워보도록 합시다.



그 중 MongoDB라는 것을 사용할 것인데 그 이유는..

- 처음 다룰 때 어려운 셋팅작업이 필요하지 않음 (스키마 생성 등 필요없음)

- SQL 안배워도 됨

- 복잡한 자료형 몰라도 됨

- 평생 무료 호스팅해주는 곳이 있음

그리고 DB의 종류에 대해서도 할말이 많은데 그건 다음 강의에서 알아보도록 합시다.











MongoDB Atlas 가입 후 호스팅받기



DB를 여러분 집 컴퓨터에 설치하기도 하지만 사이트를 실제 배포할 것이라면 클라우드 서비스를 이용하는 것이 매우 안전합니다.

백업도 알아서 해주고 갑자기 사람이 터질 때 용량 걱정도 없고

그리고 무엇보다 접속 속도가 빠릅니다.

근데 이걸 무료로 호스팅 해주는 고마운 MongoDB Atlas라는 사이트가 하나 있습니다.













#### DB 접속하는 URL 찾아오기



server.js에서 DB에 접속하려면 접속 방법을 알아야겠죠?



1. 메인화면 셋팅이 끝나면 CONNECT라는 작은 흰색 버튼 누르기

2. 가운데 Connect Your Application 버튼 누르기

3. (1) Choose your driver version 에서 Node.js 선택되어있는지 잘 확인하기

3. (2) 밑에 접속 URL(Connection String) 긴게 뜨면 복사해서 일단 메모장 같은 곳에 저장해놓기



끝입니다. 이거 접속 URL만 잘 써주시면 이제 Node.js로 돌아가는 파일에서 여러분 DB와 직접 통신이 가능합니다.



Server.js에서 DB접속하려면



1. 터미널 켜서 npm install mongodb 를 입력해서 라이브러리를 설치합니다.

그냥 MongoDB 접속을 쉽게 도와주는 라이브러리입니다.

뭔가 에러가 나고 안된다면 npm uninstall mongodb 로 지웠다가

npm install mongodb@3.6.4 이렇게 설치해서 이용해보도록 합시다.



2. server.js 상단 쯤에 다음 코드를 추가합니다.

const MongoClient = require('mongodb').MongoClient;
require 라는 글자 많은 곳에 함께 위치시켜 주면 될듯 합니다.





3. 하단에 다음 코드를 입력해줍니다.
```
 MongoClient.connect('아까 챙겨온 접속URL', function(에러, client){
  if (에러) return console.log(에러);
  //서버띄우는 코드 여기로 옮기기
  app.listen('8080', function(){
    console.log('listening on 8080')
  });
})
```
접속 URL은 대충 이렇게 생겼는데

mongodb+srv://디비계정아이디:디비계정패스워드@cluster0-qaxa3.mongodb.net/데이터베이스이름?retryWrites=true&w=majority

빨간 부분 3개를 여러분이 만든걸로 잘 채워 입력해야합니다.

그리고 app.listen이라고 그 서버 띄우는 코드를 여기 안으로 옮겨주시면 되겠습니다.

그리고 터미널에서 nodemon server.js로 서버를 실행시켜보면 터미널에 listening on 8080이라고 잘 뜨죠?

아무튼 뜨면 성공입니다.

warning 이런게 뜨는건 상관없는데 에러 등이 뜨거나 listening on 8080 글자가 안뜬다면

1. 접속 URL 양끝에 따옴표 잘있는지 확인하시고

2. URL 안에 아이디 비번란에 Atlas 계정이 아니라 Database Access 메뉴에서 만든 DB 계정 넣었는지 다시 확인하시고

3. URL 내에 비번 입력시 특수문자를 넣어야하시면 (참고) 하십시오. 귀찮으면 계정만들 때 특수문자를 넣지마세요.

4. Network Access 메뉴에서 허용한 IP에서 접속하고 있는지

5. app. listen 코드를 저기로 옮긴거 맞습니까

6. 나머지는 오타입니다













또 오타났을까봐 server.js 윗부분 전체 코드

```
server.js
const express = require('express')
app.use(express.urlencoded({ extended: true }));
const app = express()
const MongoClient = require('mongodb').MongoClient


MongoClient.connect('님 접속 URL', function(에러, client){
  if (에러) return console.log(에러)
  app.listen(8080, function() {
    console.log('listening on 8080')
  })
})

//여기 이하는 쓸데없는 app.get 이런 코드들

app.get('/', function(요청, 응답) {
  응답.sendFile(__dirname +'/index.html')
})

```

---------

### Database에 자료 저장하는 법 (한줄이면 끝)


★ 2020.9월 이후 업데이트 사항 :

접속 URL 복붙하실 때 mongodb+srv://디비계정아이디:디비계정패스워드@cluster0-qaxa3.mongodb.net/데이터베이스이름?retryWrites=true&w=majority

빨갛게 표시한 3곳을 잘 입력하시면 됩니다. 데이터베이스 이름은 강의에서 todoapp이라고 만들었었네요. 그거넣으시면 됩니다.







숙제 : 누군가 /add로 POST 요청을 하면 폼에 입력된 자료를 2개가 서버로 도착합니다.

이 때 자료 2개를 post라는 이름의 collection에 저장해보도록 합시다.

{ 제목 : '어쩌구', 날짜 : '어쩌구' } 이런 Object 자료형으로 저장하시면 되겠습니다.









자료를 저장하기 위해선 일단 MongoDB에 저장할 폴더와 파일을 만드세요



여러분이 저번시간까지 접속 URL 길게 적어서 쓴건

여러분 계정에 접속하는 것이었고,

이제는 여러분 계정 안에 있는 여러가지 database와 collection에 자료를 저장할 것입니다.

우린 database 이런게 없으니까 하나 강제로 만들어보도록 합시다.









database/ collection 만들기



▼ 1. MongoDB Atlas 메인 대시보드에서 Collections 라는 버튼을 누르도록 합시다.


![20220411_143632](/assets/20220411_143632.png)


▼ 2. 이번엔 Add my own data 버튼을 누르도록 합시다. (혹은 이미 뭐가 있다면 create database)

![20220411_143801](/assets/20220411_143801.png)


3. 여러분이 database 이름, collection 이름을 예쁘게 하나씩 정해준 다음 저장을 눌러줍니다.

저는 database 이름은 todoapp

collection 이름은 post 라고 지었습니다.

database와 collection의 차이는...

![20220411_143909](/assets/20220411_143909.png)

이런 거라고 보시면 됩니다. database는 하나의 폴더, collection은 하나의 엑셀파일이라고 생각하면 딱 맞습니다.











이제 server.js 아무데나 코드를 짜서 db와 통신해보도록 합시다.



(실은 아무데나는 아니고 const 어쩌구 많은 곳 밑에 쓰셔야합니다.)
```
var db;
MongoClient.connect('접속URL', { useUnifiedTopology: true }, function (에러, client) {
	if (에러) return console.log(에러)
	db = client.db('todoapp');

	app.listen(8080, function () {
		console.log('listening on 8080')
	});
});
```
(둘째줄에 { useUnifiedTopology: true } 이건 쓰면 좋습니다. 워닝메세지를 제거해줍니다.)

이렇게 여러분 코드를 바꿔주시면 됩니다. 첫줄과 넷째줄에 코드가 추가되었죠?

var db;로 페이지 전체에서 쓸 수 있는 전역 변수를 하나 만들고,

그리고 client.db('todoapp') 이라는 이상한 함수로 todoapp 이라는 database 에 접속해주세요~라는 명령을 내렸습니다.

collection에 자료 하나 추가하는 법



세줄만 쓰시면 아까 만든 collection에 내가 원하는 자료를 추가해볼 수 있습니다.
```
var db;
MongoClient.connect('접속URL', { useUnifiedTopology: true }, function (에러, client) {
 if (에러) return console.log(에러)
 db = client.db('todoapp');

       db.collection('post').insertOne( {이름 : 'John', _id : 100} , function(에러, 결과){
     console.log('저장완료');
 });

 app.listen(8080, function () {
   console.log('listening on 8080')
 });
});
```
중간에 세줄이 추가되었습니다. DB에 자료 추가할 일이 있을 때마다 저거 세  줄 쓰시면 됩니다.

db.collection('post') 라는건 collection 중에 post 라는걸 선택한다는 뜻이고

뒤에 insertOne을 붙이시면 자료를 추가할 수 있습니다. (Object 자료형식으로 추가가능)

그리고 insertOne 함수는 insertOne(추가할 자료, 콜백함수) 이렇게 쓰시면 되겠습니다.




```
db.collection('post').insertOne()
```
이 패턴 잘 기억해주시길 바랍니다.

나중에 데이터 추가하고 삭제하고 수정할 때도 이거와 동일한 형식으로 쓸 거니까요.

(서버개발은 이해보다 패턴 외우는게 중요합니다)







몇줄에 걸친 긴 코드를 합쳐서 한번에 작성한다면
```
client.db('todoapp').collection('post').insertOne(추가할 자료, 콜백함수)
```
이렇게 쓰셔도 됩니다.


_id 라는건 왜 붙이죠?



mongoDB에선 자료들을 서로 구분하기 위해 _id가 꼭 있어야합니다.

일종의 출석번호라고 생각하시면 됩니다.

이걸 직접 집어넣으셔야 하는데

안집어넣으시면 알아서 하나 만들어줍니다.

_id : 어쩌구 이런 식으로 유니크한 아이디를 하나 자동으로 부여해줍니다.





근데 저런 이상한 문자들 보기싫으니까 보통 번호붙여 저장을 합니다.

_id : 1

_id : 2

_id : 3

이렇게 저장하는 자료들에 항상 유니크한 출석번호를 붙여서 저장을 하는게 좋습니다.

나중에 번호 붙이는 법에 대해 알아봅시다.







 -----------


### HTML에 DB데이터 꽂아넣는 법 1 (EJS)


/add로 POST요청시 DB에 저장하는 저번시간 숙제는



이렇게 코드를 짜면 되지 않을까요

```
app.post('/add', function(요청, 응답){
  응답.send('전송완료');
  db.collection('post').insertOne( { 제목 : 요청.body.title, 날짜 : 요청.body.date } , function(){
    console.log('저장완료')
  });
});
```

저번시간 데이터저장하던 예제코드를 똑같이 작성하고 안에 내용물만 살짝 바꿨습니다.

그럼 이제 폼에서 뭔가 전송시킬 때마다 DB에 데이터를 저장합니다.

그리고 참고로 응답.send() 이 부분은 항상 존재해야합니다.

전송이 성공하든 실패하든 뭔가 서버에서 보내주어야합니다. 안그러면 브라우저 멈춰요.

메세지 같은걸 보내주기 싫다면 간단한 응답코드나 아니면 리다이렉트(페이지강제이동)를 해주는 코드도 있습니다.









/list로 방문하면 ejs 파일을 보내주자



그냥 HTML 파일만 보내주면 흔히 말하는 Static페이지가 됩니다.

HTML에 실제 DB 데이터를 넣어서 보내줄 수가 없으니까요.

그래서 EJS, Pug같은 템플릿 엔진을 사용합니다.

EJS는 서버 데이터를 HTML에 쉽게쉽게 박아넣을 수 있게 도와주는 일종의 HTML 렌더링 엔진입니다.

그럼 우리도 이걸 설치해서 DB 데이터를 HTML에 박아넣어보도록 합시다.







설치는 터미널에서 npm install ejs 하시고
```
 app.set('view engine', 'ejs');
```
이걸 Server.js 상단에 적어주면 되겠습니다. const 여러개 있는 곳 바로 밑에 적으면 될듯요.


EJS 파일 만들기



EJS 파일은 그냥 html과 똑같이 만들어 쓰시면 됩니다.

근데 중간중간 EJS 문법으로 데이터를 꽂아넣을 뿐입니다.

그래서 파일을 빨리 하나 만들어봅시다.

그 전에 주의할점 : 작업폴더 내에 views라는 이름의 폴더를 하나 만드신 후

거기에 list.ejs 파일을 만드셔아합니다.

(views/list.ejs)
```
<!doctype html>
<head>
  index.html에 있던거 전부 복붙
</head>

<body>
index.html에 있던거 전부 복붙
</body>

</html>
```

다시한번 강조합니당. list.ejs 파일을 views 라는 폴더를 생성한 뒤에 거기 안에 담으셔야합니다.

그리고 내부 코드는 그냥 index.html에 있는거 전부 복붙해오시면 되겠습니다.

끝입니다.











EJS 파일 기본적인 문법



당장 쓸 것 딱 두개만 알려드리겠습니다.
```
<h2><%= user.name %></h2>
```
HTML 중간중간에 서버 데이터를 집어넣고 싶을 땐 이렇게 사용합니다.
```
<%= 서버에서 보낸 데이터의 변수명 %>
```
그럼 HTML 글자로 렌더링 됩니다. 끝입니다.





EJS를 사용하면 HTML에 여러가지 자바스크립트 문법을 사용가능합니다.
```
<% if (user) { %>
  <h2><%= user.name %></h2>
<% } %>
```
HTML에 if문을 적용하거나 반복문을 적용하고 싶을 땐

<% %> 내부에 자바스크립트 문법을 담으시면 됩니다.
위의 예제 코드는 user 라는 변수가 참일 때만 내부 h2 코드를 보여줄 것입니다.


### HTML에 DB데이터 꽂아넣는 법 2 (DB데이터 읽기)


저번시간 이번시간에 어떤 흐름으로 코드를 짜는지 잠깐 요약정리하자면

1. 누군가 /list로 GET 요청을 하면

2. MongoDB에서 데이터를 꺼낸 뒤에

3. list.ejs 파일에 그 데이터를 꽂아넣어서 고객에게 보내줌

이렇게 코드를 짜고 있습니다.









MongoDB에서 데이터를 꺼내고 싶다면



db.collection('post').find()

db.colleciton('post').findOne()

이런 식으로 쓰시면 데이터를 꺼낼 수 있습니다.

근데 우리는 "post 콜렉션에 저장된 모든 데이터를 가져와주세요~" 라고 명령을 주고 싶습니다. 그렇다면 이렇게 칩니다.



(server.js)
```
app.get('/list', function(요청, 응답){
  db.collection('post').find().toArray(function(에러, 결과){
    console.log(결과)
    응답.render('list.ejs')
  })
})
```
저번시간 코드를 이렇게 업데이트하면 되겠군요.

.find().toArray() 라고 적으시면 collection('post')에 있는 모든 데이터를 Array 자료형으로 가져옵니다.

[자료1, 자료2 ...] 이런 식으로 담겨오게 됩니다. 궁금하면 결과라는 변수를 콘솔창에 출력해보십시오.

그리고 자료들이 안오거나 에러나면 실제 DB에 데이터 몇개가 제대로 저장되어 있는지 확인합시다.

DB 데이터가 오염되어있거나 그러면 원하는대로 보이지 않을 수 있으니까요.




#### 데이터를 list.ejs 파일에 보내고 싶다면?



그리고 가져온 데이터를 list.ejs 파일로 보내주면 이제 접속자들이 그 데이터들을 볼 수 있겠죠?



(server.js)
```
app.get('/list', function(요청, 응답){
  db.collection('post').find().toArray(function(에러, 결과){
    console.log(결과)
    응답.render('list.ejs', { posts : 결과 })
  })
})
```
.render()라는 함수에 둘째 파라미터를 요로케 적어주시면

list.ejs 파일을 렌더링함과 동시에 {posts: 결과} 라는 데이터를 함께 보내줄 수 있습니다.

(정확히 말하면 결과라는 데이터를 posts 라는 이름으로 ejs 파일에 보내주세요~ 입니다)


그러면 이제 list.ejs 파일에서 데이터를 가지고 여기저기 쑤셔 집어넣는 일만 남았군요.









#### 데이터를 가지고 EJS 파일을 꾸며보자



(views/list.ejs)
```
<h4>임시 제목</h4>
<p>임시 날짜</p>

<h4>임시 제목</h4>
<p>임시 날짜</p>
```
대충 이런 HTML 몇개를 만들어 주시고 여기에 데이터를 꽂아넣으면 되겠습니다.





(views/list.ejs)
```
<h4><%= posts %></h4>
<p><%= posts %></p>

<h4>임시 제목</h4>
<p>임시 날짜</p>
```
posts 까지만 꽂아도 뭔가 나오죠? 아까 결과라는 데이터를 posts 라는 이름으로 여기에 보냈으니까요.

근데 결과라는 데이터는 출력해보시면 [{어쩌구}, {어쩌구}] 이런 식으로 되어있으니

원하는 제목과 날짜 데이터를 출력하려면



(views/list.ejs)
```
<h4><%= posts[0].제목 %></h4>
<p><%= posts[0].날짜 %></p>

<h4><%= posts[1].제목 %></h4>
<p><%= posts[1].날짜 %></p>
```
이런 식으로 쓰시면 되겠습니다. 기본적인 Object, Array에서 원하는 자료를 뽑는 문법이니 설명은 패스합니다.

에러나면 실제 DB에 데이터 몇개가 제대로 저장되어 있는지 확인합시다. (두번째 강조)







#### 반복문을 사용하자



반복되는 코드를 발견하면 반복문으로 축약할 수 있습니다.

(views/list.ejs)
```
<% for (var i = 0; i < 2; i ++) { %>
 <h4><%= posts[0].제목 %></h4>
 <p><%= posts[0].날짜 %></p>
<% } %>
for (var i = 0; i < 반복시킬 횟수; i++) { 반복시킬 코드 }
```
자바스크립트에선 이렇게 반복문을 씁니다.

그리고 EJS 안에서 자바스크립트 문법을 쓰실 땐 <% %> 내부에 담으셔야합니다.

그럼 위의 예제코드에 따르면 내부 코드가 2번 반복됩니다.

새로고침 해보시면 제목이 2개 생기죠?





근데 문제가 있죠? 같은 제목이 2번 반복됩니다.

반복할 때마다 각각 다른 제목을 출력시키고 싶으면 i라는 변수를 활용합니다.  

(views/list.ejs)
```
<% for (var i = 0; i < posts.length; i ++) { %>
 <h4><%= posts[i].제목 %></h4>
 <p><%= posts[i].날짜 %></p>
<% } %>
```
i 라는 변수는 반복문이 돌 때마다 0,1,2,3 ... 이렇게 차례로 나아가는 변수라고 보시면 됩니다.

그래서 이걸 써주면 각각 다른 제목을 출력해줄 수 있겠군요.





그리고 반복문 안의 인자를
```
for (var i = 0; i < posts.length; i ++) { 반복시킬 코드 }
```
이렇게 바꿔주면

아까처럼 항상 2번만 도는게 아니라 posts 갯수만큼 반복문이 돌게 되니까 확장성 있는 코드가 되겠군요.


----------


### 심심할 때 읽어보는 DB의 종류와 특징

데이터베이스는 전통이 매우 깊습니다.

과거엔 계층형, 네트워크 이런 데이터베이스들이 있었고 최근들어 Graph 이런 데이터베이스까지도 등장했습니다.

하지만 현재 실제 웹서비스 개발시 이용하는 데이터베이스는 대부분 이 둘 중 하나로 분류합니다.

관계형 데이터베이스, NoSQL 데이터베이스인데 이게 무엇인지 상세히 알아보도록 합시다.





1. 관계형(Relational) 데이터베이스



정의

80년대 부터 흥하기 시작해서 아직까지도 사용하고 있는 데이터베이스의 표준 같은 데이터베이스입니다.

관계형 데이터베이스는 짧게 요약하자면

엑셀처럼 행과 열로 데이터를 저장할 수 있는 데이터베이스를 뜻합니다.





어떻게 생겼나

엑셀의 시트처럼생긴 테이블이라고 부르는 공간을 하나 생성한 다음

행과열에 맞춰 데이터를 쭉 저장합니다.

생긴 것도 엑셀처럼 생겼습니다.


![20220411_182809](/assets/20220411_182809.png)

특징

- 거의 모든 곳에 사용할 수 있어 범용적입니다.  

- 구조화된 데이터를 저장하기 가장 좋습니다.

- 보통 SQL이라는 언어를 이용해 데이터를 출력 입력합니다.

- "이 열엔 숫자가 들어옵니다~"라고 스키마를 미리 정의하기 때문에 관리가 쉽습니다.

- 구조화된 데이터 덕분에 원하는 데이터 뽑기도 쉽습니다.  

- 트랜잭션 롤백 이런 기능을 이용해 데이터의 무결성을 보존하기 쉽기 때문에 금융, 거래 서비스에 필수입니다.







도대체 Relational 이라는게 무슨 뜻인가

데이터들 간의 관계를 정해서 데이터를 저장할 수 있다라는 뜻입니다.

뭔 소리인지 예를 들어보도록 합시다.



학교를 운영하는데 학교 선생님들과 가르치는 과목 정보를 DB에 저장하려고 합니다.



 ![20220411_182839](/assets/20220411_182839.png)

 선생님마다 가르치는 과목들을 이렇게 저장할 수 있겠죠?

그런데 손흥민 선생님이 가르치는 과목이 많아지면 어떻게 DB에 저장하는게 좋을까요?

![20220411_182854](/assets/20220411_182854.png)

▲ 대충 이렇게 저장하면 될까요?

아마 나중에 데이터 꺼내쓸 때 문제가 있겠죠. 좋은 생각은 아닙니다.

손흥민 선생님 행을 하나 더 만든다고 해도 문제가 많겠죠. 선생님 번호 중복이 마구 생길 것 같습니다.

이것이 테이블 형 데이터베이스의 단점인데, 데이터가 3차원으로 늘어나게 되면 2차원의 테이블 내에서 제대로 표현할 수가 없게 됩니다.

그래서 테이블을 하나 더 만든 후 테이블간의 관계를 지어줍니다.

![20220411_182916](/assets/20220411_182916.png)

이건 어때보입니까. 테이블을 하나 더 만들어서

왼쪽엔 선생님 관리하는 테이블,

오른쪽은 과목 관리하는 테이블입니다. 그리고 과목에 선생님 번호를 적어서 어떤 선생님이 가르치는지 관계를 지어준 것이고요.

이게 바로 관계형 데이터베이스의 특징이자 구축방법입니다.

관계의 종류도 있는데  

- one to one, one to many, many to many

이런 관계들이 있습니다.

DB처리자격증 딸 것도 아니니 여기까지 하겠습니다.









2. NoSQL 데이터베이스



정의

용어자체는 약간 범용적입니다. SQL문없이도 사용할 수 있는 데이터베이스라고 보시면 됩니다.

대부분 테이블에 국한되지 않고 자유로운 형식으로 데이터를 쉽게 분산저장할 수 있습니다.

![20220411_182940](/assets/20220411_182940.png)

종류

종류는 매우 여러가지 입니다.

- Key-value 모델 : Object, JSON 자료형 형식으로 데이터를 쉽게쉽게 저장, 출력이 가능합니다. 가장 심플함

- Document 모델 : 테이블 대신 Collection이라는 문서 기반으로 데이터를 분류하고 저장합니다. 테이블보다는 훨씬 유연합니다.

(우리가 사용하고 있는 MongoDB도 Key-value, Document 모델 저장방식을 차용하고 있습니다)

- Graph 모델 : 데이터를 노드의 형태로 저장하고 노드간의 흐름 또는 관계를 저장할 수 있습니다.

- Wide-column 모델 : 한 행마다 각각 다른 수, 다른 종류의 열을 가질 수 있습니다. (스키마가 자유로움)







특징

1. Scaling이 쉽다는 장점이 있습니다.

찰나의 순간에 대량의 데이터를 저장해야한다면 어떻게할까요?

기존 올드한 관계형 데이터베이스는 확장이 매우 어렵습니다. 보통 scale up 이라는 방법으로 서버의 성능을 키워야합니다.

하지만 대부분의 NoSQL 데이터베이스는 scale out이라는 방법으로 데이터를 분산저장하는 걸 기본적으로 지원합니다.

확정 걱정할 필요없이 쉽게 쉽게 데이터 입출력에만 신경쓸 수 있는 것이죠.

그래서 대량의 데이터를 빠르게 입출력해야한다면 NoSQL이 제격입니다.

(관계형 데이터베이스도 요즘은 분산저장 대충 잘합니다)



2. 대부분 다루기가 쉽습니다.

SQL 이라는 언어를 새로 배우지 않아도 데이터를 쉽게 입출력할 수 있습니다.

자바스크립트 object{} 자료형 다루듯이 데이터를 입출력할 수 있으니 사용자에게 매우 편리하죠.

그리고 여러분이 서버에서 쓰던 프로그래밍 언어로 DB를 다룰 수 있다는 장점이 있습니다. MongoDB도 그러고 있죠?



3. 대부분 스키마 정의 없이도 쉽게 쓸 수 있습니다. (이 열의 데이터는 정수입니다~ 라고 표현하는 짓거리 안해도 됨)

장점이자 단점일 수 있습니다. 그래서 MongoDB에선 스키마를 미리 정의하기 위한 Mongoose같은 라이브러리를 추가해서 사용하기도 합니다.



4.  NoSQL 데이터베이스는 기본적으로 SQL에서의 JOIN 연산을 적용하는게 기본적으로 어렵습니다.

서버 단에서 JOIN 연산을 쉽게 처리해주는 라이브러리를 이용합니다.

이건 뭔지 모르면 스킵합시다.













아까 relational 데이터베이스의 문제도 나름 쉽게 해결할 수 있습니다.




![20220411_183006](/assets/20220411_183006.png)

▲ 여기서 손흥민 선생님이 가르치는 과목이 수학, 영어 이렇게 2개로 늘어나야하면 어떻게 코드를 짜야할까요?

NoSQL의 대표 주자인 MongoDB에선 그냥 ['수학', '영어'] 이걸 array로 만들어서 저 자리에 그냥 집어넣으시면 됩니다.

얘는 DB에 array, object 집어넣는건 자유니까요.









물론 MongoDB에서도 Relational Database처럼 관계를 표현해 저장하기도 합니다.



뭐 예를 들어서 게시물을 만들었는데

거기 달린 댓글도 저장해야한다고 칩시다.

그럼 게시물 document 안에 댓글란도 만들면 되겠네요?


![20220411_183026](/assets/20220411_183026.png)

▲ 편의상 엑셀로 표현해봤습니다. (가로줄 하나가 document 하나입니다)

array 자료 쓸 수 있다니까 이렇게 써본 것입니다. 훌륭합니다.

하지만 게시물 하나가 댓글이 1억개가 되면 문제가 생깁니다.

한 게시물에 댓글 1억개를 어떻게 array에 저장할 것임

(실은 MongoDB document 하나의 최대 용량이 16mb 라서요)

![20220411_183041](/assets/20220411_183041.png)

▲ 이렇게 만드는건 어떨까요.

댓글용 collection (table)을 하나 더 만들었습니다.

거긴 댓글을 전부 밀어넣어두는 곳인데 어떤 게시물에 달린 댓글인지 부모 게시물 번호도 함께 저장했습니다.

그럼 나중에 0번 게시물 + 댓글을 불러오고 싶으면

1. 우선 0번 게시물 불러오고

2. 부모게시물번호가 0인 댓글도 전부 찾아오면 되는 것입니다.

뭔가 1억개 중에 번호 0을 가진 댓글을 찾아야하니 오래걸릴 것 같지만 DB는 검색 빨리빨리 잘해줍니다.

아무튼 MongoDB도 이런 식으로 관계형스럽게 개발하면 편리할 수 있습니다.















두 데이터베이스가 공존하는 이유는 바로 각각의 명확한 장점 때문입니다.

정규화된 데이터와 안정성이 필요하다면 관계형 데이터베이스를 사용합니다.

금융서비스를 만든다, 은행 전산시스템을 만든다면 당연히 안정적인 관계형이 최고입니다.



하지만 일초에 수백만개의 데이터 입출력 요청이들어오는 SNS 서비스를 만들 때,

뭔가 서비스의 변경사항이 잦아서 쉽고 유연하게 데이터를 저장하고 싶으면 NoSQL을 사용합니다.

실제로 Facebook은 이런 대량의 데이터를 저장하기 위해 HBase 데이터베이스를 이용해 분산저장합니다.











요즘은 블록체인같은 새로운 형태의 데이터 저장 방법들이 등장하고 있습니다.

블록체인이 뭐냐면..

여러분이 멋진 음반을 하나 발표했다고 칩시다. 그래서 멜론, Vibe 이런 곳에 음원을 판매등록했습니다.

그래서 멜론에서 이번달엔 500회 재생했습니다~ 라는 기록에 따라 저작권료를 정산받습니다.

하지만 멜론같은 스트리밍 사이트의 음원 재생기록을 믿을 수 있겠습니까?

멜론 CEO 입장에서 멜론의 DB를 조작한다면 정산금액을 일부러 낮추어 비용을 줄일 수도 있잖아요?





그래서 블록체인이라는 거래장부 저장형식이 등장합니다.

전세계 모든 사람이 거래내역을 저장하고 관리해줄 수 있습니다.

관리해주는 대가로 비트코인을 지급받고요.  

블록체인 장부를 살펴보면 A가 B에게 1코인을 지급했다~ 라는 내용이 전부입니다. 물론 A의 정보는 암호화되어있고요.

덕분에 거래내역의 투명성과 익명성과 공정성을 보장해줍니다.

여러분이 많이 들어본 이더리움, 비트코인이 그런 장부를 사용하고 있습니다.





지금은 처리시간, 스케일링, 수수료 문제 등 특유의 비효율성 때문에 실용화되진 못하고 있지만

언젠가는 효율적인 블록체인 장부저장 시스템도 실생활에서 구경해볼 수 있을 것입니다.





 --------



### 게시물마다 번호를 달아 저장하려면




_id를 달아서 저장합시다.



MongoDB에 데이터를 저장할 땐 _id라는 값을 꼭 넣으셔야합니다. 그래야 삭제도 쉽고 나중에 수정도 쉬우니까요.

아까 모르고 안넣으셨다고요? 괜찮습니다.

안넣으시면 MongoDB에서 알아서 ObjectId() 어쩌구 이런걸 만들어서 아이디를 강제로 부여해줍니다.  

무작위의 숫자와 문자로 이루어져있는데

이게 싫으면 애초에 저장할 때 직접 _id를 강제로 달아주셔도 됩니다.





몇강 전에 작성했던 post 요청 처리하는 서버코드를 다시 살펴봅시다.

```
app.post('/add', function(요청, 응답){
  응답.send('전송완료');
  db.collection('post').insertOne( { _id : 1, 제목 : 요청.body.title, 날짜 : 요청.body.date } , function(){
    console.log('저장완료')
  });
});
```


위의 코드에 주황색으로 표시된 부분을 새로 추가했습니다.

insertOne 함수 안에 _id : 1 이라는 항목을 요로케 써주시면... 번호달아서 저장하기 끝입니다.





그런데 1이라고 하드코딩을 해버렸네요. 글 쓸 때마다 항상 _id : 1일 수는 없죠?

2번째 글이면 _id: 2,

3번째 글이면 _id : 3이 되어야 합니다.









다른 DB에선 _id를 자동으로 1증가시켜서 추가해주세요~ 이런 기능이 있는데 (Auto Increment라고 합니다)

MongoDB는 그런거 없습니다. (실은 별로 필요없어서 그렇습니다. 정수말고 자동으로 부여되는 ObjectId도 전혀 문제없음)

그래서 여러분이 직접 지금까지 몇번 게시물을 발행했는지를 어딘가에 기록해두셔야합니다.

그리고 방금 코드를 이렇게 바꾸면 되겠죠?

```
app.post('/add', function(요청, 응답){
  응답.send('전송완료');
  db.collection('post').insertOne( { _id : 지금까지 발행한 게시물 갯수 + 1, 제목 : 요청.body.title, 날짜 : 요청.body.date } , function(){
    console.log('저장완료')
  });
});
```

_id : 1 이라고 하드코딩 하지 말고 위 코드 처럼 바꾸면

글을 하나 발행할 때마다 유니크한 _id가 부여되겠군요.











지금까지 몇번 게시물을 발행했는지 기록합시다.  



여러분 mongodb atlas 홈페이지 들어가셔서 대시보드에서 collection을 하나 더 만들도록 합시다.

![20220425_091727](/assets/20220425_091727.png)

좌측에 여러분 todoapp이라는 데이터베이스에 + 버튼을 누르시면 collection(파일)을 하나 더 생성 가능합니다.

counter라는 이름을 가진 collection을 생성합시다.



![20220425_093300](/assets/20220425_093300.png)

방금 새로만든 counter라는 콜렉션에 데이터를 하나 강제로 집어넣어봅시다.



![20220425_093320](/assets/20220425_093320.png)

우측에 보면 Insert Document 흰버튼을 누르시면 강제로 항목을 하나 추가 가능합니다.

그리고 이렇게 그대로 작성한 후 Insert 버튼을 누르면 되겠습니다.

(totalPost 라는 항목은 Int32로 셋팅하는거 잊지마세요)





이게 바로 여러분이 지금까지 몇번 게시물을 발행했는지를 기록할 공간입니다.

totalPost라는 곳에 저장할 것입니다.

지금은 아무 게시물도 발행되지 않았다고 생각하고 초기값은 0이라고 합시다.









그럼 아까 POST 요청 처리하는 코드를 수정해야겠군요



그리고 방금 코드를 이렇게 바꾸면 되겠죠?

```
app.post('/add', function(요청, 응답){

  counter라는 콜렉션에서 totalPost라는 총 게시물 갯수 숫자를 가져와서
  var 총게시물갯수 = 여기에 저장함
  그 다음에 밑에 코드 실행
  db.collection('post').insertOne( { _id : (총게시물갯수 + 1), 제목 : 요청.body.title, 날짜 : 요청.body.date } , function(){
    console.log('저장완료')
    응답.send('전송완료');
  });
});

```


한글로 예쁘게 적은 부분을 자바스크립트 코드로 그대로 번역만 하시면 되겠습니다.

구글 검색만 잘 하면 번역따위 쉽게 쉽게 가능합니다.

```
app.post('/add', function(요청, 응답){
  db.collection('counter').findOne({name : '게시물갯수'}, function(에러, 결과){
    var 총게시물갯수 = 결과.totalPost;
    db.collection('post').insertOne( { _id : (총게시물갯수 + 1), 제목 : 요청.body.title, 날짜 : 요청.body.date } , function(){
      console.log('저장완료')
      응답.send('전송완료');
    });
  });

});
```


1. findOne함수를 쓰시면 collection 내에서 내가 원하는 문서를 쉽게 찾을 수 있습니다.

쓰는 법은 강의를 참고합니다. 그럼 찾은 결과는 function내의 결과라는 이름의 변수에 담겨옵니다.

2. 그럼 아까 저장한 totalPost라는 자료도 출력가능합니다. 그걸 총게시물갯수 변수에 저장합니다.

3. 그리고 그 다음에 post라는 콜렉션에 insertOne을 써서 제대로된 _id와 함께 자료를 저장합니다. 끝!

4. 그리고 응답.send 라는 코드를 이용해 응답해줍니다. (응답.어쩌구는 꼭 들어있어야합니다)







이런 긴 코드는 무슨 예술작품처럼 한눈에 보고 이해하려하시면 안됩니다.

위에서 부터 한줄한줄 읽어나가셔야합니다.

그럼 이해를 돕기 위해 위 코드를 차례로 다시 설명해드리자면

```
app.post('/add', function(요청, 응답){
  db.collection('counter').findOne({name : '게시물갯수'}, function(에러, 결과){
    var 총게시물갯수 = 결과.totalPost;
    db.collection('post').insertOne( { _id : (총게시물갯수 + 1), 제목 : 요청.body.title, 날짜 : 요청.body.date } , function(){
      console.log('저장완료')
      응답.send('전송완료');
    });
  });

});
```

1번줄 : 누군가 /add 경로로 post 요청을 하면

2번줄 : counter라는 콜렉션에서 총게시물갯수 저장해놓은 문서를 찾습니다. 그 찾은 문서는 결과라는 변수에 담겨옵니다.

3번줄 : 결과.totalPost하면 총게시물 갯수가 뿅하고 출현합니다. 그걸 var 총게시물갯수 변수에 저장해서 사용합니다.

4번줄 : 이제 글저장 시간입니다. post라는 콜렉션에 insertOne을 이용해 게시물을 추가합니다. 추가할 때 _id를 var 총게시물갯수를 이용해 제대로 부여해줍니다.

6번줄 : 성공했다고 응답.send로 브라우저에게 글자를 보냅니다. 응답.render, 응답.redirect 이런 것도 이용가능합니다.





근데 뭔가 하나의 기능이 빠져있습니다.

4번줄에서 글을 잘 발행했다면...

counter라는 콜렉션 내의 'totalPost'라는 값도 1 증가시켜야하겠는데요?

(totalPost가 총게시물갯수 세는 역할이라면서요.)

그러면 어떻게 하는지 다음 시간에 알아보도록 합시다.

근데 솔직히 이것도 구글과 함께라면 여러분 충분히 혼자 가능합니다.

----


### 게시물마다 번호 달기 2 : DB Update 함수와 inc 연산자

DB 데이터를 수정하고 싶으면 updateOne을 쓰시면 됩니다.



counter라는 콜렉션 내의 자료를 수정하고 싶으면 이렇게 하시면 됩니다.

```
db.collection('counter').updateOne( {요런 이름의 자료를} , {이렇게 수정해주세요} , function(에러, 결과){
  console.log('수정완료')
})
```
updateOne 함수엔 파라미터가 세개가 필요합니다.

왼쪽엔 { name : '게시물갯수' } 이렇게 자료를 찾을 수 있는 이름이라든지 쿼리문을 적어주면 됩니다.



가운데는 여러분이 수정할 값을 입력해주시면 됩니다. 그런데 약간 특이합니다.

{ $set : { totalPost : 100 } } 이렇게 넣어서 값을 아예 100으로 변경할 수도 있고

{ $inc : { totalPost : 5 } } 이렇게 넣어서 값을 5만큼 더해줄 수도 있습니다.

$ 표시 붙은게 바로 operator 라는 문법입니다. 여러 종류가 있으니 나머지는 필요할 때 찾아쓰도록 합시다.



오른쪽은 그냥 콜백함수입니다. 수정이 실패나 성공시 실행할 코드를 안에 담으시면 됩니다

##### 그럼 데이터를 1 증가시키려면 이렇게 하면 되겠군요.

![20220425_093804](/assets/20220425_093804_xe72ehsk2.png)

▲ 위의 totalPost라는 데이터를 1 증가시켜봅시다.


```
db.collection('counter').updateOne( {name : '게시물갯수' } , { $inc : { totalPost : 1 } } , function(에러, 결과){
  console.log('수정완료')
})
```
이 코드를 실행하면 totalPost라는 항목이 1 증가합니다. 끝!

이 코드를 언제 실행시켜야합니까



언제겠습니까. 글을 하나 발행할 때 아니겠습니까.
```
app.post('/add', function (요청, 응답) {
  db.collection('counter').findOne({name : '게시물갯수'}, function(에러, 결과){
    var 총게시물갯수 = 결과.totalPost

    db.collection('post').insertOne({ _id : 총게시물갯수 + 1, 제목 : 요청.body.title, 날짜 : 요청.body.date }, function (에러, 결과) {
      db.collection('counter').updateOne({name:'게시물갯수'},{ $inc: {totalPost:1} },function(에러, 결과){
	if(에러){return console.log(에러)}
        응답.send('전송완료');
      })
    })

  })
})
```
이렇게 글 발행해주는 코드 안에 뿅하고 집어넣어주시면 되겠습니다.



이 긴 코드를 읽고 해석하려는 시도는 안하는게 좋습니다. 남의 코드 읽고 해석하는게 가장 어렵습니다.

참고해서 여러분 코드를 완성시키면서 이해하시면 되겠습니다.

굳이 읽으시려면 한줄한줄 한글로 해석하면서 읽어보시길 바랍니다. 단어하나 놓치지 말고 전부 다 한글로 번역해보세요.



한글로 설명할 수 없는 코드가 있다면 큰 문제입니다. 다음 강의 듣는 것 보다 이전 강의 복습 잘해보시면 되겠습니다.




----


### AJAX로 삭제요청하기 1 (HTML 파일 구성)


시작하기 전에 일단 list.ejs 페이지를 예쁘게 꾸며보도록 합시다.



있어보이는 HTML이 코드 짜기도 좋다고 했으니

list.ejs 파일을 약간만 다듬고 삭제버튼도 추가해보도록 합시다.

(list.ejs 요로케 수정)
```
<ul class="list-group">
  <% for (var i = 0; i < posts.length; i++){ %>
  <li class="list-group-item">
    <h4> 할일 제목 : <%= posts[i].제목 %> </h4>
    <p> 할일 마감날짜 : <%= posts[i].날짜 %> </p>
    <button>삭제</button>
  </li>
  <% } %>
</ul>
```
Bootstrap 홈페이지에 있는 list group 이라는 UI를 그대로 따와서 만든 것입니다.

여러분의 ejs파일도 이렇게 비슷하게 업데이트 해보시고 시작하시면 되겠습니다.

서버를 띄워봤는데 이상한 에러메세지가 뜬다면 EJS <% %>문법이 잘못된 것이니 잘 살펴보십시오.

이제 삭제버튼을 누르면 DELETE 요청을 하도록 코드를 짤 것입니다.

간지나는 AJAX를 써서 삭제요청을 해보도록 합시다.



요청은 4개 종류가 있다고 했습니다. GET POST PUT DELETE

하지만 HTML 폼에서 일반적으로 PUT DELETE 요청을 할 수는 없습니다.
```
<form method="DELETE">
  <button>버튼</button>
</form>
```
이런거 안됩니다. 일반적인 HTML 폼 안에선 GET, POST 요청밖에 못날립니다.

(HTML이라는 언어를 만들 때 잘못 만든 겁니다)

그래서 삭제요청을 할 때 쓸 수 있는 3가지 방법이 있습니다.

1. method-override 라이브러리의 도움을 받는다

2. AJAX로 DELETE 요청을 날린다

3. 그냥 POST요청을 날려서 DELETE 작업을 수행한다

우린 2번 방법으로 해보도록 합시다.

실은 3번이 가장 편합니다. POST로 삭제하라고 요청해도 전혀 상관 없습니다.

근데 REST한 API를 만들기 위해 1번과 2번을 쓰는 것일 뿐입니다.









#### AJAX 는 무엇인가



실은 별거 아닌데 프론트엔드에서 JavaScript를 이용해 서버에 여러가지 요청을 할 수 있는 문법 같은 것입니다.

장점은 새로고침 없이도 서버에 몰래몰래 요청을 할 수 있습니다.

그래서 새로고침이 없는 스무스한 사이트를 만들고 싶으면 많은 요청을 AJAX 문법을 이용해 처리하게 됩니다.

그래서 이걸 써서 개발하면 삭제 버튼을 누르는 순간 새로고침 없이도 글 삭제가 가능합니다.

개멋있겠죠?









#### AJAX를 쓰기 위한 jQuery 설치



쌩 자바스크립트로도 AJAX가 가능하지만 코드가 길어서 정신건강을 위해 jQuery를 설치합니다.

실은 근데 이미 설치가 되어있습니다.

여러분 list.ejs 파일에 Bootstrap이 정상적으로 설치가 잘 되었다면

이런 코드를 발견하실 수 있습니다.



(list.ejs 하단)
```
<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="어쩌구" crossorigin="어쩌구" ></script>
```
이 코드가 바로 jQuery를 CDN 방식으로 설치하는 부분이라고 보시면 되겠습니다.

(CDN은 다른 사이트에서 호스팅해주는 jquery 파일을 내 HTML에 적용해주세요~ 라는 뜻입니다.)

하지만 그냥 쓸 순 없습니다. jQuery Slim 버전인데 이걸가지고 AJAX요청이 불가능합니다.

빨리 이 부분을 이렇게 수정합니다.




```
<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
```
1. slim이라는 글자를 지우고 2. 뒤에 있는 이상한 긴 글자들을 제거합니다.

이렇게 써주셔야 정상적으로 AJAX 기능이 들어있는 jQuery 라이브러리를 설치할 수 있습니다.

이제 이거 하단에 코드 이렇게 짤겁니다.




```
<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script>
 서버에 AJAX DELETE요청 날려주세요~
</script>
```
알겠쥬?

(주의) jQuery 설치 파일보다 하단에 script 태그를 열어서 작성하셔야 잘 작동됩니다.

이거 안지키고 에러난다고 그러면 답안해줌









#### AJAX 기본 문법



이렇게 치십시오.

(list.ejs 하단)
```
<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script>
 $.ajax({
   method : 'POST',
   url : '/add',
   data : '결혼하기'
 })
</script>
```
지금 뭘 쓴거냐면.. /add 경로로 POST 요청을 하는데 요청과 함께 '결혼하기' 라는 데이터를 보내주세요~ 라는 것입니다.

그럼 서버는 요청을 처리해줍니다. 이게 AJAX 기본 문법 끝입니다.

이 코드는 언제 실행되냐면.. script 태그 안에 그대로 넣으시면 list.ejs 페이지를 방문할 때 마다 바로 실행됩니다.

근데 새로고침 현상이 없으니 요청이 성공한지 실패한지 전혀 모르죠?







그래서 완성형 문법을 공개합니다. 이렇게 치십시오.

(list.ejs 하단)
```
<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script>
 $.ajax({
   method : 'DELETE',
   url : '/delete',
   data : '1번게시물'
 }).done(function(결과){
   AJAX 성공시 실행할 코드는 여기
 }).fail(function(에러){
   실패시 실행할 코드는 여기
 });
</script>
```
/add 경로로 POST 요청을 하는데 요청과 함께 '1번게시물' 이라는 데이터를 보내주세요~ 라고 썼습니다.

그리고 뒤에 .done .fail 이런 함수들을 붙여서 쓰실 수 있는데

각각 설명은 위에 한글로 잘 나와있군요.

AJAX가 필요할 때마다 이거 그대로 복붙해서 쓰시면 됩니다.









그럼 서버는 이런 코드를 작성하면 삭제기능이 완성되지 않을까여



(server.js)
```
app.delete('/delete', function(요청, 응답){
 DB에서 글 삭제해주쇼
 응답.send('삭제완료')
});
```
어떤 사람이 /delete경로로 DELETE 요청을 하면 ~~ 해주세요 라고 코드를 짰습니다.

안에는 어떤 내용이 들어가야할까요?

아마 "DB에서 글삭제해주세요~"가 아닐까여?

그럼 다음시간에 완성시켜보도록 합시다.


-------


### AJAX로 삭제요청하기 2 (서버는 뭘해야하나)


게시물 번호를 보내려면 어떻게 합니까



AJAX로 DELETE 요청시 가장 중요한 내용이 있습니다.

여러분이 원하는 게시물을 삭제하고 싶으면 AJAX요청을 할 때

삭제 원하는 게시물 번호를 보내십시오.

(게시물 번호는 우리가 예전에 _id : 1 뭐 이런식으로 DB에 저장해놨응게 그걸 보내십쇼)



(list.ejs)
```
<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script>
  $.ajax({
    method : 'DELETE',
    url : '/delete',
    data : { _id : 1 }
  }).done(function(결과){
    AJAX 성공시 실행할 코드는 여기
  })
</script>
```
data : {} 부분에 삭제를 원하는 게시물 아이디를 적어 보내면 좋을 것 같습니다.

지금은 테스트해야하니 대충 _id : 1이라고 적어봅시다.











그럼 서버는 어떤 코드를 짜야 게시물이 삭제될까



이런 코드가 아닐까요. 빨리칩시다.

(server.js)
```
app.delete('/delete', function(요청, 응답){
  db.collection('post').deleteOne(요청.body, function(에러, 결과){
    console.log('삭제완료')
  })
  응답.send('삭제완료')
});
```
deleteOne 함수를 쓰면 원하는 데이터를 삭제 가능합니다.

deleteOne(삭제원하는 데이터이름, function(){} ) 이렇게 쓰시면 됩니다.

그리고 AJAX요청시 data : { _id : 1 } 이라고 적은 정보는 요청.body라는 곳에 담겨옵니다.

그래서 그 정보를 그대로 deleteOne에 집어넣으면 { _id : 1 }이라는 게시물을 삭제할 수 있겠죠?


근데 삭제가 안됩니다요



(원래 잘 안될 때 deleteOne 콜백함수 내 에러나 결과라는 파라미터를 출력해보시면 됩니다.)

삭제가 안되는 이유는 당연히 deleteOne 내에 잘못된 데이터를 집어넣어서가 아닐까요?

대충 출력해보니 DB에 저장된 { _id : 1 } 이라는 아이디는 숫자고

AJAX로 보낸 데이터를 (요청.body) 출력해보면 { _id : '1' } 이렇게 문자입니다.



Q. 전 분명 AJAX코드에서 { _id : 1 }를 보냈는데 왜 바뀌어있죠?

AJAX요청 등으로 데이터를 서버에 전송할 때 숫자 자료들이 가끔 문자화 되는 경우가 있습니다.

그래서 사기행위에 당황하지 마시고 이걸 다시 숫자로 바꿔주셔야합니다.



(server.js)
```
app.delete('/delete', function(요청, 응답){
  요청.body._id = parseInt(요청.body._id)
  db.collection('post').deleteOne(요청.body, function(에러, 결과){
    console.log('삭제완료')
  })
  응답.send('삭제완료')
});
```
parseInt라는 함수는 '1' 이런걸 정수 1로 바꿔주는 고마운 함수입니다.

그리고 실행해보시면 (/list 페이지를 새로고침해서 AJAX 요청해보시면)

{_id : 1} 인 데이터가 삭제가 되어있음을 확인할 수 있습니다.



버튼을 눌렀을 때만 AJAX 요청을 해보도록 합시다.



지금은 /list 페이지를 로드할 때마다 AJAX 요청이 실행됩니다.

script태그 안에 담은 코드들은 페이지 로드할 때마다 실행되니깐요.

코드를 이렇게 고치면..





(list.ejs)
```
<ul class="list-group">
  <% for (var i = 0; i < posts.length; i++){ %>
  <li class="list-group-item">
    <h4> 할일 제목 : <%= posts[i].제목 %> </h4>
    <p> 할일 마감날짜 : <%= posts[i].날짜 %> </p>
    <button class="delete">삭제</button>
  </li>
  <% } %>
</ul>
<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script>
  $('.delete').click(function(){
    $.ajax({
      method : 'DELETE',
      url : '/delete',
      data : { _id : 1 }
    }).done(function(결과){
      //AJAX 성공시 실행할 코드는 여기
    })

  });
</script>
```
1. button태그에 class를 추가했고

2. $.ajax 코드를 이상한 코드로 감쌌습니다.

이상한 코드의 뜻은.. delete라는 클래스명을 가진 요소를 클릭하면 내부 $.ajax(~) 코드를 실행해주세요~ 입니다. (jQuery 문법입니다.)

그래서 이제 delete라는 클래스명을 가진 버튼을 클릭할 때만 ajax를 실행시켜주네요!  


근데 왜 항상 1번글만 삭제해주죠?



우리가 AJAX 요청할 때마다 1번만 삭제하기 코드를 짰으니까 그렇지 않을까요. (제탓은 아님)

그럼 코드를 수정해봅시다.



(list.ejs)
```
<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script>
  $('.delete').click(function(){
    $.ajax({
      method : 'DELETE',
      url : '/delete',
      data : { _id : 지금 클릭한 삭제버튼의 글번호 }
    }).done(function(결과){
      //AJAX 성공시 실행할 코드는 여기
    })
  });
</script>
```
{_id : 1} 이라고 하드코딩하는게 아니라 지금 누른 삭제버튼의 번호?를 집어넣으면 되겠군요.

그럼 버튼마다 미리 번호를 달아줘야하지 않을까요? 버튼에 자연적으로 번호가 생기진 않잖아요.

```
<ul class="list-group">
  <% for (var i = 0; i < posts.length; i++){ %>
  <li class="list-group-item">
    <h4> 할일 제목 : <%= posts[i].제목 %> </h4>
    <p> 할일 마감날짜 : <%= posts[i].날짜 %> </p>
    <button class="delete" data-id="<%= posts[i]._id %>">삭제</button>
  </li>
  <% } %>
</ul>

<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script>
  $('.delete').click(function(){
    $.ajax({
      method : 'DELETE',
      url : '/delete',
      data : { _id : e.target.dataset.id }
    }).done(function(결과){
      //AJAX 성공시 실행할 코드는 여기
    })
  });
</script>
```
1. button태그에 data-id라는 속성을 추가했으며

2. data : { } 부분을 변경했습니다.



빠른 해설 들어갑니다.

1. HTML요소에는 data-id="1" 이런 식으로 몰래 정보를 슬쩍넣을 수 있습니다. 몰랐죠?

여기에 posts[i]._id 라는 게시글의 번호를 EJS문법을 이용해 집어넣었을 뿐입니다.



2. 그리고 자바스크립트로 버튼에 숨겨져있는 data-id="1" 이라는 정보를 가져올 수 있습니다.

 버튼요소. dataset. id 이런식입니다.



3. e.target 이라는 코드는 현재 지금 클릭한 요소를 뜻합니다.

그래서 e.target.dataset.id는 무슨 뜻일까여?




코드를 또 수정해봅시다.


뭐게요
지금 클릭한 요소의 data-id 속성값을 가져오세요~ 라고 쓴 것입니다.

2번글 버튼을 누르면 data-id에 2가 박혀있으니까

e.target.dataset.id는 샤라락 2로 변하겠군요.



그래서

2번글 버튼을 누르면 data : { _id : 2 } 라고 채워지게되는 것입니다.

3번글 버튼을 누르면 data : { _id : 3 } 이라고 채워지게되는 것입니다.







이제 3번글 삭제버튼을 누르면 3번 게시물을 삭제해줍니다.

끝입니다.

하지만 새로고침을 해야 반영이 되죠? 다음 시간엔 이걸 수정하는 UI 개발을 해보도록 합시다.


-------

### AJAX로 삭제요청하기 3 (jQuery를 이용한 UI 기능) & 여러가지 응답방법


고객 요청에 응답하는 방법은 여러가지가 있습니다


```
app.get('/어쩌구', function(요청, 응답){
  응답.send('<p>some html</p>')
  응답.status(404).send('Sorry, we cannot find that!')
  응답.sendFile('/uploads/logo.png')
  응답.render('list.ejs', { ejs에 보낼 데이터 })
  응답.json(제이슨데이터)
});
```

send는 간단한 문자나 HTML을 보낼 수 있습니다.

status는 응답코드를 보낼 수 있습니다.

sendFile은 static 파일들을 보낼 수 있습니다.

render는 ejs등의 템플릿이 적용된 페이지들을 렌더링해줄 수 있습니다.

json은 제이슨 데이터를 담아보낼 수 있습니다.




응답코드를 이용해 요청이 성공했는지, 실패했는지 판정해줄 수 있습니다

대충 서버에러일 경우엔 500, 이상한 요청일 경우 400 이렇게 대충 적어보내셔도 무방하지만

정확히 적으시면 테스트할 때 어떤 문제인지 약간 더 쉽게 파악가능합니다.

아무튼 그래서 우리도 server.js에서 DELETE요청시 성공/실패 코드를 보내도록 합시다.


-----

#### AJAX 요청 성공 또는 실패시 특정 코드 실행하기



당연히 데이터가 오거나 200 코드가 오면 성공이고, 데이터가 안오거나 400, 500 코드가 오면 실패라고 봅니다.

성공이나 실패시 각각 기능을 실행하려면 done 혹은 fail 함수를 이용하시면 되겠습니다.



(list.ejs)

```
<script>
  $('.delete').click(function(){
    $.ajax({
      method : 'DELETE',
      url : '/delete',
      data : { _id : e.target.dataset.id }
    }).done((결과)=>{
      //AJAX 성공시 실행할 코드적기
    }).fail((xhr,code,err)=>{
      //AJAX 실패시 실행할 코드적기
    });
  });
</script>
```

AJAX 성공시 done 함수 내부의 코드를 실행하고

실패시 fail 함수 내부의 코드를 실행할 것입니다.

(function 대신 => 이거 써도 똑같은 함수입니다)

참고로 fail 함수 내부의 3개의 파라미터는 차례로 jQuery의 XMLHttpRequest(몰라도됨), 에러코드, 에러메세지입니다.

done 함수의 1개 파라미터는 요청시 받아온 결과가 담겨있습니다. (파일, 데이터 등)



그럼 성공이나 실패 각각 경우에 따라서 안내문을 띄워준다든지 그런 UI개발을 할 수 있겠군요?


------

#### 삭제요청 성공시 해당 게시물 <li>를 지워보자



삭제버튼을 누르면 HTML화면은 변동이 없고 DB데이터만 지우고 있습니다.

(AJAX는 새로고침 없이 몰래 요청을 처리해주니깐요)

그럼 유저들이 삭제 된지 안된건지 모르겠죠?

그러니 삭제 AJAX 성공시 해당 게시물의   li태그를 지워보도록 합시다.

Q. 왜 li 태그를 지우나고요?

왜냐면
(list.ejs)
```
<ul class="list-group">
  <% for (var i = 0; i < posts.length; i++){ %>
  <li class="list-group-item">
    <h4> 할일 제목 : <%= posts[i].제목 %> </h4>
    <p> 할일 마감날짜 : <%= posts[i].날짜 %> </p>
    <button class="delete">삭제</button>
  </li>
  <% } %>
</ul>
```
이 부분이 여러분 작성했던 게시물 리스트 HTML 입니다.



간단히 해석하자면 여러분 게시물은
```
<ul>

<li> 제목, 날짜, 삭제버튼 </li>

<li> 제목, 날짜, 삭제버튼 </li>

<li> 제목, 날짜, 삭제버튼 </li>

</ul>
```
이렇게 HTML로 이루어져있으니까요.

그래서 삭제버튼을 감싸고 있는 li 태그를 지우면 해당 게시물행이 하나가 깔끔하게 삭제될 것 같습니다.


그럼 코드를 수정해봅시다.



(list.ejs)
```
<script>
  $('.delete').click(function(){
    $.ajax({
      method : 'DELETE',
      url : '/delete',
      data : { _id : e.target.dataset.id }
    }).done((결과)=>{
      $(this).parent('li').fadeOut();
    })
  });
</script>

```
기존에 있던 done 함수 안에 한줄을 추가했습니다.

1. $(this) 라는 단어는 현재 클릭이벤트가 동작하는 곳입니다.  
$(e.target)으로 대체 가능합니다. (지금 누른것)

하지만 e.target이나 this 같은 키워드 뒤에 jQuery 함수를 붙이고 싶다면 $() 안에 싸매셔야합니다.

2. parent('li')는 부모 HTML 중 li태그를 찾아주세요~

3. fadeOut()은 사라지게 해주세요~

4. 근데 done() 안에 function(){} 말고 ()=>{} 이런 함수로 바꿔봤습니다. 그래야 this값의 변형없이 잘됩니다.

입니다.


###### Q. 그럼 $(this).parent('li').fadeOut() 는 무슨 뜻일까여?

안알랴줌
안알려드리려고 했지만 눌러보셨군요.

"지금 누른곳(이벤트가 동작하는 곳)의 부모(상위요소)중에 li 태그가 있으면 사라지게 해주셈"

이라는 뜻입니다.  

삭제 실패시 안내메세지를 보여주거나의 기능은

fail 함수 내에 이리저리 코드를 짜면 될텐데

여러분이 jQuery나 JavaScript 배워서 직접 할 수 있을테니 패스하겠습니다.

-----


### 쇼핑몰처럼 상세페이지를 만들어보자 (URL parameter)


상세페이지를 어떻게 만들어야할까요?



일반 쇼핑몰들처럼 만들면 됩니다.

누군가 /detail/3 으로 접속하면 3번 게시물 데이터를 보여주면 되고

누군가 /detail/4 로 접속하면 4번 게시물 데이터를 보여주면 됩니다.

그럼... 이렇게 코드 짜면 되겠네여?
```
app.get('/detail/3', function(요청, 응답){
  응답.render('detail.ejs', {3번게시물데이터} )
});

app.get('/detail/4', function(요청, 응답){
  응답.render('detail.ejs', {4번게시물데이터} )
});
```
app.get() 어쩌구를 상품 갯수만큼 만들면 되겠군요?

상품이 100개면 100개 만드시면 되겠습니다.

--------


싫다면 파라미터라는 문법을 이용하시면 되겠습니다.



파라미터는 쉽게 말하면 URL 뒤에 무작위의 문자를 붙일 수 있게 만들어주는 URL 작명 방식입니다.

제가 한번 만들어보겠습니다.

```
app.get('/detail/:id', function(요청, 응답){
  응답.render('detail.ejs', {어쩌구} )
});
```

저렇게 콜론 (:) 기호를 붙여주면 누군가 /detail/ 뒤에 아무 문자열이나 입력하면~ 이라는 소리입니다.

이제 사용자가 /detail/ 뒤에 어떤 숫자나 문자를 붙이든 위의 코드3줄로 인식할 수 있는 것이죠.



Q. 왜 id라고 썼는가?

땡땡 기호 뒤엔 여러분이 자유롭게 작명하시면 됩니다. 전 id라는 이름이 좋아서 그랬어요.

그냥 detail 뒤의 무작위의 문자를 id라고 부르겠습니다~ 라는 뜻입니다.

(참고로 파라미터는 두개 세개 계속 이어붙일 수도 있습니다.)


그럼 detail/2로 방문하면 2번 게시물을 보내야합니다.



그럼 일단 누군가 detail/2로 방문하면 _id가 2인 게시물을 DB에서 찾아와야합니다. (당연)

DB에서 게시물 찾기는 처음 하는 내용일 수 있으니 제가 한번 만들어보겠습니다.

따라하세요.

```
app.get('/detail/:id', function(요청, 응답){
  db.collection('post').findOne({ _id : URL에입력한id값 }, function(에러, 결과){
    응답.render('detail.ejs', {어쩌구} )
  })
});
```
db.어쩌구.findOne() 이라는 함수를 사용했습니다.

이 함수는 db에서 원하는 게시물 하나 찾고싶을 때 사용합니다.

사용법은 .findOne({원하는게시물정보}, function(){ 완료시 실행할 코드 }) 이렇게 하시면 됩니다.



이제 위 코드에 사용자가 URL에 입력한 :id값을 그대로 넣어주면 되는데 어떻게 할까요?

이런건 생각해서 나오는게 아니라 구글 검색을 하셔야합니다.

검색하시면 아마 요청.params.id 라고 나올 것입니다.





그래서 적용해봤습니다.


```
app.get('/detail/:id', function(요청, 응답){
  db.collection('post').findOne({ _id : 요청.params.id }, function(에러, 결과){
    응답.render('detail.ejs', {data : 결과} )
  })
});
```
마지막으로 셋째 줄에서 DB에서 찾은 결과를 data라는 이름으로 ejs파일로 보내고 있습니다.

그럼 ejs파일 내에서 그 게시물 데이터를 가지고 HTML에 꽂아넣을 수 있겠죠?











하지만 결과를 출력해보니 null이 나오는데요?



console.log 등을 써보시면 DB에서 찾은 결과가 null이라고 출력됩니다.

그래서 이걸 ejs에 보내도 아무 쓸모짝에도 없겠군요.

이제 여러분이 이 문제를 찾고 해결하시면 됩니다.

실은 DB에서 찾은 결과가 null, 즉 아무것도 없다는 뜻인데.. 그 이유는 여러분이 findOne을 잘못 썼기 때문이 아닐까요?
```
app.get('/detail/:id', function(요청, 응답){
  db.collection('post').findOne({ _id : parseInt(요청.params.id) }, function(에러, 결과){
    응답.render('detail.ejs', {data : 결과} )
  })
});
```
그래서 위 코드처럼 parseInt()를 이용해서 제대로 사용하시면 됩니다.

왜냐면 요청.params.id를 출력해보면 '2' 이런 식으로 문자자료형으로 출력됩니다.

그런데 DB엔 _id가 '2'인 자료는 없죠? _id가 2인 자료는 있습니다.

그래서 이걸 숫자로 변환하기 위해 parseInt를 쓴 것입니다.

(parseInt는 자바스크립트에서 문자를 정수로 변환해주는 고마운 함수입니다.)


###### 다 해결되었으니 이제 EJS 파일을 디자인해봅시다



1. detail.ejs 파일을 view 폴더 안에 만들어줍니다

2. 다른 ejs파일에 있던 HTML 코드를 전부 복사 붙여넣기 해준 다음 body 태그 내에 필요없는 태그들을 삭제합니다.

3. 하단 코드를 body>태그 내에 추가합니다.


```
<h4>상세페이지 입니다.</h4>
<h4>제목 : <%= data.제목 %></h4>
<h4>날짜 : <%= data.날짜 %></h4>
```
이렇게 쓰면 완성!

그럼 지금까지의 코드를 테스트를 해보면

- URL란에 /detail/4를 입력시

- detail.ejs파일이 렌더링되는데 data라는 변수에 실제 DB에 있던 _id가 4인 게시물이 담겨옵니다.

- data.제목 이렇게 4번게시물의 제목과 날짜를 ejs파일 안에서 보여줍니다.

상세페이지 완성 ㄷㄷ









(참고) 예전에 했던 Ajax delete 요청도

 ```

 $.ajax({
     method: 'DELETE',
     url: '/delete',
     data: { _id: 1 },
})
```
▲ 이런 식으로 data를 전달해서 요청.body로 꺼내쓰도록 만들었는데




```
 $.ajax({
     method: 'DELETE',
     url: '/delete/1',
})
```
▲ 이런 식으로 url parameter로 원하는 데이터를 전달할 수도 있겠네요.

어떻게하든 정보만 전달된다면 상관은 없지만 delete 요청시엔 이게 약간 더 자주 쓰는 사용방법입니다.

원래 delete 요청으로 data를 전달하는게 일반적이진 않아서요 근데 보낼 정보가 길면 data로 전달해야죠 뭐



### (쉬어가기) Bootstrap 디자인 넣기 & HTML 조립식 개발하기



잠깐 쉬어가며 HTML 디자인좀 넣어봅시다



공부용 예제라고 HTML에 디자인없이 글만 넣으면 코드짤 맛이 나지 않습니다.

그러니 같이 list, detail 페이지를 꾸며보도록 합시다.

일단 detail.ejs 코드를 이렇게 업데이트 했습니다 .

(이전 detail.ejs)
```
<h4><%= data.제목 %></h4>
<h4><%= data.날짜 %></h4>

(현재 detail.ejs)
<div class="container mt-3">
  <div class="card" style="width: 100%">
    <div class="card-body">
      <h5 class="card-title"><%= data.제목 %></h5>
      <h6 class="card-subtitle mb-2 text-muted"><%= data.날짜 %></h6>
      <p class="card-text">임시내용입니다.</p>
      <a href="#" class="card-link">수정하기</a>
    </div>
  </div>
</div>
```
Bootstrap 홈페이지에 있는 카드 레이아웃 아무거나 가져다 붙여놓고 안에 EJS문법으로 실제 제목을 채웠습니다.

이제 더 이상 눈이 썩지 않습니다.

container라는 클래스는 Bootstrap에서 좌우 여백을 예쁘게 잡을 수 있게 도와주는 클래스입니다.


CSS 파일 넣는 법



CSS 파일은 보통 관습적으로 public 폴더에 보관합니다.

CSS, 이미지 처럼 자주 바뀌지 않는 static 파일들을 다 public에 넣어주시면 됩니다.

(public 폴더는 views 폴더 옆에 나란하게 만드세요)

그리고 원하는 HTML이나 EJS파일에 가서
```
<head>
  <link href="/public/님들이만든CSS파일.css" rel="stylesheet">
</head>
<head>태그 안에 <link>로 CSS를 집어넣으면 됩니다. (이건 당연한 사실)
```
하지만 그냥 넣으시면 동작하지 않습니다.

Node쨩에게 "나는 public 폴더도 있다"라고 알려주어야합니다.







(server.js)
```
app.use('/public', express.static('public'))
```
이라는 코드를 app.set이나 app.use가 모여있는 곳 근처에 적어주시면 됩니다.

"/public 위치에 있는 폴더를 쓰겠다"라는 뜻입니다.







list.ejs 파일 디자인하기



별거 한건 없고 버튼들을 Bootstrap 버튼들로 바꿔서 집어넣었으며

글자 가운데 정렬을 조금 해주고 마진 잡고 container 클래스를 활용해 좌우여백을 예쁘게 잡았을 뿐입니다.

자세한 사항은 강의를 참고합니다.









##### nav 조립식으로 첨부하기



페이지가 4개 정도 있는데 여기 <nav>태그로 이루어진 상단메뉴UI가 계속 출현하고 있습니다.

이 UI는 전부 똑같은 모습을 하고 있어야하는데, 그럼 나중에 수정사항이 생기면

페이지4개에 있는 <nav> 직접 하나하나 수정해줄겁니까. 그럼 너무 오래걸리잖아요.

1. 그래서 nav.html이라는 파일을 하나 만들고 2. 그 파일을 다른 파일에다가 include(첨부) 하는 식으로 한번 UI를 만들어보겠습니다.





1. list.ejs에 있던 <nav>태그를 잘라내어 nav.html 파일을 만들고 거기에 붙여넣습니다.

(views/nav.html)
```
<nav>
  <a>링크</a>
  어쩌구...
  저쩌구...
</nav>
```
views 폴더 내에 만드시면 될듯 합니다.



2. <nav>태그 UI가 필요한 파일에 가서 이런 문법을 사용합니다.

(list.ejs)

```
<%- include('nav.html') %>
```
이 문법을 쓰시면 이 자리에 nav.html 내용이 전부 붙여넣기됩니다.

그럼 list 페이지 방문하시면 nav태그가 잘 보이죠?

다른 ejs 파일들에도 nav.html을 조립식으로 첨부해보시길 바랍니다.

----

index.html에도 필요한데 어쩌죠



EJS 파일 말고 그냥 쌩 HTML 파일엔 <% %> 이런 문법을 쓸 수 없습니다. (EJS문법이니까 당연)

그럼 HTML 파일을 .ejs 파일로 바꾸시면 되죠 뭐..!

1. 확장자를 index.ejs로 바꾸고

2. 이걸 views폴더 내로 옮기고

3. server.js에서 /경로로 방문시 index.html을 보내라~가 아니라 index.ejs 파일을 렌더링해줘라~ 라고 바꾸면 되겠죠?





그럼 <% %> 문법을 자유롭게 쓸 수 있겠군요. -->
