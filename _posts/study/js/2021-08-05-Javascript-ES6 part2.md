<!-- ---
title: "[js] Javascript, ES6 part2"
layout: post
subtitle: JS
date: "2021-03-22-23:45:51 +0900"

categories: study
tags: JS
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---

ES6부터 업그레이드된 함수의 default 파라미터 기능과

ES5 문법 arguments에 대해 알아봅시다.

함수의 default 파라미터 넣기

함수를 만들 때 파라미터값을 실수로 안적거나 했을 경우

파라미터에 기본값(default 값)을 줄 수 있습니다.

이렇게 사용하시면 됩니다.

```
function 더하기 (a, b = 10){
  console.log(a + b)
}
더하기(1);

```

위 코드를 실행하면 콘솔창에 뭐가 뜨냐면 11이 뜹니다.

지금 더하기() 함수는 파라미터를 두개 입력할 수 있습니다.

하지만 실수인지 일부러인지 1이라는 파라미터 하나밖에 쓰지 않았습니다.

그럴 때 저렇게 b = 10 선언해뒀던 default 파라미터값인 10이 b에 할당되게 됩니다.

그래서 콘솔창에 a + b가 11이 출력되게 되는 것입니다.

default 파라미터를 주고 싶으면 저렇게 파라미터 선언하실 때 등호로 입력해주시면 됩니다.

그럼 파라미터가 정의되지 않았을 때 등호 오른쪽 값이 발동됩니다.

default 파라미터로 별게 다 들어갈 수 있습니다.

```
function 더하기 (a, b = 2 * 5){
  console.log(a + b)
}
```

더하기(1);
수학 연산자도 사용가능합니다. b 자리에 파라미터가 없으면 2 \* 5라는 값을 할당해줍니다.

```
function 더하기 (a, b = 2 * a){
  console.log(a + b)
}

더하기(3);

```

다른 파라미터와 연산도 가능합니다. 위 코드는 실행하면 콘솔창에 뭐가 출력될까요?

뭘까요
9가 출력됩니다.

console.log(3 + 6)을 실행하니까요.

심지어 default 파라미터엔 함수입력도 가능합니다.

```
function 임시함수(){
  return 10
}

function 더하기 (a, b = 임시함수() ){
  console.log(a + b)
}

더하기(3);

```

위 코드는 실행하면 콘솔창에 뭐가 출력될까요?

뭘까요
13이 출력됩니다.

b자리에 파라미터가 들어오지 않으면 임시함수()를 실행한 값을 b 파라미터에 할당해줍니다.

임시함수()를 실행하면 그 자리에 10이 남습니다.

(return 10이 그 뜻입니다)

그래서 console.log(3 + 10)을 실행해줍니다.

함수의 arguments

함수의 모든 파라미터들을 전부 한꺼번에 싸잡아서 다루고 싶은 경우가 있습니다.

그럴 땐 arguments라는 키워드를 활용하시면 됩니다.

함수 안에서 쓸 수 있는 미리 정의된 키워드 혹은 변수인데

한번 써보도록 합시다.

```
function 함수(a,b,c){
  console.log(arguments)
}

함수(2,3,4);
```

그러면 콘솔창에 [2,3,4]를 담은 array 비슷한 자료가 출력됩니다.

arguments는 즉, 모든 입력된 파라미터를 [ ] 안에 싸매주는 고마운 키워드였던 것이었습니다.

이제 여러분이 파라미터들을 한꺼번에 다루고 싶을 때 자주 활용해주시면 됩니다.

예를 들면 이런 경우가 있겠군요.

콘솔창에 모든 파라미터를 하나씩 출력해주고 싶은 경우

![20210925_235337](/assets/20210925_235337.png)
![20210925_235150](/assets/20210925_235150.png)

```
function 함수(a,b,c){
  console.log(arguments[0])
  console.log(arguments[1])
  console.log(arguments[2])
}

함수(2,3,4);
```

이러면 되겠군요? 그런데 조금 더 확장성있게 반복문을 쓴다면

```
function 함수(a,b,c){
  for (var i = 0; i < arguments.length; i++){
    console.log(arguments[i])
  }
}

함수(2,3,4);
```

이러면 되겠군요.

약간 편리하게 파라미터들을 다룰 수 있는 문법이었습니다.

하지만 ES6문법 부터는 파라미터를 더 쉽게 다룰 수 있는 rest 파라미터라는 문법이 등장하게 되는데..

그건 다음 강의에서 알아봅시다.

---

##### 함수에서 쓰는 점3개 Rest 파라미터

저번 시간 arguments라는 문법을 배워봤는데

ES6부터는 약간 더 쉬운 문법을 제공합니다.

Rest 파라미터가 그것입니다.

Rest 파라미터

함수를 만들 때 ...이라는 기호를 파라미터 왼쪽에 추가가능합니다.

그러면 신기한 일이 일어납니다.

```
function 함수2(...파라미터들){
  console.log(파라미터들)
}

함수2(1,2,3,4,5,6,7);

```

![20210925_235337](/assets/20210925_235337_kippbn2f2.png)

![20210926_002223](/assets/20210926_002223.png)

![20210926_002337](/assets/20210926_002337.png)

![20210926_002810](/assets/20210926_002810.png)

![20210926_003029](/assets/20210926_003029.png)

위 코드를 실행해보면 파라미터들이라는 변수를 출력해줍니다.

파라미터들이라는 변수는 모든 파라미터를 [] array 안에 담고 있습니다.

이게 바로 ES6 환경에서 쓸 수 있는 rest 파라미터입니다.

원하는 파라미터 왼쪽에 ... 기호를 붙여주시면

"이 자리에 오는 모든 파라미터를 [] 중괄호로 감싸준 파라미터" 라는 뜻입니다.

그래서 출력해보면 저렇게 [1,2,3,4,5,6,7]이 나오는 것이고요.

그 자리에 입력한 모든 파라미터(1,2,3,4,5,6,7)를 중괄호에 감싸주는게 rest 파라미터입니다.

(참고로 sperad와의 차이는 함수 파라미터자리에 붙으면 rest, 나머지는 spread이다.)

...을 다른 자리에 사용한다면

그 자리에 있는 파라미터를 [] 안에 감싸준다고 했으면

다른 자리에 쓰면 어떻게 될까요?

```
function 함수2(a, b, ...파라미터들){
  console.log(파라미터들)
}

함수2(1,2,3,4,5,6,7);

```

위 코드를 실행해보면 [3,4,5,6,7]이 출력됩니다.

첫 두개의 파라미터는 a, b로 쓰는데

a,b 그 뒤에 나오는 모든 파라미터는 중괄호에 감싸서 파라미터들이라는 array가 됩니다.

파라미터 종류가 많을 경우 arguments 문법보다 다루기 쉽고 간단해서 자주 사용합니다.

쓰기 전 주의사항

rest(나머지) 파라미터라는 뜻대로 나머지 부분에만 사용가능합니다.

그니까 항상 파라미터가 여러개면 rest는 항상 마지막 파라미터로 넣으셔야합니다.

![20210926_003454](/assets/20210926_003454.png)

```
function 함수2(a, ...파라미터들, b){
  console.log(파라미터들)
}
```

이렇게 사용하시면 에러난다는 소리입니다.

```
function 함수2(a, ...파라미터들, ...파라미터들2){
  console.log(파라미터들)
}
```

이것도 안됩니다. 2개 이상 사용할 수 없습니다.

간단한 연습문제

모든 파라미터를 전부 하나씩 콘솔창에 출력해주는 함수를 만들고 싶습니다.

어떻게 해야할까요?

그냥 쉬우니까 답을 알려드리겠습니다.

```
function 함수(a, b, c){
  console.log(a);
  console.log(b);
  console.log(c);
}

함수(1,2,3);
```

이렇게 하면 되는거 아닙니까.

맞습니다. 근데 파라미터를 4개 5개 오바해서 입력한 경우엔 제대로 실행이 되지 않는 멍청한 함수가 완성되었을 뿐입니다.

파라미터 갯수 제한없이 똑같은 기능을 실행해주는 함수를 만들려면 어떻게 해야할까요?

뭘까요

A.

```
function 함수(...rest){
  console.log(rest[0]);
  console.log(rest[1]);
  console.log(rest[2]);
  (...이하 쭉쭉쭉)
}

함수(1,2,3);
```

이렇게 하면 되는거 아닙니까. 근데 파라미터가 몇개 들어갈지 모르기 때문에

console.log()부분을 반복문을 이용하면 더 깔쌈하게 만들 수 있습니다.

```
function 함수(...rest){
  for (var i = 0; i < rest.length; i++) {
    console.log(rest[i]);
  }
}

함수(1,2,3,4,5,6,7,8);
```

rest라는게 모든 파라미터를 [] 안에 담아서 array처럼 만들어주는 고마운 변수기 때문에

반복문을 저렇게 돌릴 수 있습니다.

그럼 이제 함수에 파라미터를 몇개를 넣든 간에 콘솔창에 계속 출력을 해줄 수 있습니다.

영단어 rest가 뜻이 쉬다가 아니라 여분, 나머지 이런 뜻이잖아요.

그러니 나머지 파라미터라고 외우시면 그나마 머릿속에 기억이 잘 될 것 같습니다.

---

##### Spread, Rest 연습문제

1. spread 문제 1

```
var a = [1,2,3];
var b = '김밥';
var c = [...b, ...a];
console.log(c);
```

위 코드의 출력 결과는?

답안

A.

['김', '밥', 1, 2, 3 ] 이라는 array가 출력됩니다.

글자를 spread하면 한글자씩 콤마로 분열이 되고

array를 spread 하면 대괄호를 제거합니다.

2. spread 문제 2

```
var a = [1,2,3];
var b = ['you', 'are'];
var c = function(a,b){
  console.log( [[...a], ...[...b]][1] )
}
c(a,b);
```

대괄호가 가득한 위 코드의 출력 결과는?

답안

A.

c라는 함수에 a와 b라는 자료를 집어넣어서 실행하라고 하네요.

c라는 함수의 기능은 어려워보이지만

지랄맞은 코드들은 하나씩 차례로 번역하다보면 별거아닙니다.

[ [...a], ...[...b] ][1] 여기서 a와 b를 집어넣어보면

[ [1,2,3], ...['you', 'are'] ][1] 이렇게 되고 spread를 해치워버리면

[ [1,2,3], 'you', 'are' ][1] 이렇게 되고 [1]이라는건 1번째 자료라는 뜻이니까 출력해보면

'you'라는 글자가 콘솔창에 뜹니다.

3. default 파라미터 문제 1

A.

```
function 함수(a = 5, b = a * 2 ){
  console.log(a + b);
  return 10
}
함수(3);

```

위 코드의 출력 결과는?

답안

함수는 두개의 파라미터를 입력할 수 있는데 3만 집어넣어서 실행하고 있습니다.

a자리에 파라미터 하나만 집어넣었다는 소리군요.

그럼 b라는 파라미터는 default 파라미터가 발동해서 a \* 2 라는 값을 가지게 됩니다.

그래서 a는 3, b는 6이 됩니다.

9가 출력되겠네요.

4. default 파라미터 문제 2

```
function 함수(a = 5, b = a * 2 ){
  console.log(a + b);
}
함수(undefined, undefined);
```

위 코드의 출력 결과는?

답안

A.

함수에 파라미터를 입력하지 않았을 경우 그 파라미터를 출력해보면 undefined가 출력됩니다.

그러니까

```
 function 함수(a){
  console.log(a)
}
함수();

```

이 코드의 실행결과는 undefined라는 소리입니다.

자바스크립트 함수에서는 파라미터를 집어넣지 않았을 경우 파라미터가 자동으로 undefined가 됩니다.

그럼 일부러 파라미터로 undefined를 입력하면 어떻게 될까요?

그냥 파라미터를 입력하지 않은 것과 동일합니다.

그래서 default 파라미터가 발동되어 15라는 결과를 출력해줍니다.

5. array를 만들어주는 함수를 제작하고 싶습니다.

실용성은 0이지만 일단 해보도록 합시다.

파라미터로 자료들을 입력하면 그걸 그대로 array를 만들어주는 함수를 만들고 싶습니다.

```
function 어레이(){
  (여기 어떤코드가 들어가면 될까요?)
}

var newArray = 어레이(1,2,3,4,5);
console.log(newArray);
```

이렇게 작성하면 [1,2,3,4,5]가 출력되어야합니다.

함수에 숫자를 100개 집어넣으면 Array안에 숫자100개가 들어가야하고요.

어레이라는 함수를 어떻게 만들면 될까요? (new 키워드 사용금지)

답안

A.

파라미터를 전부 array안에 담아주는 좋은 방법을 배운 것 같습니다.

rest 파라미터를 이용하시면 되겠네요.

```
function 어레이(...rest){
  return rest
}

var newArray = 어레이(1,2,3,4,5);
console.log(newArray);
```

이렇게 작성하면 [1,2,3,4,5]가 출력됩니다.

또한 파라미터를 몇개 집어넣든 간에 그대로 array를 만들어서 출력해주네요.

옛날방식으로는 arguments 라는 변수를 이용하시면 비슷하게 기능개발이 가능합니다.

6. 최댓값 구하기

자바스크립트에서 최댓값을 구하고 싶으면.. Math.max()라는 기본 내장함수를 쓸 수 있습니다.

Math.max(5,6,4,3)
이렇게 쓰시면 6이라고 최댓값을 출력해줍니다.

근데 최댓값을 검사하고 싶은 숫자들이 좀 많습니다.

var numbers = [2,3,4,5,6,1,3,2,5,5,4,6,7];
Math.max()에 집어넣어서 쓰고 싶은데 어떻게 하면 좋을까요?

답안

A.

Math.max() 안에 array 안의 모든 데이터를 담고싶으면

array를 풀어헤쳐서 집어넣으면 되는게 아니겠습니까.

```
var numbers = [2,3,4,5,6,1,3,2,5,5,4,6,7];

console.log( Math.max(...numbers) );
```

이렇게 작성하면 array데이터들 중에서 최댓값을 구해줍니다.

끝입니다.

왜 함수 소괄호에 적었는데 rest 파라미터가 아니냐고요?
함수를 선언할 땐 ...은 rest 파라미터
함수를 사용할 땐 ...은 spread 연산자 입니다.

7. 글자를 알파벳순으로 정렬해주는 함수를 만들고 싶습니다.

일단 자바스크립트는 array 내의 데이터를 알파벳순으로 정렬하고 싶을 때

sort()라는 array 내장함수를 붙여 사용합니다. (array에만 적용가능)

console.log( ['b', 'c', 'a'].sort() );

//['a', 'b', 'c'] 출력됨
이렇게 sort()만 붙이면 쉽게 정렬이 가능합니다. 끝입니다.

그런데 우리는 array가 아니라 문자열에도 적용할 수 있는 알파벳순 정렬함수를 하나 만들고 싶습니다.

```
function 정렬(){
  (여기 어떤 코드가 들어가야할까요?)
}
```

정렬('bear');
정렬('bear')라고 사용하면

콘솔창에 a b e r 이렇게 입력한 문자를 알파벳 순으로 출력되게 만들고 싶으면 어떻게 해야할까요?

(sort() 함수 사용가능)

답안

A.

sort 함수는 사용가능하다고 했는데 sort는 안타깝게도 array에만 붙일 수 있습니다.

그럼 그냥 문자를 array화 시켜버리면 sort함수 쓸 수 있으니 그렇게 하면 쉽게 해결가능하지 않을까요?

bear라는 문자를 ['b', 'e', 'a', 'r'] 이렇게 array에 담아서 알파벳을 정렬해버리는 겁니다.

그럼 어떻게 해야되냐면

```
function 정렬(글자){
  console.log( [...글자].sort() )
}

정렬('bear');
```

[...글자] 이렇게 하시면 글자를 spread로 풀어헤쳤다가 다시 array안에 담아줍니다.

['b', 'e', 'a', 'r'] 이렇게 해준다는 소리입니다.

그럼 이걸 sort()로 정렬해버리면 끝이죠?

그리고 정렬한 데이터를 대괄호를 다시 벗기고 싶다면

```
function 정렬(글자){
  console.log( ...[...글자].sort() )
}

정렬('bear');

```

거기에 spread를 또 써주시면 되는거 아니겠습니까.

그럼 콘솔창에 a b e r 이렇게 차례로 출력됩니다. 끝입니다.

8. 데이터마이닝 기능 만들기

데이터분석 하는 사람들이 자주 만들어 쓰는 함수가 있습니다.

알파벳들의 출현 갯수를 세어주는 함수입니다. 우리도 한번 만들어봅시다.

글자세기('aacbbb') 라고 입력하면 콘솔창에

{ a : 2, b : 3, c : 1 }

▲ 이렇게 출력해주는 글자세기() 라는 함수를 만들고 싶습니다.

쉽게말하자면 입력한단어에 들어있는 알파벳의 갯수를 세어서 오브젝트에 기록해주고 출력까지 해주는 함수입니다.

글자세기라는 함수를 어떻게 만들면 될까요?

답안
별거 아니고 글자에다가 반복문을 돌릴 수 있습니다.

그냥 반복문을 쓰셔도 될 거 같고 아니면 조금 더 간단하게 사용하시려면 forEach() 반복문을 쓸 수 있습니다.

forEach()는 근데 array에만 붙일 수 있는 함수입니다.

글자에 붙이려면.. 글자를 array화 해주면 되는게 아닐까요?

```
function 글자세기(글){
  var 결과 = {};
  [...글].forEach(function(a){  });
}
```

그래서 함수안에 글자를 집어넣으면 spread를 이용해서 하나하나의 알파벳들을 array에 저장시켜줍니다.

그리고 거기에 forEach 반복문을 돌려봤습니다.

그럼 이제 글자안에있던 하나하나의 알파벳들 갯수 만큼 반복문이 돌게 되고,

반복문이 돌면서 a라는 값은 하나하나의 알파벳이 됩니다.

그럼 이제 하나하나의 알파벳만큼 반복문이 돌게 되니 반복문 안에다가 기능개발하면 되겠군요.

결과라는 object에 결과[a] (결과.a) 라는 항목이 있으면 값을 1을 더해주고

없으면 1로 등록해주세요~ (a : 1 이렇게) 라고 코드를 짜면 될 것 같군요.

그래서 짜보았습니다.

```
function 글자세기(글){

var 결과 = {};
  [...글].forEach(function(a){
     if( 결과[a] > 0 ){ 결과[a]++ } else { 결과[a] = 1 }
  });
console.log(결과)
}

```

(결과[a] 이건 오브젝트 내에서 데이터를 뽑는 법입니다.)

그리고 반복문이 다 돌고난 후 콘솔창에 결과까지 출력하라고 코드를 짰습니다.

잘 출력해주네요.

---

##### 이상한 Reference data type과 예제 3개

오늘은 객체지향 문법 시작 전 반드시 알아야할 reference, primitive data type을 알아봅시다.

Primitive data type

자바스크립트의 자료형 (문자, 숫자, array, object 등)은 자료형을 크게 2개로 분류합니다.

Primitive & reference라고 분류하는데

Primitive data type들은 그냥 별건 없고 자료 자체가 변수에 저장되는 자료들입니다.

문자, 숫자 자료형들이 대표적인 primitive data type들입니다.

```
var name = 'john';
var age = 20;
```

이렇게 문자나 숫자 자료형은 문자나 숫자가 변수에 직접 저장된다는 소리입니다.

뭐 그런 당연한 소리를 하냐고요?

아닌 것들도 있기 때문입니다.

Reference data type

Array, Object 자료형은 reference data type에 속합니다.

reference data type은 자료를 변수에 직접 저장하는게 아닌,

자료가 저쪽에 있습니다 라는 화살표 (레퍼런스)를 변수에 저장합니다.

말이 어려우니 예를 들어봅시다.

```
var 사람 = { name : 'Kim' };
```

여러분 방금 { name : 'Kim' } 이라는 자료를 변수에 저장했습니다.

하지만 변수에 저장된건 { name : 'Kim' } 이게 아닙니다.

"{ name : 'Kim' }이 저기 저장되어있습니다"라는

{ name : 'Kim' } 값을 가리키는 화살표가 저장이 되어있을 뿐입니다.

알겠죠? Kim이라는 데이터가 변수에 저장된게 아닙니다. Kim이라는게 저기 있습니다~ 라는 정보만 저장할 뿐입니다.

그래서 이런 reference만 저장되는 array, object 자료형을 reference data type이라고 합니다.

Q. 화살표가 가리키는 저기가 어딘데요?

A. 컴퓨터 메모리 상의 어떤 곳입니다. 그냥 우리는 컨트롤할 수 없는 미지의 공간이라고 생각하셔도 됩니다.

어디서 이상한 C언어 배우다온 분들은 포인터인가? 라고 생각할 수 있는데 비슷합니다.

다만 C언어처럼 포인터 주소같은 개념은 다루지 못합니다.

아무튼 그래서 reference data type은 신기한 현상들이 일어납니다.

예제 1. 복사하면 이상한 일이 일어납니다.

한번 아주 직관적이고 간단한 Primitive 자료형부터 복사해보도록 합시다. 문자말입니다 문자.

```
var 이름1 = '김';
var 이름2 = 이름1;
이름1 = '박';
```

(1) 이름1은 '김'이라는 문자를 집어넣었고

(2) 이름2는 이름1에 있던 자료를 복사해서 집어넣습니다. (등호는 그냥 집어넣는다라는 뜻입니다 같다는게 아니고요)

(3) 셋째줄에서 이름1을 심심해서 박으로 변경했습니다.

그럼 이름1, 이름2를 출력하면 각각 무엇이 나올까요?

이름1은 변경했으니 '박'이고, 이름2는 복사만했지 변경하진 않았으니 '김' 입니다.

끝입니다. 별로 이상한 점이 없습니다.

근데 똑같은 일을 reference data type으로 진행하면 이상한 일이 일어납니다.

한번 Reference 타입 자료형인 object를 이용해 똑같이 해보도록 하겠습니다.

```
var 이름1 = { name : '김' };
var 이름2 = 이름1;
이름1.name = '박';
```

(1) 이름1은 { name : '김' } 이라는 object자료형을 집어넣었고

(2) 이름2는 이름1에 있던 자료를 복사해서 집어넣습니다.

(3) 셋째줄에서 이름1 object 안의 name을 박으로 변경했습니다.

그럼 이름1, 이름2를 출력하면 각각 무엇이 나올까요?

이름1은 변경했으니 { name : '박' } 이고, 이름2는 복사만했지 변경하진 않았으니 { name : '김' } 입니다.

근데 콘솔창에 출력해보면 아니라는데요?

![20210926_021548](/assets/20210926_021548.png)

쟌넨! 둘다 { name : '박' } 이었습니다

분명 코드를 보면

```
var 이름1 = { name : '김' };
var 이름2 = 이름1;
이름1.name = '박';
```

이름2는 우리가 값을 전혀 수정한 적이 없는데 바뀌어있습니다.

왜 그러냐면.. 두번째줄이 문제입니다.

이름2에 이름1을 복사해서 집어넣을 때가 문제입니다.

이 때, 이름1에 있던 { name : '김' } 이라는 데이터가 복사된게 아닙니다.

왜냐면 이름1에는 {} 이게 저장된게 아니라 reference (화살표)가 저장되어있다고 했으니까요.

이름1의 화살표를 이름2에 복사하신겁니다.

이제 이름1과 이름2는 같은 화살표를 가지고 있습니다.

그림으로 표현하자면 이렇습니다.

![20210926_021606](/assets/20210926_021606.png)

이름1과 이름2는 같은 화살표 (reference) 를 가지게 된 것이고

그 화살표는 { name : '김' } 이라는 같은 값을 가리키고 있는 것일 뿐입니다.

그럼 아까 코드에서 셋째줄에서 이름1.name = '박' 이렇게 값 변경을 하면 어떻게 되죠?

화살표를 타고 들어가서 name 을 '박'으로 설정해줍니다.

근데 가만히 있던 이름2를 출력해보면

화살표를 타고 들어가서 { name : '박' } 이라는 데이터가 나오게 되는 것이지요.

아무튼 이런 원리 때문에 이름1과 이름2는 같은 값을 공유하고 있었던 것입니다.

결론은 object, array 자료형은 등호로 복사하시면

화살표 값을 공유해버리기 때문에 문제가 일어날 수 있습니다.

그래서 다음시간에 배울 constructor 문법을 쓰셔서 object를 복사하든가 하시면 안전합니다.

예제 2. 화살표가 할당되는 기준 & object 두개가 같은지 비교해보기

여러분이 새로운 {} object를 할당할 때마다 화살표가 새로 생성된다고 보시면 됩니다.

정확한 명칭은 reference 지만 님들 기억에 오래 남게 화살표라고 합시다.

var 이름1 = { name : '김' };
var 이름2 = { name : '박' };
지금 첫줄과 둘째줄 모두 object를 새로 할당해주고 있습니다.

실은 object가 저기 있다는 화살표를 할당해준 것입니다. 끝입니다.

그럼 이걸 한번 보도록 합시다.

var 이름1 = { name : '김' };
var 이름2 = { name : '김' };
지금 첫줄과 둘째줄 모두 object를 새로 할당해주고 있습니다. 근데 object 안의 내용이 똑같네요.

여기서 문제풀어봐야함

Q. 바로 위의 예제에서 이름1 == 이름2 이렇게 두개를 같다고 비교하면 true가 나올까요 false가 나올까요?

뭘까요
A. false가 나옵니다.

왜그럴까요

왜냐면 이름1과 이름2에 저장된건 데이터가 아니라 화살표랬죠?

== 등호로 비교하고 계신건 지금 object 두개가 아닙니다. 화살표 두개입니다.

화살표가 같으면 (같은 곳을 가리키면) true가 나오고, 화살표가 같지 않으면 false가 나오기 때문입니다.

위의 예제코드를 그림으로 표현하자면 이렇습니다.

![20210926_021645](/assets/20210926_021645.png)

각각 다른 화살표를 가지고 있기 때문에 이름1과 이름2는 같지 않습니다.

잘 기억해주시면 됩니다. array도 마찬가지입니다. 함부로 같다고 비교하시면 안됩니다.

굳이 값이 같은지 비교하고 싶으면 이름1.name과 이름2.name을 비교해보십시오.

예제 3. 함수를 이용해 object를 변경하면 어떻게 될까

object를 = 등호를 이용해 조작하면 뭔가 일이 일어나는거 같으니까

이번엔 한번 함수를 이용해서 object 조작 기계를 만들어보겠습니다.

```
var 이름1 = { name : '김' };

function 변경(obj){
  obj = { name : 'park' };
}

변경(이름1);

```

말되죠? 변경() 이라는 함수를 만들었는데,

이 함수는 뭔가 오브젝트를 입력하면 오브젝트 내용을 { name : 'park' } 으로 재할당해주는 함수입니다.

그래서 이름1을 집어넣어서 실행해봤습니다.

Q. 근데 실행해봐도 이름1은 바뀌지 않습니다. 왜 그럴까요?

5년차 자바스크립트 개발자에게 물어봐도 왜 그런지 잘 모릅니다.

여러분 이거 알면 이제 6년차 개발자인겁니다.

누르기 전에 신입 가르치듯 설명해보셈

왜그러냐면 여러분 함수 만들 때 파라미터라는거 만들잖아요.

파라미터는 일종의 변수처럼 생성되고 사라지는 존재라고 보시면 됩니다.

그냥 쉽게말하면 var 변수에요 변수

(인간의 시점)

```
var 이름1 = { name : '김' };
function 변경(obj){
  obj = { name : 'park' };
}
변경(이름1);
```

(자바스크립트의 시점)

```
var 이름1 = { name : '김' };
function 변경(obj){
  obj = { name : 'park' };
}
변경(var obj = 이름1);
```

자바스크립트가 파라미터를 만들고 사용할 땐 대충 맨 밑줄처럼 만든다고 생각하시면 됩니다.

(실제 이런 문법이 있는건 아니지만요)

obj라는 파라미터자리에 이름1이라는 변수를 집어넣으시면

var obj = 이름1 이렇게 파라미터형 변수를 만든겁니다.

```
var 이름1 = { name : '김' };

function 변경(obj){
  obj = { name : 'park' };
}

변경(이름1);
```

음 근데 이거 오늘 계속 보던 패턴인데요

obj 라는 변수에 이름1이라는 { object } 를 등호로 복사해서 넣으면 어떻게 되나요?

obj, 이름1 이 두개 변수는 서로 같은 화살표를 갖게 되며 { name : '김' } 값을 공유합니다.

그런데 함수 내부를 잘 보시면 obj라는 변수는 obj = { name : 'Park' } 이렇게 재할당을 해주고 있죠?

이것은

obj라는 변수에 새로운 화살표를 재할당을 한 것이지

실제 이름1이라는 변수는 전혀 건드리지 않고 있습니다.

그래서 결국 이름1은 바뀌지 않는 것입니다.

저렇게 만들면 안되겠군요.

▼ 그럼 밑의 예제코드는 실행하면 콘솔창에 무엇이 출력될까요??

```
var 이름1 = { name : '김' };

function 변경(obj){
  obj.name  = 'park';
}

변경(이름1);
console.log(이름1);
```

한번 예상해보신 다음 실제 실행해보셔서 출력결과랑 맞춰보시길 바랍니다.

그리고 그런 출력결과가 나오는 이유도 한번 설명해봅시다.

(이유는 위에 다 있습니다)

---

##### 객체지향1. Object 생성기계인 constructor를 만들어 써보자

그래서 저번시간에 object 그냥 복사하면 큰일난다고 배워봤는데

이번시간엔 object를 안전하게 많이 복사해 만들 수 있는 constructor라는 문법을 배워봅시다.

자바스크립트로 학생 출석부 만들기

자바스크립트로 학생 리스트를 만들어야합니다.

```
var 학생1 = { name : 'Kim', age : 15 };
var 학생2 = { name : 'Park', age : 15 };

...
```

이렇게 쭉 30명을 만들어야합니다. 어떻게 하는게 가장 빠른 방법일까요?

당연히 오브젝트를 직접 중괄호쳐서 하드코딩 30개 하는 것 보다는

비슷한 오브젝트들이니 복사를 하는게 좋을 것 같습니다.

근데 = 등호를 이용해서 var 학생2 = 학생1 복사하면 큰일나니

오브젝트를 복사해서 찍어낼 수 있는 새로운 문법을 이용해보도록 합시다.

빨리 따라 적어유

```
//var 학생1 = { name : 'Kim', age : 15 };

function 기계(){
  this.name = 'Kim';
  this.age = 15;
}
```

![20210926_033108](/assets/20210926_033108.png)

object 자료 복사 기계만들 땐 function이라는 함수만드는 키워드를 빌려서 이용하시면 됩니다.

function을 하나 만드시고 거기 안에 this.name과 this.age를 집어넣어주시면 됩니다.

이게 바로 오브젝트 생성 기계입니다.

this는 새로생성되는 오브젝트를 뜻합니다. (그걸 멋진 개발용어로 인스턴스라고 합니다)

Q. 그렇다면 this.name = 'Kim' 이 뭔소리일까요 그럼?

그냥 간단한 object 자료 추가/수정문법 아닙니까.

새로생성되는 오브젝트.name은 'Kim'을 넣어주세요~ 라는 뜻이었습니다.

this를 이용해서 새로 복사될 object가 가질 값들을 디자인해놓으시면 됩니다.

[collapse]

이제 기계에서 새로운 오브젝트를 뽑고 싶으시면 이렇게 따라하시면 됩니다.

```
//var 학생1 = { name : 'Kim', age : 15 };

function 기계(){
  this.name = 'Kim';
  this.age = 15;
}

var 학생1 = new 기계();
var 학생2 = new 기계();
```

new라는 키워드를 쓰신 다음 오른쪽에 기계(constructor) 이름을 쓰신다면

기계로부터 새로운 오브젝트를 하나를 뽑아낼 수 있습니다.

그리고 그걸 변수에 저장하시면 이제 자유롭게 오브젝트를 뽑아 쓰실 수 있는겁니다.

비슷한 + 독립적인 object 자료를 여러개 만들 때 코드의 양이 줄어듭니다.

그래서 사용하는 문법입니다.

특히 오브젝트안에 들어갈 내용이 복잡하고 많을 때 쌩코딩 하지말고 써보십시오.

오브젝트에 함수가 들어가야 한다면

심지어는 함수도 오브젝트에 추가할 수 있댔죠?

그니까 예를 들면 모든 학생 오브젝트 안에 sayHi() 라는 함수를 추가해야한다고 칩시다.

학생1.sayHi()라고 사용하시면 콘솔창에 "안녕하세요 'Kim'입니다"라고 이름이 포함된 인삿말을 출력해주어야합니다.

어떻게 코드를 짜면 될까요?

```
var 학생1 = {
    name : 'Kim',
    age : 15
    sayHi : function(){
        console.log('안녕하세요' + this.name + ' 입니다');
    }
};

학생1.sayHi();
```

이렇게 하면 되겠군요. (함수 안의 this.name이 뭔지 궁금하다면 this에 관한 이전 강의를 살펴봅시다)

근데 학생1이라는 곳에다가만 하드코딩하는게 아니라

앞으로 모든 학생들이 sayHi()를 쓸 수 있게 만들고 싶으면 어떻게 해야할까요?

당연히 오브젝트 생성 기계에 추가하시면 되겠죠?

기계에 sayHi()를 추가해봅시다.

```
function 기계(){
  this.name = 'Kim';
  this.age = 15;
  this.sayHi = function(){
    console.log('안녕하세요' + this.name + ' 입니다');
  }
}
var 학생1 = new 기계();
var 학생2 = new 기계();

학생2.sayHi();
```

기계에 저렇게 this.sayHi 를 추가하시면 이제 기계로부터 생성되는 모든 학생들이 sayHi()를 가지고 있게 됩니다.

그럼 학생1, 학생2 전부 sayHi()를 쓸 수 있게됩니다.

object 자료 안엔 함수도 넣을 수 있으니 그냥 당연한 소리입니다.

학생 오브젝트를 뽑을 때 각각 다른 name, age 값을 부여하고 싶다면

지금까지 뽑은 오브젝트들의 문제가 있습니다.

학생1이나 학생2나 name이 똑같은데요? 실용성이 없는듯 ㅅㄱ

그렇다면 실제 name 속성을 각각 다르게 해서 뽑고싶으면 어떻게 해야할까요?

그것은 함수엔 파라미터를 추가할 수 있음을 떠올리면 됩니다.

```
function 기계(이름){
  this.name = 이름;
  this.age = 15;
  this.sayHi = function(){
    console.log('안녕하세요' + this.name + ' 입니다');
  }
}
var 학생1 = new 기계('Park');
var 학생2 = new 기계('Kim');
```

함수에 파라미터를 추가한다면 앞으로 기계라는 함수를 쓸 때마다

파라미터자리에 뭔가 데이터를 넣어서 실행할 수 있는 것입니다.

▲ 그래서 마지막줄 보시면 기계()를 쓸 때 데이터를 넣어봤습니다.

![20210926_033812](/assets/20210926_033812.png)

그 'Park' 이라는 데이터는 파라미터자리에 쏙 들어가서 함수가 실행되게 되며

그럼 새로 생성되는 오브젝트의 name속성은 'Park'이 됩니다. (this.name = 'Park')

그럼이제

학생1은 { name : 'Park', age : 15 }

학생2는 { name : 'Kim', age : 15 }

이렇게 출력되겠네요.

생성되는 오브젝트마다 각각 다른 값을 부여하고 싶다면 저렇게 함수의 파라미터를 이용하시길 바랍니다.

age도 바꾸고 싶다면 파라미터를 한개 더 추가하면 되겠군요.

간단 연습문제 : 쇼핑몰에 쓸 상품데이터를 오브젝트로 여러개 만들고 싶습니다.

그래서 하드코딩해봤는데

```
var product1 = { name : 'shirts', price : 50000 };
var product2 = { name : 'pants', price : 60000 };

```

앞으로 몇십개를 더 만들어야해서 하드코딩은 그만두고 constructor를 만들어서 오브젝트를 뽑아내려고 합니다.

Q1. 위처럼 생긴 상품오브젝트들을 뽑아낼 수 있는 constructor를 제작해보세요.

그리고 실제 상품 두개를 뽑아보십시오.

Q2. 상품마다 부가세() 라는 내부 함수를 실행하면 콘솔창에 상품가격 \* 10% 만큼의 부가세금액이 출력되도록 하고 싶으면

constructor를 어떻게 수정해야할까요?

예를 들면 product1.부가세() 이렇게 쓰면 콘솔창에 5000이 출력되어야합니다.

직접 만들어보시고 펼쳐보도록 합시다

저는 Q1 Q2 합쳐서 이렇게 짰습니다. 여러분은 다를 수 있겠지만요.

```
function Product(상품명, 가격){
  this.name = 상품명;
  this.price = 가격;
  this.부가세 = function(){
    console.log(this.price * 0.1)
  }
}

var product1 = new Product('shirts', 50000);
var product2 = new Product('pants', 60000);

```

그럼 product1과 product2는 각각 name, price 그리고 부가세()라는 속성을 가지게 됩니다.

믿기지 않으면 콘솔창에 출력해보도록 합시다.

---

##### 객체지향2. 이거 보고 prototype 이해 못하면 강의 접습니다

![20210926_034100](/assets/20210926_034100.png)

우리가 저번시간 배웠던 내용은 멋진 객체지향 용어로 상속(inheritance)이라고 합니다.

기계라는 constructor가 가진 name, age 속성들을 그대로 물려받아서 오브젝트를 하나 뽑아주는게

뭐 재산 물려주는 상속과 비슷하다고 해서 상속이라고 부릅니다.

(그래서 상속해주는 것은 부모, 상속받는 오브젝트들은 자식이라고 많이 비유해서 불러요)

근데 자바스크립트엔 constructor 말고도 상속기능을 구현할 수 있는 장치가 하나 더 있습니다.

prototype이라는 것인데 알아보도록 합시다.

기계를 만드시면 prototype이라는 항목이 기계 안에 몰래 생성됩니다.

▲ 위의 사실이 진짜인지 확인해보고 싶으면 출력해보시면 됩니다.

여러분이 만든 기계는 전부 prototype이라는 항목을 내부에 몰래 생성합니다.

```
function 기계(){
  this.name = 'Kim';
  this.age = 15;
}
var 학생1 = new 기계();
var 학생2 = new 기계();

console.log(기계.prototype);
```

그럼 뭔진 모르겠는데 뭔가 출력되긴하죠?

갑자기 알게된 prototype이라는 비밀 공간은 왜 존재하고 어디에 쓰는 거냐면..

이것이 바로 부모의 유전자역할을 해주는 일종의 비밀 공간이라고 보시면 됩니다.

Q. 여러분 우리는 왜 키가 작고 못생겨서 컴퓨터 앞에서 개발이나 하고 있는 것일까요

A. 키가 작고 못생긴건 우리 탓이 아니라 부모님 탓입니다.

부모님이 작은 키가 들어있는 유전자를 물려줬기 때문에 키가 작은 것입니다.

마찬가지로 prototype은 자식들이 물려받을 수 있는 유전자라고 생각하시면 됩니다.

기계.prototype은 기계의 유전자입니다.

기계.prototype 에 뭔가 변수나 함수가 들어가있다면

기계로부터 생성되는 새로운 오브젝트들(자식들)은 전부 그걸 그대로 물려받아 쓸 수 있습니다.

예를 들면 이렇게 됩니다.

저번 시간 예제 코드에 prototype 어쩌구 한줄을 추가해보겠습니다.

```
function 기계(){
  this.name = 'Kim';
  this.age = 15;
}

기계.prototype.gender = '남';
var 학생1 = new 기계();
var 학생2 = new 기계();

console.log(학생1.gender); //'남'이 출력됩니다
```

제가 기계의 prototype이라는 곳에 { gender : '남' } 이라는 key/value 한쌍을 저장했습니다.

(prototype은 저렇게 오브젝트 자료형 다루듯이 하면 됩니다)

기계의 prototype, 즉 유전자에 gender : '남'이라는 데이터를 추가한 것입니다.

이제 학생1, 학생2 같은 기계로부터 생성되는 모든 자식들은 gender라는 속성을 사용할 수 있습니다.

진짠지는 출력해보시면 되죠?

그래서 결론은 prototype 이라는 비밀 공간을 이용하시면 똑같이 상속기능을 만들 수 있습니다.

오늘의 수업 끝입니다.

(참고)

- prototype에는 값을 여러개 부여할 수도 있고 심지어 함수도 집어넣으실 수 있습니다. object 자료처럼 다뤄주시면 됩니다.

- prototype에 추가된 데이터들은 자식들이 직접 가지는게 아니라 부모만 가지고 있습니다.

하지만 작동원리가 궁금하지 않으십니까

도대체 왜 prototype에 추가한 데이터는 자식들이 자유롭게 가져다 쓸 수 있는지 안궁금하세요?

이런거 궁금해해야 나중에 커서 훌륭한 사람이 됩니다.

그러니 같이 알아봅시다.

자바스크립트는 오브젝트에서 데이터를 뽑을 때 확인하는 순서가 있습니다.

예를 들면

```
function 기계(){
  this.name = 'Kim';
  this.age = 15;
}
기계.prototype.gender = '남';
var 학생1 = new 기계();

console.log(학생1.gender)
```

▲ 학생1.gender라고 사용하면 '남'이 출력되죠? 그 이유는..

자바스크립트는 오브젝트에서 값을 출력할 때 이런 순서로 물어봅니다.

(1) 학생1에 직접 gender라는 값이 있는가?

(2) 그럼 부모 유전자에 gender라는 값이 있는가?

(3) 그럼 부모의 부모 유전자에 gender라는 값이 있는가?

(4) 그럼 부모의 부모의 부모의 유전자에 .. 그게 있는가?

자바스크립트는 이런 알고리즘으로 작동합니다.

그냥 쉽게말하자면 오브젝트에서 값을 뽑을 때

1. 내가 직접 가지고 있는지 검사

2. 내가 가지고 있지 않으면 부모 유전자들을 차례로 검사하는구나

라고 잘 기억해주시면 됩니다.

그래서 학생1이라는 오브젝트가 gender라는 값을 가지고 있지 않지만

부모의 유전자(기계.prototype) 에 있는 gender라는 걸 출력할 수 있는 이유입니다.

작동원리2 : 자바스크립트 내장함수 toString() 을 쓸 수 있는 이유

자바스크립트 array, object 들에는 붙일 수 있는 내장함수들이 많습니다.

sort, push, toString, map, forEach 등 이런 것들을 array에 붙여서 사용가능한데 혹시 그 이유가 궁금하지 않으셨습니까.

이런거 궁금해야 고오급개발자가 됩니다.

결론부터 말하자면 매우 쉽습니다.

```
var arr = [1,2,3];
console.log( arr.toString() ); //가능
```

내가 만든 array에 arr.toString() 이렇게 붙일 수 있는 이유는

내가 만든 array의 부모 유전자가 toString()을 가지고 있기 때문입니다. (혹은 부모의 부모요)

- 내가 만든 array는 부모 기계로 부터 뽑은게 아닌데 뭔소리하는 거냐고요?

여러분 실은 array나 object 자료형 만드실 때 부모가 있긴 있습니다.

```
var arr = [1,2,3];
var arr = new Array(1,2,3);
```

▲ 위 코드 두줄은 같은 완전 똑같은 의미입니다.

위는 인간이 array 만드는 방식, 밑은 컴퓨터가 array 만드는 방식입니다.

사람은 귀찮아서 [] 그냥 대괄호쳐서 만드는데 내부적으로는 저렇게 new 키워드를 항상 이용해서 array/object를 만들어줍니다.

그럼 new Array() 이게 뭔뜻이죠?

Array라는 기계로부터 자식을 하나 새로 뽑아주세요 라는 뜻 아닌가요?

맞습니다.

그래서 Array로부터 생성된 자식들은 Array의 유전자에 부여되어있는 함수, 데이터들을 자유롭게 사용하실 수 있습니다.

Array라는 기계의 유전자가 진짜 있는지 확인은 콘솔창에 출력해보시면 됩니다.

```
console.log(Array.prototype);
```

이렇게 하면 뭐나옵니까. 여러분이 평소에 쓰던 sort, map, push, forEach 이런 것들이 등장합니다.

그래서 Array의 자식들은 전부 이런 함수들을 쉽게 가져다 쓸 수 있었던 것입니다.

Object 자료형도 똑같이 new Object() 이런 식으로 만들어주기 때문에 부모의 prototype에 있던 함수들을 자유롭게 사용가능합니다.

이것이 내장함수들의 비밀이었습니다.

Q. 그럼 prototype으로 상속시키는거랑 constructor로 상속시키는거랑 차이가 뭐죠?

A. 자식들이 값을 직접 소유하게 만들고 싶으면 constructor로 상속시키시면 되고

부모만 가지고 있고 그걸 참조해서 쓰게 만들고 싶으면 prototype으로 상속시키면 되겠쥬?

보통은 그래서 상속할 수 있는 함수 같은 것들은 prototype으로 많이 만들어놓습니다.

---

##### prototype의 특징 몇가지

저번시간에 배웠던 prototype은 여러가지 특징이 있습니다.

1. prototype은 constructor 함수에만 몰래 생성됩니다.

여러분이 일반 object, array 이런거 만들어도 거기엔 prototype이 없습니다.

끝입니다.

그럼 일반 object 같은걸 상속하고 싶으면 어떻게 하냐고요?

constructor 함수를 만들던가.. 아니면 다음 시간에 알려주는 Object.create()를 쓰거나 class를 쓰거나 셋 중 하나 하시면 됩니다.

2. 내 부모님 유전자를 찾고 싶다면 **proto**를 출력해보시면 됩니다.

부모로부터 생성된 자식 object들은 **proto**라는 속성이 있습니다.

이걸 출력해보시면 부모의 prototype이 출력됩니다.

그래서 **proto**는 부모의 prototype과 같은 의미입니다.

진짜 그런지 한번 출력해봅시다.

```
function 기계(){
  this.name = 'Kim';
  this.age = 15;
}
var 학생1 = new 기계();
console.log(학생1.__proto__);
console.log(기계.prototype);
```

학생1.**proto**

기계.prototype

각각 출력해보시면 똑같은게 나오죠?

아무튼 그래서 "**proto**는 부모 prototype을 의미한다" 라고 알아두시면 되겠습니다.

그냥 **proto**는 내 부모 유전자가 뭔지 유전자 검사하고 싶을 때 쓸 수 있는 그런 값이라고 생각하시면 되겠습니다.

3. **proto**를 직접 등록하면 object끼리 상속기능을 구현가능합니다.

**proto**는 부모의 prototype을 의미한다 라고 했습니다.

그럼 어떤 object에다가 **proto**를 강제로 하나 설정해버리면 어떻게 될까요?

오 이런 부모님이 생겨버립니다.

일종의 유전자 공학인데 한번 실험해봅시다.

```
var 부모 = { name : 'Kim' };
var 자식 = {};

자식.__proto__ = 부모;
console.log(자식.name);
```

지금 부모와 자식 object를 하나씩 만들었습니다.

그리고 셋째줄에서 자식의 **proto**에 부모를 집어넣었습니다.

그럼 자식의 부모 유전자는 { name : 'Kim' } 이라는 오브젝트가 되는 것입니다.

그렇게 되면 자식은 이제 자식.name 속성을 자유롭게 사용할 수 있습니다.

상속기능 구현을 이렇게도 할 수 있군요.

4. 실은 콘솔창에 prototype 정보들이 항상 출력됩니다.

이거 여기 예제코드 적어놓으신 다음에

콘솔창에서 학생1 한번 출력해보십시오.

```
function 기계(){
  this.name = 'Kim';
  this.age = 15;
}
기계.prototype.gender = '남';

var 학생1 = new 기계();
```

그럼 콘솔창에 name도 나오고 age도 나올 텐데

이상한 **proto** 이런 것도 나옵니다.

![20210926_035605](/assets/20210926_035605.png)

▲ **proto**가 뭐랬습니까. 부모의 유전자라고 했죠?

그래서 이걸 항상 까보실 수 있습니다. 아마 기계.prototype이랑 똑같은 내용이 출력되겠죠.

그리고 기계.prototype의 **proto**도 조회가능합니다. (기계.prototype의 부모 유전자요)

이렇게 쭉 내 부모의 부모까지 탐색할 수도 있습니다.

탐색해보시면 모든 object 자료형의 조상은 Object() 라는 기계이며 (일명 Object.prototype)

모든 array 자료형의 조상도 Object()입니다. (중간에 Array()라는 부모도 있고요)

모든 함수 자료형의 조상도 Object() 입니다.

(그래서 자바스크립트는 모든게 다 Object라고 말하는 것입니다.)

##### constructor, prototype 연습문제 4개

0. 오브젝트 자료 여러개를 만들고 싶습니다.

제일 잘하는게 하드코딩이기 때문에 하드코딩해봤습니다.

```
var 학생1 = { name : 'Kim', age : 20 }
var 학생2 = { name : 'Park', age : 21 }
var 학생3 = { name : 'Lee', age : 22 }
```

하드코딩해서 3개를 만들긴 했는데 앞으로 만들일이 더 많이 생길 것 같아서 constructor를 제작하려고 합니다.

constructor문법을 사용해서 위의 오브젝트와 똑같은 오브젝트 3개를 한번 뽑아보십시오.

- 여기에 학생1.sayHi()라고 사용하면 "안녕 나는 Kim이야" 라는 글자가 콘솔창에 나오도록 sayHi()라는 함수도 constructor 안에 추가해보세요.

이건 답안인데 직접 해보고 펼쳐봐야합니다. 안그러면 대머리됨

```
function Student(이름, 나이){
this.name = 이름;
this.age = 나이;
this.sayHi = function(){
console.log('안녕 나는 ' + this.name + '이야');
}
}

var 학생1 = new Student('Kim', 20);
var 학생2 = new Student('Park', 21);
var 학생3 = new Student('Lee', 22);
```

이렇게 하시면 됩니다. 별거아닙니다.

sayHi 함수를 prototype에 추가하셔도 전혀 상관없을 것 같습니다.

1. 다음 코드의 출력 결과는 무엇일까요?

```
function Parent(){
this.name = 'Kim';
}
var a = new Parent();

a.**proto**.age = 30;
console.log(a.age)
```

펼쳐보기 전에 뭐가 답인지 빨리 마음의 결정하십시오

답은... 30입니다.

1~4번줄에서는 그냥 Parent()라는 기계를 이용해서 새로은 a라는 자식을 뽑아내는 과정이었을 뿐입니다.

근데 그 다음줄 `a.**proto**.age = 30;` 이게 문제입니다.

이게 무슨뜻일까요?

이것은 a의 부모 prototype에 age : 30 이라는 값을 추가해라 라는 뜻이었습니다.

그래서 Parent()라는 기계의 prototype에 30이 추가가 되는 것이고

a.age 하면 30이라는 값이 출력되는 것입니다.

2. 함수가 안들어가요 엉엉

위에 0번 문제에서 Student라는 부모에 sayHi라는 함수를 하나 추가하라고 했죠?

그래서 sayHi()라고 사용하면 "안녕 나는 ~이야" 라고 내 이름을 출력해주는 함수를 prototype에 추가했습니다.

하단처럼 만들었는데 의도한 대로 이름이 출력되지 않고 있습니다.

원인은 무엇일까요?

```
function Student(이름, 나이){
this.name = 이름;
this.age = 나이;
}

Student.prototype.sayHi = () => {
console.log('안녕 나는 ' + this.name + '이야');
}
var 학생1 = new Student('Kim', 20);

학생1.sayHi(); //왜 이 코드가 제대로 안나오죠?
```

아마 이게 아닐까요

sayHi() 라는 함수를 prototype에 추가할 때 arrow function을 사용했습니다 .

결론부터 말하자면 arrow function은 그냥 일반 function 대체품이아닙니다.

arrow function은 this를 바깥에 있는 this를 그대로 사용하고 싶을 때 쓰는 함수라고 했었습니다.

암튼 그런데 sayHi() 함수를 만들 때 arrow function을 사용해서

내부에 있던 this라는 값이 이상해진 것이었습니다.

```
Student.prototype.sayHi = () => {
    console.log(this);
}

```

sayHi 함수에 그냥 this 하나만 출력해보시면 window 같은게 출력될 것입니다. (strict mode에선 undefined)

이전 강의내용에 따르면 arrow function을 사용하시면 그냥 바깥 아무데나 있던 값을 가져와서 사용합니다.

바깥 this 값은 window이며,

그 window를 그대로 저기 함수 안에다가 적용했기 때문입니다.

그래서 this가 이상해서 그랬던 문제였습니다.

Q. 잉 오브젝트 안의 함수(메소드)에서 this를 쓰면 "함수의 주인"을 출력한다고 하지 않았습니까?

prototype이라는 곳도 일종의 오브젝트 자료형인데 왜 sayHi안에서 this를 출력해보면 window인 것이죠?

A. 음 오브젝트 안의 함수(메소드)에서 this를 출력하면 "함수의 주인"이 맞습니다.

근데 그 함수를 arrow function으로 만드시면.. this가 "함수의 주인"으로 재정의되지 않습니다.

```
var 오브젝트 = { sayHi : () => { console.log(this) } }
오브젝트.sayHi();
```

▲ 위 코드의 this는 무엇이 출력될까요?

sayHi 함수의 주인인 오브젝트가 아니라 window가 출력됩니다.

sayHi를 만들 때 그냥 일반함수였다면 this가 "함수의 주인"으로 뿅 하고 변할텐데

arrow function을 쓰시면 this값이 변하지 않습니다. 그냥 밖에 있던 this를 그대로 적용합니다. (밖에 있던 this는 window죠)

3. 모든 array에 적용할 수 있는 함수를 직접 새로 만들려면 어떻게 해야할까요?

모든 array에 붙일 수 있는,

array 내에 있는 3이라는 값을 제거해주는 유용한 함수를 하나 만들고 싶습니다.

```
var arr = [1,2,3];
arr.remove3();

console.log(arr); //[1,2]
```

이렇게 array뒤에 붙이기만 하면 array 내의 3이라는 모든 숫자 자료들이 삭제됩니다.

멋있게 이름은 remove3() 이라고 하겠습니다.

remove3()함수는 어떻게, 어디에 만들어야 모든 array에 쓸 수 있을까요?

검색도 좋은 공부방법입니다.

일단 모든 array에 pop(), sort(), push() 이런 함수를 붙일 수 있는 이유 혹시 기억나십니까.

모든 array 자료형은 부모가 Array로 부터 new Array() 이런 식으로 만들어지기 때문에

Array라는 부모의 prototype에 있는 함수들을 자유롭게 가져다 쓸 수 있어서 그렇습니다.

그럼 우리도 Array의 prototype에 remove3라는 함수를 하나 추가해주면 되는게 아닐까요?

맞습니다.

```
Array.prototype.remove3 = function(){
  this 에서 3을 찾아서 제거해주세요
}
```

이렇게 코드를 짜면 되겠군요.

위의 코드에서의 this라는 키워드는 현재 remove3이라는 함수를 작동시키는 object (여기서는 array) 라는 뜻입니다.

그럼 this라는 array에서 3을 제거하는 코드는 어떻게 짭니까?

100가지 방법이 있는게 그 중 하나를 쓴다면 ..

저는 this라는 array 안에 있는 데이터를 하나하나 출력하면서 3과 비교하려고 반복문을 썼습니다.

```
Array.prototype.remove3 = function(){
  for (var i = 0; i < this.length; i++) {
    if ( this[i] === 3 ) {
      this.splice(i,1);
    }
  }
};

var arr = [1,2,3,4];
arr.remove3();

console.log(arr); //[1,2,4]
```

그냥 어려운거 아니고 remove3()함수는

1. this라는 array의 길이만큼 반복문을 돌리는데, 돌리는 과정에서 this[i] 라고 쓰면서 this 안에 있는 모든 데이터를 출력해봅니다.

2. 만약에 this[i]가 3이면

3. this라는 array에서 i번째 자료를 제거해주세요

라고 썼습니다. (splice 라는 함수는 array안에 뭘 제거할 때 가끔씁니다. 구글 검색하시면 나와염)

이렇게 성공적으로 remove3() 함수를 제작했군요. 짝짝짝

remove3을 만들었는데 remove(3) 이런 식으로 원하는 데이터를 집어넣으면 제거해주는 함수로

업그레이드도 한번 해보시길 바랍니다.

실은 find나 filter나 비슷한 내장함수가 있긴 합니다만

내가 자주 사용할법한 내장함수들을 많이 만들어두시면 더 효율적인 코딩생활이 가능합니다.

혹은 이런 함수들 모아서 나중에 자바스크립트 라이브러리화 해서 사용해도 괜찮을 것 같습니다.

---

##### (간만에 쉬운거) ES5방식으로 쉽게 구현하는 상속기능

![20210926_163418](/assets/20210926_163418.png)

prototype이니 this니 class니 뭐니 어렵다면 그냥 ES5 방식으로 하셔도 됩니다.

ES5 출시 때 나온 Object.create()라는 신기한 문법이 하나 있는데

내가 상속을 이용해서 오브젝트를 만들고 싶다면 이거보다 더 쉬운 문법이 없습니다.

하지만 class문법에 밀려 인지도는 낮습니다.

Object.create() 사용하기

Object.create(부모object);

이렇게 사용하시면 이 자리에 오브젝트 자료형 하나가 남습니다.

그리고 소괄호 안에 적은 부모object가 유전자(prototype)가 되는 것이고요.

한번 예를 들어봅시다.

```
var 부모 = { name : 'Kim', age : 50 };
var 자식 = Object.create(부모);

console.log(자식.age); //50나옴
```

이렇게 쓴다는 소리입니다.

그럼 자식이라는 object는 부모를 prototype으로 두게 됩니다.

그럼 자식.name 해도 'Kim'이 출력되고요, 자식.age 해도 50이 출력됩니다.

자식이 성공적으로 부모 속성들을 상속했죠?

상속기능 만들기 끝입니다. 매우 간단하고 쉽습니다.

그럼 자식이 age를 바꾸고 싶으면 어떻게 하죠?

자식놈은 50살이 아닌데 자꾸 age가 50이라고 하네요.

이걸 20살로 바꿔봅시다.

```
var 부모 = { name : 'Kim', age : 50 };
var 자식 = Object.create(부모);
자식.age  = 20;

console.log(자식.age); //20 나옴
```

그냥 자식이라는 object에 age : 20 이라는 값을 부여했을 뿐입니다.

그럼 이제 자식.age 할 때마다 20이 출력됩니다.

Q. 부모로부터 상속받은 50이라는 age가 출력되지 않는 이유는 뭐죠?

A.

면접관이 이렇게 물으면 어떻게 답변할 것임
왜냐면 자바스크립트 오브젝트 자료형에서 특정 자료를 꺼낼 때 묻는 순서가 있다고 배웠었습니다.

자식.age를 꺼내주세요~ 라고 하면

1. 자식이라는 object가 직접 age를 가지고 있으면 그거 출력

2. 없으면 자식의 부모 prototype을 뒤져서 age가 거기 있으면 그거 출력

3. 거기도 없으면 부모의 부모 prototype을 뒤져서..

이런 순서로 age를 출력합니다.

그래서 지금 자식놈은 20이 나오는 것입니다.

손자도 쉽게 만들 수 있습니다.

그니까 자식의 자식도 쉽게 만들 수 있다는 소리입니다.

부모가 가진 속성, 자식이 가진 속성을 전부 물려받는 손자를 만들어봅시다.

```
var 부모 = { name : 'Kim', age : 50 };
var 자식 = Object.create(부모);
자식.age  = 20;

var 손자 = Object.create(자식);

console.log(손자.age);
```

손자를 만들었습니다.

얘는 자식과 부모가 가진 속성들을 전부 물려받는 애입니다.

그럼 손자.age하면 무엇이 나올까요?

20이 출력됩니다.

아직도 왜 20이 나오는지 궁금하다면

1. 손자에 age가 있는지 확인하고

2. 없으면 부모 prototype에 있는지 확인하고

3. 거기도 없으면 부모의 부모 prototype에 있는지 확인하고..

그렇게 하나씩 확인해서 젤 가까운 age를 출력시키기 때문입니다.

![20210926_164047](/assets/20210926_164047.png)

아무튼 이게 상속의 상속을 받는 방법입니다. 매우 간단하죠?

값 추가도 여러분 object 다루듯이 하면 되니까 쉽습니다.

함수 추가하는 것도 그냥 등호로 넣으면 되니까 쉽고요.

하지만 요즘 개발자들은 있어보이게 class, 그리고 extends 문법을 이용해서 상속의 상속기능을 만들어냅니다.

자바같은 프로그래밍 언어 하던 분들이 보면 친숙하게 느낄텐데

외울게 많아 우리는 약간 거부감이 들 수 있습니다.

![20210926_165124](/assets/20210926_165124.png)

---

##### 객체지향4. ES6방식으로 안쉽게 구현하는 상속기능 (class)

![20210926_165558](/assets/20210926_165558.png)

class 라는 문법이 있습니다.

constructor, prototype 을 이용한 상속기능을 간지나게 만들 수 있게 도와주는 문법입니다.

기존 function부터 시작하던 문법과 기능상 차이는 크게 없고 약간 더 보기쉽게 표현해줄 뿐입니다.

어떻게 하는지 자세히 알아봅시다.

ES6 class 키워드로 구현하는 constructor 기계만들기

constructor 라는건 저번시간에 했기 때문에 다들 아시죠?

오브젝트 뽑는 기계였습니다.

ES6 class라는 신문법으로 constructor를 만드시려면 이렇게 따라치시면 됩니다.

```
class 부모 {
  constructor(){
    this.name = 'Kim'
  }
}

var 자식 = new 부모();
```

끝입니다. 예전 function 부모(){} 어쩌구 이렇게 기계를 만드는 문법과 똑같은 문법입니다.

이제 new 키워드를 이용해서 방금 만든 부모라는 기계에서 오브젝트를 새로 생성할 수 있는 것이고요.

constructor()라고 쓴 부분에 예전처럼 this.name 어쩌구 하시면 새로 생성되는 오브젝트들에 값을 부여할 수 있습니다.

이게 끝입니다.

상속가능한 함수를 추가하려면 어떻게 해야할까요?

예전에 sayHi 이런거 하면서 배웠던 두가지 방법이 있습니다.

1. 함수를 this.sayHi 이렇게 constructor 안에 추가하는 방법과

2. 기계의 prototype에 추가하는 방법이 있었죠?

▼ 1번은 똑같이 이렇게 하시면 되겠죠?

```
class 부모 {
  constructor(){
    this.name = 'Kim';
    this.sayHi = function(){ console.log('hello') }
  }
}

var 자식 = new 부모();
```

그럼 새로생성되는 자식은 sayHi() 함수를 직접 가지게 되며 자유롭게 쓸 수 있습니다.

![20210926_170045](/assets/20210926_170045.png)

▼ 2번처럼 prototype에 추가하시려면

```
class 부모 {
  constructor(){
    this.name = 'Kim';
  }
  sayHi(){
    console.log('hello')
  }
}

var 자식 = new 부모();
```

이런 식으로 하시면 됩니다.

오브젝트에 함수추가하듯 하시면 됩니다요.

그럼 자식은 sayHi()라고 썼을 때 부모의 prototype에 있던 sayHi() 함수를 쓸 수 있습니다.

(혹은 그냥 부모.prototype.sayHi = function(){} 이렇게 하셔도 되고요)

참고로 알아두는 Object.getPrototypeOf()

이 함수 안에 오브젝트를 넣으시면 부모 prototype을 출력해줍니다.

이 오브젝트가 대체 누구로부터 prototype을 상속받고 있는지를 알려주는 함수죠.

**proto**라는 키워드와 비슷한 역할을 한다고 보시면 됩니다.

constructor안에 파라미터 추가하기

ES6 방식으로 constructor 만들 때 파라미터를 추가하려면 이렇게 하시면 됩니다.

```
class 부모 {
  constructor(이름, 나이){
    this.name = 이름;
    this.age = 나이;
  }
}

var 자식 = new 부모('Park', 30);
```

이런 식으로 하시면 파라미터를 넣어서 constructor를 만들 수 있습니다.

자식을 생성할 때 이제 파라미터 두개를 입력할 수 있겠군요.

![20210926_170404](/assets/20210926_170404.png)

##### 객체지향 문법 쓰는 이유는 객체 여러개 만들어서 쓰기 위함이다.

prototype 내에 함수 여러개 추가하기

그냥 별건 아니고 이렇게 하면 됩니다.

```
class 부모 {
  constructor(이름, 나이){
    this.name = 이름;
    this.age = 나이;
  }
  sayHi(){
    console.log('안녕');
  }
  sayHello(){
    console.log('안녕하세요');
  }
}

var 자식 = new 부모('Park');
```

이렇게 쭉 써주시면 prototype에 sayHi, sayHello 등 여러개 함수를 동시에 넣을 수 있겠군요.

별거 아닙니다.

----------

##### 객체지향5. class를 복사하는 extends / super


지금까지 class, prototype, constructor 이걸 전부 이해하신 분들을 위해 준비했습니다.

자바스크립트 객체지향 문법의 끝판왕인 extends를 배워보도록 합시다.

어렵진 않고 그냥 외울게 몇개 더 생기는 것일 뿐입니다.

class, prototype, constructor가 뭔지 어디다 쓰는지 남들에게 설명할 수 있다면 들으시고

설명할 수 없다면 이번강의 보다 전 강의들 한번 더 듣는게 나을 수 있습니다.




![20210926_181152](/assets/20210926_181152.png)




class를 상속한 class를 만들고 싶을 때 쓰는 extends



할아버지 class를 하나 만들었다고 칩시다.

할아버지 class는 성과 이름이라는 속성을 가지고 있습니다.

```
class 할아버지{
  constructor(name){
    this.성 = 'Kim';
    this.이름 = name;
  }
}
```

그럼 이제 new 할아버지() 뭐 이런식으로 하면 새로운 object를 쉽게 생성할 수 있겠죠?

그런데 이 class가 너무나도 유용한 나머지 이것과 유사한 class를 하나 더 만들고 싶습니다.

그러면 직접 class를 하나 더 만들어서 내용을 복붙하면 되겠죠?

하지만 class안에 복사할 내용이 너무나도 많으면 코드가 너무나도 길어집니다.



그래서 고대의 개발자들이 extends라는 문법을 만들었는데

이걸 이용해서 class를 만드시면 기존에 있던 class의 내용을 그대로 복붙해서 만들어낼 수 잇습니다.

있어보이게 말하면 "다른 class를 상속해서 만들 수 있게 도와주는 문법"이죠.







그래서 할아버지 class를 상속하는 아버지 class를 만들어보겠습니다. 따라하세요.


```
class 할아버지{
  constructor(name){
    this.성 = 'Kim';
    this.이름 = name;
  }
}

class 아버지 extends 할아버지{

}

```


extends는 이렇게 쓰면 됩니다.

그럼 이제 할아버지라는 class를 그대로 복붙한 아버지라는 class가 생성됩니다.

진짜 class가 생겼는지 확인해보고 싶으면 new 아버지(); 이렇게 테스트 해보면 되겠죠?



new 아버지('만수'); 이렇게 하시면 성과 이름을 가진 object 자료가 하나 생성됩니다.

할아버지랑 똑같은 class가 생겼죠? extends 문법 끝!











근데 아버지라는 class에는 새로운 속성을 추가하고 싶으면



당연히 아버지 constructor안에 내용을 추가하시면 됩니다.


```
class 할아버지{
  constructor(name){
    this.성 = 'Kim';
    this.이름 = name;
  }
}

class 아버지 extends 할아버지{
  constructor(){
    this.나이 = 50;
  }
}

```

이렇게 하면 new 아버지() 했을 때 생성된 오브젝트들은 {성, 이름, 나이} 속성들을 가지겠군요.

하지만 이러면 에러가 납니다.

super를 써야된다고 에러가 나네요.

그럼 super를 써주시면 됩니다.








```
class 할아버지{
  constructor(name){
    this.성 = 'Kim';
    this.이름 = name;
  }
}

class 아버지 extends 할아버지{
  constructor(){
    super();
    this.나이 = 50;
  }
}
```
super()라는 이상한 함수는

"extends로 상속중인 부모 class의 constructor()"를 의미합니다. (암기사항)

쉽게 말하면 할아버지 class의 constructor() 이거랑 똑같다는 소리입니다. (암기해야됨)

그래야 이제 에러없이 this.나이 이런걸 추가하실 수 있습니다. (암기 ㄱ)







근데 할아버지 class의 constructor()에는 name 파라미터를 입력할 수 있었죠?

그것도 똑같이 따라서 명시해주셔야 할아버지가 가진 모든 속성들을 정확히 상속받을 수 있습니다.


```
class 할아버지{
  constructor(name){
    this.성 = 'Kim';
    this.이름 = name;
  }
}

class 아버지 extends 할아버지{
  constructor(name){
    super(name);
    this.나이 = 50;
  }
}

```

할아버지 constructor()에 name이라는 파라미터가 있던걸 그대로 아버지 constructor()에도 따라했습니다.

(파라미터 작명은 자유롭게 가능합니다)

이제 그럼 new 아버지(); 할 때 파라미터를 입력하면 this.이름 속성에 들어가게 되겠네요.



그럼 예상해봅시다.

Q. 위 코드 하단에 var a = new 아버지('만수'); 이렇게 적으면 a라는 변수는 어떤 내용을 가지고 있을까요?

예상해보셨습니까

A.


1. a라는 변수는 아버지라는 class로부터 새로 생성된 오브젝트입니다.

2. 그래서 할아버지가 가지고 있던 성, 이름 그리고 아버지가 가지고 있던 나이를 전부 물려받았습니다.  

3. 그리고 this.이름 자리에는 '만수'를 넣어 실행했습니다.  



그래서 { 성 : 'Kim', 이름 : '만수', 나이 : 50 } 이라는 오브젝트가 됩니다.






할아버지에 메소드(함수)를 추가한다면



할아버지 class 안에 함수를 추가한다면 아버지 class의 자식들도 물려받아 쓸 수 있을까요?

실험해보면 되겠죠?




```
class 할아버지{
  constructor(name){
    this.성 = 'Kim';
    this.이름 = name;
  }
  sayHi(){
    console.log('안녕 나는 할아버지')
  }
}

class 아버지 extends 할아버지{
  constructor(name){
    super(name);
    this.나이 = 50;
  }
}

var a = new 아버지('만수');
```

그럼 이제 a라는 오브젝트는 sayHi()라는 함수를 쓸 수 있을까요?

- 쓸 수 있습니다.



a라는 오브젝트가 a.sayHi() 이렇게 사용한다면

1. a라는 오브젝트에 sayHi가 있는지 물어보고

2. 없으면 아버지.prototype에 sayHi가 있는지 물어보고

3. 없으면 할아버지.prototype에 sayHi가 있는지 물어보고

이런 식으로 sayHi를 실행하기 위해 부모님을 뒤져봅니다.





근데 sayHi()라는건 할아버지.prototype에 추가된 함수이기 때문에

a라는 오브젝트는 sayHi() 함수를 실행할 수 있습니다.











근데 class간에 함수를 상속하고 싶으면 어떻게 해요?



뭔소리냐면.. 아버지라는 class에 함수를 만들고 싶습니다.

근데 할아버지 class에 있던 sayHi()라는 함수가 너무나도 유용한 나머지

이걸 그대로 아버지 class에 가져와서 활용하고 싶은 것입니다.

그럴 때 어떻게 합니까?





이 때도 super를 쓰시면 됩니다.


```
class 할아버지{
  constructor(name){
    this.성 = 'Kim';
    this.이름 = name;
  }
  sayHi(){
    console.log('안녕 나는 할아버지')
  }
}

class 아버지 extends 할아버지{
  constructor(name){
    super(name);
    this.나이 = 50;
  }
  sayHi2(){
    console.log('안녕 나는 아버지');
    super.sayHi();
  }
}

var a = new 아버지('만수');
```

super라는걸 저렇게 prototype 함수 안에서 쓰시면 아까의 super와 약간 다른 의미가 됩니다.

여기서의 super는 부모 class의 prototype을 의미합니다.

알겠쥬? super는 뜻이 두개입니다.



1. constructor 안에서 쓰면 부모 class의 constructor

2. prototype 함수 안에서 쓰면 부모 class의 prototype

입니다. 아이고 외우기 힘드니까 2번은 참고로만 알아둡시다.







Q. 그럼 위의 예제 코드에서 a.sayHi2()를 실행하면 무엇이 콘솔창에 출력될까요?


A.
정확히 한번 예상해보시고 펼쳐봅시다


a.sayHi2()를 사용하신다면 아버지.prototype에 있던 sayHi2 함수가 동작합니다.

그 함수는 일단 console.log('안녕 나는 아버지')를 실행하고

둘째 줄에서 super.sayHi()를 실행합니다. 이건 다른말로 할아버지.prototype.sayHi()와 똑같기 때문에

console.log('안녕 나는 할아버지')를 실행할 것입니다.

그래서 콘솔창에 "안녕 나는 아버지" "안녕 나는 할아버지"가 출력됩니다.


-----


##### getter, setter 대체 왜 쓰는지 알아보기






많은 분들이 왜 쓰는지 궁금해하는 자바스크립트 getter, setter 문법을 알아봅시다.

얕게 말하자면 오브젝트 내의 함수들을 괄호없이 쓸 수 있게 만들어주는 키워드인데

깊숙히 들어가면 데이터의 무결성을 보존하기 위해 쓰는 키워드라고 보시면 됩니다.



요즘 원본 데이터는 immutable 해야한다 이런말 들어보셨습니까.

데이터를 수정하거나 출력할 때 직접 원본 데이터를 만지는게 아니라 함수로 간접적으로 다루는게 대세를 이루고 있는데

거기에 합치되는 일종의 코딩 테크닉이라고 보시면 됩니다.

이걸 이해하려면 일단 object 데이터를 다루는 방법론에 대해 알아야합니다.









함수로 object 데이터를 꺼내는 방법



object 데이터를 하나 만들어봅시다. 여러분의 이름과 나이를 한번 저장해보십시오.  


```
var 사람 = {
  name : 'Kim',
  age : 30,
}
```

그 다음에 여러분의 내년 나이를 출력해보고 싶으면 어떻게 할까요?

사람.age + 1 이렇게 하면 될까요?

맞습니다. 그런데 미래를 생각하는 개발자들은 내년 나이를 출력해주는 함수를 만들어 사용합니다.




```
var 사람 = {
  name : 'Kim',
  age : 30,
  nextAge(){
    return this.age + 1
  }
}
```

이렇게 함수를 만들어놓으면

사람.nextAge() 이렇게 사용하면 내년 나이가 출력되겠죠? 31이라고 출력되겠네요.

이렇게 데이터를 끄집어내서 사용하는 방법이 요즘 유행입니다.





굳이 왜 이렇게 하냐면

- object 안의 데이터가 복잡할 수록 함수 만들어놓는게 데이터 꺼내기 쉽습니다.

- 내부에 있는 name, age 변수를 건드리지 않아서 실수를 방지할 수 있어서 안전합니다.

특히 매우 긴 object 안에 원하는 자료 몇개만 뽑고 싶을 때

미리 저렇게 함수를 만들어놓으면 매번 기능개발해줄 필요가 없습니다.





(참고)

다른 언어에선 코드가 class 단위로 동작하는데

class 안에 가끔 외부로 부터 보호하고 싶은 변수들이 있습니다.  

그럴 때 저런 함수를 많이 만들어 사용합니다. 그런 코딩스타일을 자바스크립트에 그대로 적용하고 있다고 보면 됩니다.

(보호라는 뜻은 그냥 실수로 수정하는거 방지입니다)













함수로 object 데이터를 수정하는 방법



이번엔 object에 있는 age 데이터를 수정하고 싶습니다.

40으로 변경하고 싶습니다. 어떻게 할까요?

사람.age = 40 이렇게 등호를 이용하면 수정되긴하죠?

하지만 미래를 생각하는 개발자들은 데이터 수정을 위한 함수를 만들어 사용합니다.



![20210926_190401](/assets/20210926_190401.png)

```
var 사람 = {
  name : 'Kim',
  age : 30,
  setAge(나이){
    this.age = 나이
  }
}
```

setAge()라는 함수를 오브젝트 내에 추가했습니다.

그리고 이 함수는 파라미터를 한개 입력할 수 있는데 그 파라미터를 그대로 this.age에 집어넣어주는 역할을 합니다.

그럼 이제 사람.setAge(40) 이렇게 쓰시면 자유롭게 나이 변경이 가능합니다.  





사람.age = 40 이렇게 쉽게 안하고

사람.setAge(40) 굳이 이렇게 하는 이유는

- 원본 데이터를 덮어쓰지 않고 카피 데이터로 관리할 수 있게 됩니다.

- 내부에 있는 name, age 변수를 직접 건드리지 않아서 실수를 방지할 수 있습니다.

한 겹의 안전장치를 만든다고 보면 됩니다.







안전장치가 뭐냐면 예를 들면
```
사람.setAge('40')
```
▲ 나이에 숫자를 집어넣어야하는데 이렇게 실수로 '40' 이라는 문자를 집어넣으면 어떻게 될까요?

그냥 잘 저장됩니다. 데이터가 오염됩니다.

나중에 나이에 1을 더하고 싶을 때 에러도 유발할 수 있겠죠.





근데 데이터 수정하는 함수를 사용하시면 살짝 안전장치를 더해줄 수 있습니다.


```
var 사람 = {
  name : 'Kim',
  age : 30,
  setAge(나이){
    this.age = parseInt(나이)
  }
}

사람.setAge('200'); //문자 넣었는데도 숫자 200으로 저장됨
```

▲ setAge()라는 함수안에 기능을 하나 추가했죠?

parseInt()라는 함수는 '40'같은 문자를 숫자 40으로 바꿔주는 고마운 자바스크립트 내장함수입니다.

이렇게 문자를 집어넣어도 숫자로 바꿔주는 안전장치도 이렇게 쉽게 개발이 가능한 것입니다.

그러니 굳이 함수를 만들어놓고 데이터를 수정하는 미친 사람들이 조금이라도 이해가 될 것 같군요



함수 쓰기 복잡하다면 get/set 키워드를 붙이자



함수를 만들어쓴다면 단점이 있죠?

setAge(40) 이렇게 소괄호까지 써야되고 뭔가 데이터 집어넣기 너무 복잡해집니다.

그렇다면 get/set 키워드를 함수 옆에 추가하시면 됩니다.


![20210926_190702](/assets/20210926_190702.png)

```
var 사람 = {
  name : 'Kim',
  age : 30,
  set setAge(나이){
    this.age = parseInt(나이)
  }
}

사람.setAge = 40; //set 키워드를 추가하면 이렇게 함수를 사용가능
```
▲ setAge() 함수 만들 때 왼쪽에 set이라는 키워드를 추가하시면

이제 등호로 데이터를 입력하거나 하실 수 있습니다.

보기도 쉽고 직관적이고 그렇죠?

그래서 set을 사용합니다. 그리고 set 붙은 함수들은 setter라고 부릅니다. (데이터를 set 하는 (수정하는) 함수라는 뜻)



```
var 사람 = {
  name : 'Kim',
  age : 30,
  get nextAge(){
    return  this.age + 1  
  }
}

console.log( 사람.nextAge ) //get 키워드를 추가하면 이렇게 함수를 사용가능
```

▲ nextAge()라는 함수를 만들 때는 get 키워드를 사용가능합니다.

그러면 이제 소괄호 없이 nextAge를 사용해서 데이터를 꺼낼 수 있습니다.

보기도 쉽고 직관적이고 그렇죠?

그래서 get을 사용합니다. 그리고 get 붙은 함수들은 getter라고 부릅니다. (데이터를 get하는 (가져오는) 함수라는 뜻)











get/set 사용하는 기준은



그냥 데이터를 뽑아주는, 가져와주는, get 해주는 함수들은 get 쓰시면 되고

데이터를 입력해주는, 수정해주는, set 해주는 함수들은 set 쓰시면 됩니다.

그리고 규칙도 있습니다.

set 함수는 데이터를 입력해서 수정해주는 함수니까 파라미터가 한개 꼭 존재해야하고

get 함수는 파라미터가 있으면 안되고 함수 내에 return을 가져야합니다.



잘못 쓰면 에러를 알려주니까 외울 건 없고

보통 그냥 get 느낌나는 함수들은 get 붙이면 별일 없으니 그닥 어렵진 않습니다.  




![20210926_190754](/assets/20210926_190754.png)


똑같은 작업을 클래스에서도 사용이 가능하다.





class에서 사용하는 get/set



class 안에서 함수 만들 때 get/set 키워드를 이용해서 getter/setter 식으로 함수를 만들 수 있습니다.


```
class 사람 {
  constructor(){
    this.name = 'Park';
    this.age = 20;
  }
  //get nextAge(){  //프로토 타입 함수에도 get/set가능
  //  return this.age + 1
  //}

  nextAge(){    //데이터 수정/출력 함수를 만들어 쓰는 이유?->검사를 하고싶다 뭘 거르고 싶다 이런걸 하고싶다.

    return this.age + 1
  }
  set setAge(나이){
    this.age = 나이;
  }
}

var 사람1 = new 사람();
```


class 안의 함수들을 getter/setter로 만들어 쓰고 싶으면 이렇게 하시면 됩니다.

이제 새로 뽑인 object인 사람1은

사람1.nextAge;

사람1.setAge = 50;

이렇게 사용하실 수 있겠군요.





class에서의 getter/setter 용도는 위에서 설명한 내용과 똑같습니다.

새로 뽑힌 오브젝트들 내용을 편리하게 수정할 때 사용합니다.

굳이 get/set 키워드가 없어도 상관없습니다.


-------------------


##### class, extends, getter, setter 연습문제


1. 직접 class 구조 만들어보기



갑자기 강아지 SNS를 만들고 싶어서 자바스크립트로 열심히 코딩하던 중,

여러 강아지 정보들을 담은 유사한 오브젝트 자료형을 테스트삼아 몇개 만들려고 합니다.


```
var 강아지1 = { type : '말티즈', color : 'white' };
var 강아지2 = { type : '진돗개', color : 'brown' };
```


이렇게 쭉 많이 만들고 싶은데 하드코딩하기 싫어서 class를 만들어 강아지 오브젝트들을 뽑고 싶습니다.

그럼 class를 어떻게 만드는게 좋을까요?



만들어보셨습니까


이렇게 만들면 되겠습니다.


```
class Dog {
  constructor(타입, 칼라){
    this.type = 타입;
    this.color = 칼라;
  }
}
var 강아지1 = new Dog('똥개', 'black');
```

그럼 이제 Dog 이라는 class로 부터 새로운 강아지 오브젝트들을 쉽게 뽑아낼 수 있겠군요.





2. 이번엔 고양이관련 object들을 만들고 싶습니다.



이번엔 class를 이용해 고양이 오브젝트 여러개를 뽑고 싶습니다.


```
var 고양이1 = { type : '코숏', color : 'white', age : 5 };
var 고양이2 = { type : '러시안블루', color : 'brown', age : 2 };
```

type, color는 이전에 만든 강아지 object와 유사한데

고양이들만 특별하게 age라는 속성을 하나 더 추가하고 싶습니다. 어떻게 class를 만들면 될까요?

1번 문제에서 만들었던 강아지 class와 유사하기 때문에 extends라는 문법을 쓰는 것도 좋겠군요.



만들어보셨겠쥬


저는 위에서 만들었던 Dog 를 그대로 이용하기 위해

extends 문법을 사용했습니다.


```
class Dog {
  constructor(타입, 칼라){
    this.type = 타입;
    this.color = 칼라;
  }
}

class Cat extends Dog {
  constructor(타입, 칼라, 나이){
    super(타입, 칼라);
    this.age = 나이;
  }
}


var 고양이1 = new Cat('동네고양이', 'white', 5);
```


이제 쉽게 고양이 오브젝트들을 뽑아낼 수 있습니다.

파라미터 어떻게 쓰는지 궁금하다면

지금 고양이 오브젝트에 필요한 파라미터를 constructor()안에 다 나열해주시면 되고

Dog로부터 물려받은 속성들에 필요한 파라미터들은 그대로 super() 안에 넣어주시면 됩니다.

혹은 그냥 super()함수는 Dog의 constructor()를 그대로 복붙했다~라고 생각하셔도

쉽게 사용법을 파악할 수 있을겁니다.






3. 고양이와 강아지 object들에 기능을 하나 추가하고 싶습니다.



모든 고양이와 강아지 object들은 .한살먹기() 라는 함수를 사용할 수 있습니다.

(1) 한살먹기 함수는 강아지 class로부터 생성된 오브젝트가 사용하면 콘솔창에 에러를 출력해주어야합니다.

(2) 한살먹기 함수는 고양이 class로 부터 생성된 오브젝트가 사용하면 현재 가지고있는 age 속성에 1을 더해주는 기능을 실행해야합니다.



한살먹기 함수는 어떻게 만들면 좋을까요? (검색이 필요할 수 있습니다)



1시간 검색해보고 노가다해봐도 모르겠다면




일단 한살먹기() 함수는 Dog에 추가했습니다. 왜냐면 Cat, Dog 둘다 사용가능해야하니까요.

뭐 Dog에 따로 Cat에 따로 이렇게 하셔도 무방한데 저는 이랬습니다.

그래서 고양이들 강아지들은 전부 한살먹기()를 사용할 수 있습니다.


```
class Dog {
  constructor(타입, 칼라){
    this.type = 타입;
    this.color = 칼라;
  }
  한살먹기(){
    if( this instanceof Cat) {
    this.age++
    }
  }
}

class Cat extends Dog {
  constructor(타입, 칼라, 나이){
    super(타입, 칼라);
    this.age = 나이;
  }
}
```

그럼 이제 한살먹기()를 고양이들이 쓰면 나이를 1살 더해주고,

강아지들이 쓰면 에러를 출력해줘야하는데 그걸 구분하기 위해 함수 안에 if문을 추가했습니다.



###### 자바스크립트는 instanceof 라는 고마운 연산자가 있습니다.

###### a instanceof b 이렇게 쓰시면 a가 b로부터 생성된 오브젝트인지 아닌지를 true/false로 알려주는 연산자입니다.

그래서 한살먹기()라는 함수를 만들고 this.age++를 해주는 기능을 넣었는데 이 기능은 this가 instanceof Cat인 경우에만 실행하도록 if문을 추가했습니다.

그럼 이제 Cat으로 부터 생성된 오브젝트들만 한살먹기() 내부 기능을 사용가능합니다.




4. get/set을 이용해봅시다



자바스크립트로 간단한 게임 기능을 가진 오브젝트를 뽑는 class를 만들고 싶습니다.
다음 조건에 따라 class를 만들어보세요. class 이름은 Unit이라고 합시다.



(1) 모든 Unit의 인스턴스는 공격력, 체력 속성이 있으며 기본 공격력은 5, 기본 체력은 100으로 설정되어 있어야 합니다.

(2) 모든 Unit의 인스턴스는 전투력을 측정해주는 battlePoint라는 getter가 있습니다.

console.log( 인스턴스.battlePoint ) 이렇게 사용하면 현재 공격력과 체력을 더한 값을 콘솔창에 출력해주어야합니다.

(3) 모든 Unit의 인스턴스는 heal이라는 setter가 있습니다.

인스턴스.heal = 50 이렇게 사용하면 체력 속성이 50 증가해야합니다.





* 인스턴스는 class로부터 새로생성되는 오브젝트를 뜻합니다.



저는 이렇게 짰습니다



```
class Unit {
  constructor(){
    this.체력 = 100;
    this.공격력 = 5;
  }
  get battlePoint(){
    return this.체력 + this.공격력;
  }
  set heal(a){
    this.체력 = this.체력 + a;
  }
};

var 쎈애 = new Unit();

console.log(쎈애.battlePoint);
쎈애.heal = 50;

```



1. Unit이라는 class를 만들고 constructor에는 체력과 공격력을 기본으로 부여했습니다.

2. battlePoint()라는 함수를 만들고 이건 체력과 공격력을 합해서 출력하는 기능을 만들었습니다.

get을 붙여서 소괄호없이도 이용가능하게 만들었습니다.

3. heal() 이라는 함수를 만들었고 파라미터로 숫자를 입력하면 체력이 그만큼 증가합니다.

set을 붙여서 소괄호없이도 이용가능하게 만들었습니다.











5. get/set을 이용해봅시다2



다음과 같은 오브젝트가 있습니다.

```
var data = {
  odd : [],
  even : []
}
```

(1) data 오브젝트에는 setter 역할 함수가 하나 필요합니다.

setter 함수에 1,2,3,4 이렇게 아무 자연수나 파라미터로 입력하면 홀수는 odd, 짝수는 even 이라는 속성에 array 형태로 저장되어야합니다.   

(2) data 오브젝트에는 getter 역할 함수가 하나 필요합니다.

getter 함수를 사용하면 odd, even에 저장된 모든 데이터들이 숫자순으로 정렬되어 출력되어야합니다.





예를 들면

data.setter함수(1,2,3,4,5) 이렇게 입력하면

data = { odd : [1,3,5], even : [2,4] }

이렇게 저장이 되어야합니다.

빨리 위의 역할을 하는 함수 두개를 data 오브젝트 내에 만들어보십시오.



일단 1번은 어떻게 짰냐면


일단 setter 함수를 만들어봅시다.

이건 파라미터로 숫자들을 입력하면 숫자들을 분류해서 각각 odd, even 이라는 array에 저장해야합니다.

근데 파라미터로 몇개가 들어올지 모르기 때문에 rest 파라미터같은걸 쓰면 좋겠죠?


```
var data = {
  odd : [],
  even : [],
  setter함수 : function(...숫자들){
    console.log(숫자들)
  }
};

data.setter함수(1,2,3);
```

쩜쩜쩜이라는 rest 기호를 쓰시면 입력된 파라미터들을 전부 array로 싸매줍니다.

그 다음에 숫자들이라는 파라미터모음 array를 하나씩 출력해보며 분류하면 되겠죠?





숫자들[0]이 홀수면 odd에 push 해주고 짝수면 even에 push해주고

숫자들[1]이 홀수면.. 짝수면 ...

숫자들[2]가 홀수면.. 짝수면..



반복되는게 싫어서 반복문을 쓰면 뭐 이렇게 되겠죠?


```
var data = {
  odd : [],
  even : [],
  setter함수 : function(...숫자들){
    숫자들.forEach(function(a){
      a가 홀수면 this.odd에 push(a)하고..
      b가 짝수면 this.even에 push(a)하고...
    });
  }
};

data.setter함수(1,2,3);
```  

근데 홀수랑 짝수인걸 어떻게 구분합니까?

여러분이 수학을 잘하시면 알 수 있는데

그 숫자를 2로 나눠서 나머지를 보면 알 수 있습니다. 2로 나눠서 나머지가 0이면 짝수죠? 아니면 홀수고요.

자바스크립트는 나머지를 출력해주는 연산자도 친절하게 있습니다. % 기호를 쓰면 됩니다.

6 % 2 써보시면 이 자리에 0이 남습니다.

5 % 2 써보시면 이 자리에 1이 남고요.






```
var data = {
  odd : [],
  even : [],
  setter함수 : function(...숫자들){
    숫자들.forEach(function(a){
      if ( a % 2 == 1 ) {
        this.odd.push(a)  //홀수일때
      } else {
        this.even.push(a)  //짝수일때
      }
    });
  }
};

data.setter함수(1,2,3);
```

그래서 if문을 완성시켰습니다.

근데 제대로 작동되지 않습니다. 에러가 뜨죠?

왜냐면 this.odd.push 이부분이 에러가 나는 것 같습니다. 여기서 this.odd는 내 오브젝트의 odd속성을 뜻하는게 아니라

forEach안의 function(){} 안에서의 this는 약간 다른 뜻입니다.

근본없는 콜백함수에서 쓰시면 this가 window 이런 뜻이니까요.

그래서 this를 위해 함수 모양을 arrow function으로 바꿔주면






```
var data = {
  odd : [],
  even : [],
  setter함수 : function(...숫자들){
    숫자들.forEach((a)=>{
      if ( a % 2 == 1 ) {
        this.odd.push(a)  //홀수일때
      } else {
        this.even.push(a)  //짝수일때
      }
    });
  }
};

data.setter함수(1,2,3);
```

입니다.



set 키워드는 취향에 따라 알아서 추가해보시길 바랍니다.





2번은 어떻게 짰냐면


코드 넘 길어지니까 setter함수 빼고 getter함수만 좀 만들어봅시다.

array 두개를 합치려면 어떻게 합니까.

엣날에 배웠던 ES6 문법을 사용해보십시오.


```
var data = {
  odd : [1,3],
  even : [2,4,6],
  get getter함수(){
    return [...this.odd, ...this.even ].sort()
  }
};

console.log(data.getter함수);
```

... 기호로 spread operator 문법을 이용하시면 this.odd 그리고 this.even이라는 array 두개를 쉽게 합칠 수 있습니다.

그리고 그걸 출력해주는 getter함수를 만들었구염.



근데 출력하기 전에 정렬하고 싶으면 .sort()만 뒤에 붙이시면 됩니다.

그럼 문자정렬 해주는데 문자정렬이 아니라 숫자정렬을 잘 해주셔야하니

숫자정렬하는 법은 구글에 찾아서 한번 적용해보시길 바랍니다.


------ -->
