---
title: "[js] fiddler 사용 및 기타 과정"
layout: post
subtitle: JS
date: '2022-07-10-08:45:51 +0900'

categories: study
tags: JS

comments: true
---


- 서버 :  네트워크를 통해 클라이언트에 정보나 서비스를 제공하는 컴퓨터 또는 프로그램

    - 서버라고 해서 요청에 대한 응답만 하는 것은 아니다. 다른 서버에 요청을 보낼 수도 있다. 이때는 요청을 보낸 서버가 클라이언트 역할을 한다.
    
    - 서버는 클라이언트의 요청에 대해 응답. 응답으로 항상 Yes를 해야 하는 것은 아니고, No를 할 수도 있다. 어떤 사이트로부터 차단당했다면 그 사이트의 서버는 여러분의 요청에 매번 No를 응답

- 클라이언트: 요청을 보내는 주체로 브라우저일 수도 있고, 데스크톱 프로그램일 수도 있고, 모바일 앱일 수도 있고, 다른 서버에 요청을 보내는 서버


<br>

------

#### Node.js란

- Node.js란 
    - Node.jsⓇ는 Chrome V8 Javascript 엔진으로 빌드된 Javascript 런타임

- 자바스크립트 런타임
    - 런타임은 특정 언어로 프로그램 실행할 수 있는 환경
        - 노드는 자바스크립트 프로그램을 컴퓨터에서 실행가능
        - 즉, 자바스크립트 실행기라고 봐도 무방.
        - 자바스크립트를 전혀 모른다면 노드 사용이 불가



#### 이벤트 기반

- 이벤트 기반 : 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미. 이벤트로는 클릭이나 네트워크 요청 등

- 이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해두어야 함. 이를 이벤트 리스너(event listener)에 콜백(callback) 함수를 등록


- 이벤트 기반 모델에서는 이벤트 루프(event loop)라는 개념이 등장. 여러 이벤트가 동시에 발생했을 때 어떤 순서로 콜백 함수를 호출할지를 이벤트 루프가 판단

- 노드는 자바스크립트 코드의 맨 위부터 한 줄씩 실행. 함수 호출 부분을 발견했다면 호출한 함수를 호출 스택(call stack)에 넣음.

```
function first() {
  second();
  console.log('첫 번째');
}
function second() {
  third();
  console.log('두 번째');
}
function third() {
  console.log('세 번째');
}
first();
```

first 함수가 제일 먼저 호출되고, 그 안의 second 함수가 호출된 뒤, 마지막으로 third 함수가 호출. 실행은 호출된 순서와 반대로 실행이 완료


결과는

```
세 번째
두 번째
첫 번째
```

<br>

----

```
function run() {
  console.log('3초 후 실행');
}
console.log('시작');
setTimeout(run, 3000);
console.log('끝');
```

결과

```
시작
끝
3초 후 실행
```

콘솔 결과는 쉽게 예측할 수 있지만, 호출 스택으로 설명하기는 힘듬

위를 알기 위해선 이벤트 루프, 태스크 큐(task queue), 백그라운드(background)를 알아야 함.


이벤트 루프: 이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할을 담당. 노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복하므로 루프(loop)라고 부른다.

• 백그라운드: setTimeout 같은 타이머나 이벤트 리스너들이 대기하는 곳. 자바스크립트가 아닌 다른 언어로 작성된 프로그램이라고 봐도 됨. 여러 작업이 동시에 실행될 수 있다.

• 태스크 큐: 이벤트 발생 후, 백그라운드에서는 태스크 큐로 타이머나 이벤트 리스너의 콜백 함수를 보낸다. 정해진 순서대로 콜백들이 줄을 서 있으므로 콜백 큐라고도 부른다. 콜백들은 보통 완료된 순서대로 줄을 서 있지만 특정한 경우에는 순서가 바뀌기도 한다.

<br>

------

#### 논 블로킹 I/O

이벤트 루프를 잘 활용하면 오래 걸리는 작업을 효율적으로 처리할 수 있다. 작업에는 두 가지 종류가 있는데, 동시에 실행될 수 있는 작업과 동시에 실행될 수 없는 작업이 있다.


기본적으로 작성한 자바스크립트 코드는 동시에 실행될 수 없습니다. 

하지만 자바스크립트상에서 돌아가는 것이 아닌 I/O 작업 같은 것은 동시에 처리될 수 있다

I/O는 입력(Input)/출력(Output)을 의미한다. 

파일 시스템 접근(파일 읽기, 파일 쓰기, 폴더 만들기 등)이나 네트워크를 통한 요청 같은 작업이 I/O의 일종이다. 

이러한 작업을 할 때 노드는 논 블로킹 방식으로 처리하는 방법을 제공한다. 

논 블로킹이란 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행함을 뜻한다. 

반대로 블로킹은 이전 작업이 끝나야만 다음 작업을 수행하는 것을 의미.

![20221211_235043](https://user-images.githubusercontent.com/37941513/206910704-f3d5691c-e100-46ab-83df-c9f468ef5781.png)


블로킹 방식보다 논 블로킹 방식이 같은 작업을 더 짧은 시간에 처리할 수 있음을 알 수 있다. 다만 작업들이 모두 동시에 처리될 수 있는 작업이라는 전제가 있다.


<br>

----


작업 순서에 따라 성능이 크게 달라진다. 동시에 처리될 수 있는 I/O 작업이라도 논 블로킹 방식으로 코딩하지 않으면 의미가 퇴색되므로 논 블로킹 방식으로 코딩하는 습관을 들여야 한다.

##### 블로킹 방식 예제

```
function longRunningTask() {
  // 오래 걸리는 작업
  console.log('작업 끝');
}

console.log('시작');
longRunningTask();
console.log('다음 작업');
```

결과

```
시작
작업 끝
다음 작업
```
작업 완료 전 다음 작업 호출되지 않음

<br>

------

##### 논 블로킹 예제

```
function longRunningTask() {
  // 오래 걸리는 작업
  console.log('작업 끝');
}
console.log('시작');
setTimeout(longRunningTask, 0);
console.log('다음 작업');
```

결과

```
시작
다음 작업
작업 끝
```

setTimeout(콜백, 0)은 코드를 논 블로킹으로 만들기 위해 사용하는 기법 중 하나다. 사실 노드에서는 setTimeout(콜백, 0) 대신 다른 방식을 주로 사용하긴 하나 setTimeOut도 논 블로킹 중 하나.


이벤트 루프를 이해했다면, setTimeout의 콜백 함수인 longRunningTask가 태스크 큐로 보내지므로 순서대로 실행되지 않는다는 것을 알 수 있다. 다음 작업이 먼저 실행된 후, 오래 걸리는 작업이 완료된다.

아무리 논 블로킹 방식으로 코드를 작성하더라도 코드가 전부 작성한 것이라면 전체 소요 시간이 짧아지지는 않는다.  코드는 서로 동시에 실행되지 않기 때문입니다. 단순히 실행 순서만 바뀔 뿐이다.

위 예제에서는 console.log('다음 작업')과 longRunningTask 모두 작성한 코드입니다.


그렇다고 I/O 작업이 없다고 해서 논 블로킹이 의미가 없는 것은 아니다. 
 
오래 걸리는 작업을 처리해야 하는 경우, 논 블로킹을 통해 실행 순서를 바꿔줌으로써 그 작업 때문에 간단한 작업들이 대기하는 상황을 막을 수 있다는 점에서 의의가 있다.
 
 
또한, 논 블로킹과 동시가 같은 의미가 아니다. 동시성은 동시 처리가 가능한 작업을 논 블로킹 처리해야 얻을 수 있다.

    (참고)
     setTimeout(콜백, 0)

    밀리초를 0으로 설정했으므로 바로 실행되는 것으로 착각할 수 있다. 하지만 브라우저와 노드에서는 기본적인 지연 시간이 있으므로 바로 실행되지 않는다. HTML5 브라우저에서는 4ms, 노드에서는 1ms의 지연 시간이 있다.

노드에서는 동기와 블로킹이 유사하고 비동기와 논 블로킹이 유사하다고만 알아두면 된다.

