---
title: "[js] Javascript&ES6 "
layout: post
subtitle: JS
date: "2021-03-21-23:45:51 +0900"

categories: study
tags: JS
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---

.


여러분의 JavaScript 공부 고민 1. 어려운 용어 사용

책이나 구글 검색결과보면 너무나도 어려운 표현들이 기다리고 있습니다.

인스턴스, 1급객체, 생성자, 뭘 리턴하니뭐니

뭔소린지 이해도 안되는 말로 설명하고 있으니 공부해도 기억에 안남는 것입니다.

그래서 강의는 7살도 이해가능한 표현을 사용합니다.

쓸데없이 어려운 프로그래밍 용어는 설명할 때 사용하지 않습니다.

당연히 주요 프로그래밍 용어 정리는 해드립니다.

"이 생성자의 인스턴스를 뽑아서 객체의 프로토타입 상속기능을 구현하겠다 코딩허접들아"

이런 외계어로 강의 진행을 안한다는 소리입니다.

설명과정은 7살 수준 어휘력으로도 이해가능하도록 설명하겠습니다.

제 7살 조카도 제 설명 듣고 class, constructor, prototype 문법 이해했습니다.

여러분의 JavaScript 공부 고민 2. 알아보기 힘든 예제

역시 문법공부는 문법을 어떻게 쓰는지 알아야하기 때문에

예제를 찾아보기 마련인데 예제 조차 이해가 되지 않습니다.

책이든 구글이든 마찬가지입니다.

왜냐면 많이 배운 개발자일 수록 모듈화니 객체화니 뭐니 예제 어렵게 만드는 트레이닝을 많이 했기 때문입니다.

그래서 현 강의에선 foo bar myFunction 이런 의미없고 알아보기 힘든 변수명은 사용하지 않습니다.

그리고 중요한 변수명 함수명은 한글로 많이 표기할 예정입니다.

20년 전에 코딩배웠던 아조씨들이 변수 한글로 쓴다고 뭐라할 수 있는데 요즘 대부분의 언어들은 다국어 변수명 지원합니다.

그리고 예제들이 실제 코딩생활에서 찾아볼 수 있는 예제들로 준비했습니다.

내 코드에서 this가 제대로 나오지 않는 이유는?

왜 다음 예제에서 setTimeout 함수가 제대로 동작하지 않을까?

실제 맥락에 맞게 문법예제들을 학습하실 수 있어서 실제 코드 창작에도 도움이 확실히 될 것입니다.

코딩테스트 이런거 좋아하는 분들을 위해 그런 류의 연습문제들도 가끔 출몰합니다.

여러분의 JavaScript 공부 고민 3. 배워봤자 활용을 못하는 문법들

아마 공감되실 겁니다. 문법 배워봤자 뭐해요 실제로 코드짜야될 땐 전혀 쓰질 못하는데 말이에요.

이건 여러분 문제가 아니라 가르치는 사람 문제입니다.

가르치는 사람이 문법의 용도와 목적을 설명해주어야합니다.

class 문법 언제 쓰는지 아십니까.

그냥 간지를 위해 쓰는거라고요? ㄴㄴ 이것도 정확한 용도가 있습니다.

class문법이 존재하는 목적과 이유를 아셔야 내가 정확한 부분에서 정확히 class 문법으로 작성하게 되고

나중에 코드 작성시에도 class 문법을 활용할 수 있죠.

그래서 ES6와 객체지향 문법 사용법만 알려드리는게 아니라

신문법을 쓰는 이유와 용도를 많이 설명해드리려고 노력하고 있습니다.

그냥 대충 "class 문법은 이렇게 씁니다 ㅅㄱ" 시연만 해주면 저도 편하고 좋겠지만

하지만 이 강의의 목적은 여러분 혼자서도 ES6문법으로 코딩 잘하는 것이기 때문에

문법설명 전에 이 문법이 쓰이는 이유와 용도를 많이 알려드리고 있습니다.

여러분의 JavaScript 공부 고민 1. 어려운 용어 사용

책이나 구글 검색결과보면 너무나도 어려운 표현들이 기다리고 있습니다.

인스턴스, 1급객체, 생성자, 뭘 리턴하니뭐니

뭔소린지 이해도 안되는 말로 설명하고 있으니 공부해도 기억에 안남는 것입니다.

그래서 강의는 7살도 이해가능한 표현을 사용합니다.

쓸데없이 어려운 프로그래밍 용어는 설명할 때 사용하지 않습니다.

당연히 주요 프로그래밍 용어 정리는 해드립니다.

"이 생성자의 인스턴스를 뽑아서 객체의 프로토타입 상속기능을 구현하겠다 코딩허접들아"

이런 외계어로 강의 진행을 안한다는 소리입니다.

설명과정은 7살 수준 어휘력으로도 이해가능하도록 설명하겠습니다.

제 7살 조카도 제 설명 듣고 class, constructor, prototype 문법 이해했습니다.

여러분의 JavaScript 공부 고민 2. 알아보기 힘든 예제

역시 문법공부는 문법을 어떻게 쓰는지 알아야하기 때문에

예제를 찾아보기 마련인데 예제 조차 이해가 되지 않습니다.

책이든 구글이든 마찬가지입니다.

왜냐면 많이 배운 개발자일 수록 모듈화니 객체화니 뭐니 예제 어렵게 만드는 트레이닝을 많이 했기 때문입니다.

그래서 현 강의에선 foo bar myFunction 이런 의미없고 알아보기 힘든 변수명은 사용하지 않습니다.

그리고 중요한 변수명 함수명은 한글로 많이 표기할 예정입니다.

20년 전에 코딩배웠던 아조씨들이 변수 한글로 쓴다고 뭐라할 수 있는데 요즘 대부분의 언어들은 다국어 변수명 지원합니다.

그리고 예제들이 실제 코딩생활에서 찾아볼 수 있는 예제들로 준비했습니다.

내 코드에서 this가 제대로 나오지 않는 이유는?

왜 다음 예제에서 setTimeout 함수가 제대로 동작하지 않을까?

실제 맥락에 맞게 문법예제들을 학습하실 수 있어서 실제 코드 창작에도 도움이 확실히 될 것입니다.

코딩테스트 이런거 좋아하는 분들을 위해 그런 류의 연습문제들도 가끔 출몰합니다.

여러분의 JavaScript 공부 고민 3. 배워봤자 활용을 못하는 문법들

아마 공감되실 겁니다. 문법 배워봤자 뭐해요 실제로 코드짜야될 땐 전혀 쓰질 못하는데 말이에요.

이건 여러분 문제가 아니라 가르치는 사람 문제입니다.

가르치는 사람이 문법의 용도와 목적을 설명해주어야합니다.

class 문법 언제 쓰는지 아십니까.

그냥 간지를 위해 쓰는거라고요? ㄴㄴ 이것도 정확한 용도가 있습니다.

class문법이 존재하는 목적과 이유를 아셔야 내가 정확한 부분에서 정확히 class 문법으로 작성하게 되고

나중에 코드 작성시에도 class 문법을 활용할 수 있죠.

그래서 ES6와 객체지향 문법 사용법만 알려드리는게 아니라

신문법을 쓰는 이유와 용도를 많이 설명해드리려고 노력하고 있습니다.

그냥 대충 "class 문법은 이렇게 씁니다 ㅅㄱ" 시연만 해주면 저도 편하고 좋겠지만

하지만 이 강의의 목적은 여러분 혼자서도 ES6문법으로 코딩 잘하는 것이기 때문에

문법설명 전에 이 문법이 쓰이는 이유와 용도를 많이 알려드리고 있습니다.

---

![20210924_213923](/assets/20210924_213923.png)
![20210924_214819](/assets/20210924_214819.png)
![20210924_214848](/assets/20210924_214848.png)
![20210924_215158](/assets/20210924_215158.png)

함수나 변수를 전역공간에서 만들면 {window}에 보관합니다.

(global object = 전역변수 보관소)

#### this는 그냥 나를 가지고 있는 오브젝트를 출력해준다. 이렇게 알고 있으면 된다.

---

@

this 키워드를 알아보자

1. 함수와 Object에서 사용하면?

개발하면서 은근 자주 찾아볼 수 있는 this 키워드는 뜻이 매우 다양합니다.

사용하는 환경에 따라서 4개 이상의 각각 다른 뜻을 가지고 있습니다.

1-1. 그냥 쓰거나 함수 안에서 쓰면 this는 window를 뜻합니다.

그냥 HTML 파일 아무거나 하나 만들고 중간에 script 태그 열어서

일단 this라는 키워드를 콘솔창에 출력해보도록 합시다.

```
console.log(this)
```

그러면 this 키워드는 그냥 window {어쩌구} 이런 값이 나옵니다.

비슷하게 일반 함수 내에서 this라는 값을 불러보면

```
function 간지나는함수(){
 console.log(this)
}
간지나는함수();

```

똑같이 this라는 값은 window 라고 출력됩니다.

(함수 만들고 실행하는 문법은 다 아시죠? 모른다면 JS 기초 강의를 듣고 오도록 합시다. )

이것이 this의 첫째 뜻입니다. 그냥 window입니다.

Q. window가 뭔가요?

A. window는 모든 전역변수, 함수, DOM을 보관하고 관리하는 전역객체입니다.

라고 구글검색 번역투로 설명하면 솔직히 이해가 안되니 좀 쉽게 비유해보자면

님들이 쓰는 자바스크립트 함수들 있죠?

document.getElementById(), alert(), console.log()

이런 함수들을 보관하는 보관소입니다. 보관소는 특별한건 아니고 그냥 큰 {오브젝트}일 뿐입니다.

또한 여러분이 전역변수를 만들었을 때도 이 값을 보관해줍니다.

```
<script>
 var x = 300;
</script>
```

이렇게 변수를 큰 공간에 만드시면 x라는 변수는 window라는 큰 오브젝트안에 자동적으로 생성됩니다.

함수도 마찬가지고요.

아무튼 그냥 보관소입니다. 끝!

\*전역변수 : 코드 내 모든 곳에서 참조해서 쓸 수 있는 범용적인, 범위가 넓은 변수입니다. 그냥 script태그 내에 쌩으로 var 변수 하나 만들면 그건 자연스레 전역변수가 됩니다.

1-2. strict mode일 때 함수 안에서 쓰면 this는 undefined 입니다.

```
<script>
 'use strict';

 function 간지나는함수(){
   console.log(this)
 }
 간지나는함수();

</script>
```

IE 10버전 이상에선 'use strict'라는 키워드를 페이지 최상단에 추가하면

strict mode로 자바스크립트를 작성가능합니다.

strict mode에선 var 키워드 없이 변수를 선언하거나,

변수를 arguments라는 이상한 키워드로 선언하거나 그런 실수를 방지해줍니다.

strict mode에선 this 키워드를 일반함수 안에서 불렀을 때 undefined라는 값으로 강제로 지정해줍니다.

외울게 하나 더 생겼군요.

2. object 자료형 내에 함수들이 있을 수 있는데 거기서 this값은 '주인님'을 뜻합니다.

여러분 object 자료형에 함수같은거 집어넣을 수 있다는거 아셨습니까.

```
var 오브젝트1 = {
 data : 'Kim',
 간지함수 : function(){ console.log('간지') }
}

```

글자나 숫자 집어넣듯이 오브젝트 내에도 저렇게 함수를 집어넣을 수 있습니다.

그럼 함수를 어떻게 꺼내쓰냐면

```
var 오브젝트1 = {
 data : 'Kim',
 간지함수 : function(){ console.log('간지') }
}
```

오브젝트1.간지함수();
이렇게 쓰시면 됩니다. 그럼 콘솔창에 '간지'라는 글자가 출력되겠군요.

오브젝트에 들어가는 함수들을 있어보이는 전문용어로 메소드 method라고 칭합니다.

근데 메소드 안에서 this를 쓰면 신기한 값이 나옵니다. 바로 주인님이라는 값인데

```
var 오브젝트1 = {
 data : 'Kim',
 간지함수 : function(){ console.log(this) }
}

```

오브젝트1.간지함수();
간지라는 단어 대신 this라는 키워드를 출력시키면 어떻게되나요?

콘솔창에 { data : 'Kim', 간지함수 : f } 뭐 이런값이 출력되지않습니까?

이게 뭐냐면 그냥 여러분이 방금 만든 오브젝트1입니다.

그래서 메소드안에서 this를 쓰시면 this는 메소드를 가지고 있는 오브젝트를 뜻합니다.

쉽게 외우고싶다면 this는 '메소드의 주인님'을 지칭합니다.

그럼 밑의 예제의 this는 무슨 값이 출력될까요?

```
var 오브젝트2 = {
 data : {
   간지함수 : function(){ console.log(this) }
 }
}
오브젝트2.data.간지함수();
```

이런거 그대로 복붙해서 출력해보지말고 미리 생각을 해보시길 바랍니다.

그러면 머리에 잘 남습니다.

생각을 해보셨다면 직접 출력해보셔서 머릿속의 답과 비교해보시길 바랍니다.

답이 무엇이냐면

별거없고 오브젝트의 메소드안에서 썼을 때 this는 메소드를 담고있는 주인님을 뜻하기 때문에

간지함수()를 담고있는 주인님인 오브젝트2.data 라는게 위의 this랑 동일한 뜻입니다.

둘다 각각 출력해보시면 됩니다.

근데 놀라운 사실은 그냥 this라는 뜻은 2번만 아시면 됩니다.

1번, 즉 "일반 함수 내에서 썼을 때 this는 window입니다" 라는 정의는 굳이 외울 필요가 없습니다.

왜냐면 여러분이 2번 뜻을 잘 배우셨다면 1번도 자연스레 유추가 가능하니까요.

여러분이 함수나 변수를 대충 스크립트 태그 안에 만들었을 때, 함수나 변수는 그냥 만들어지는게 아닙니다.

```
<script>

 function 간지나는함수(){
   console.log()
 }

</script>
```

방금 만드신 간지나는함수()는 전역변수나 전역함수를 관리하기 위한 window라는 오브젝트에 자동으로 추가가 됩니다.

왜 그렇냐고요?

그건 자바스크립트 만든 사람에게 물어보시길 바랍니다.

그래서 코드(1) 코드(2) 둘다 자바스크립트 입장에서 보면 똑같단 이야기입니다.

```
<script>

 (1)
 function 간지나는함수(){
   console.log(this)
 }

 (2)
 window.간지나는함수 = function(){ console.log() };

</script>

```

(2)문법은 window라는 오브젝트에 함수 자료를 추가하는 문법일 뿐입니다. 어려운거 없습니다.

아무튼 결론은 전역함수 만들거나 전역변수 만드시면 저렇게 window {오브젝트} 안에 담긴다는 소리입니다.

우리가 일부러 하지 않아도 변수나 함수 쌩으로 만들면 자바스크립트가 자동으로 알아서 window안에 담습니다.

(변수 강의시간에 window 오브젝트에 대해 잠깐 더 알아볼 예정입니다)

그럼 이제 function 문법의 동작원리 하나를 알았으니 다시 한번 this를 여기서 출력해봅시다.

```
<script>

 function 간지나는함수(){
   console.log(this)
 }
</script>
```

여기서 this는 무슨 값이 나올까요?

this는 아까 2번에 의하면 내 메소드를 포함하고 있는 주인님 오브젝트를 출력시켜준댔죠?

간지나는함수()를 포함하고 있는 주인님 오브젝트가 무엇입니까?

여기서의 this는 무엇일까요

그래서 1번 : this를 함수안에서 썼을 땐 window가 나온다~ 라는건 안외우셔도 되고

2번 : this는 오브젝트 내의 메소드(함수)에서 사용했을 때 메소드의 주인님 오브젝트를 출력해준다~

요것만 외우시면 됩니다.

근데 난관이 있습니다. this의 얼탱이없는 3번 4번 뜻도 있기 때문입니다.

---

![20210924_220546](/assets/20210924_220546_4vvmglnpj.png)![20210924_221246](/assets/20210924_221246_fito75tjz.png)![20210924_220903](/assets/20210924_220903_9l69t0l9f.png)


e.currentTarget은 지금 이벤트가 동작하고 있는 곳을 말한다.

그리고 콜백함수란 함수 안에 함수를 집어넣는다. 이 함수를 콜백함수라 한다.

자스에선 콜백함수를 그냥 순차적으로 실행하고 싶을때 쓰면 된다라고 생각하자.

여기서 this를 쓰면 뭐가 나오나?


![20210924_221421](/assets/20210924_221421_hrvy7gwnh.png)

실행해보니까 window가 나왔다.


![20210924_235152](/assets/20210924_235152_3u84vhjih.png)

arrow 펑션의 특징은 내부의 this값을 변화시키지 않는다(외부 this값 그대로 사용이 가능하다).

저번 시간 this 의미 정리를 하자면

1. 그냥 일반 함수에서 쓰면 window

2. 오브젝트 내의 함수(메소드)에서 쓰면 함수를 동작시키는 오브젝트

가 출력된다고 배워봤습니다.

3. constructor 안에서 쓰면 constructor로 새로생성되는 오브젝트를 뜻합니다.

자바스크립트에서 오브젝트를 비슷한걸 여러개 만들고 싶을 경우

오브젝트를 복사하는게 아니라 constructor라는걸 만들어서 사용합니다.

쉽게 말하면 constructor는 오브젝트 복사해서 생성해주는 기계입니다.

기계를 어떻게 만드는지 알아봅시다.

```

function 기계(){
  this.이름 = 'Kim';
}

```

이게 기계 만드는 법입니다.

함수 문법을 이용해서 만드신 후, 안에 this. 어쩌구를 추가해주시면 됩니다.

여기서의 this는 기계로부터 새로 생성될 오브젝트들을 의미합니다.

그럼 this.이름 = 'Kim' 이건 무슨 뜻일까요?

새로생성되는 오브젝트의 이름 key값에 'Kim'이라는 value를 집어넣어주세요

라는 뜻 아닐까요?

맞습니다.

▼ 이건 참고로 알아두시면 좋은 기계에서 오브젝트 뽑는 법입니다.

```
function 기계(){
  this.이름 = 'Kim'
}

var 오브젝트 = new 기계();
```

이렇게 new 키워드를 이용하면 새로운 오브젝트를 꺼낼 수 있습니다.

그리고 새로운 오브젝트는 {이름 : 'Kim'} 이라는 값을 가지고 있습니다. (this 라는 키워드 덕분에요)

4. eventlistener 안에서 쓰면 this는 e.currentTarget이라는 의미입니다.

이벤트리스너라는 문법 아시쥬?

```
document.getElementById('버튼').addEventListener('click', function(e){
  console.log(this)
});

```

여기서 this를 소환하면 이것은 바로 e.currentTarget이라는 뜻과 똑같은 의미입니다.

e.currentTarget은 지금 이벤트가 동작하는 곳을 뜻합니다.

매우 간단히 설명하면 지금 addEventListener 부착된 HTML 요소를 뜻한다고 보시면 됩니다.

의심되면 e.currentTarget, this, document.getElementById('버튼') 이거 세개를 각각 출력해보시면 됩니다.

이게 this의 마지막 뜻입니다.

case 1. 이벤트리스너 안에서 콜백함수를 쓴다면 this는?

이런 코드를 쓴다고 가정해봅시다.

```
document.getElementById('버튼').addEventListener('click', function(e){
  var 어레이 = [1,2,3];
  어레이.forEach(function(){
    console.log(this)
  });
});

```

이벤트리스너 안에서 forEach() 라는 반복문을 사용했습니다.

forEach() 반복문을 사용할 땐 안에 function(){} 콜백함수를 집어넣어서 사용하게 되어있습니다. 그래서 넣었습니다.

(\* 콜백함수는 그냥 함수 안에 파라미터역할로 들어가는 함수를 뜻합니다. 그게 다임)

하지만 솔직히 forEach가 무슨 역할을 하는지는 모르셔도 이건 알 수 있습니다.

Q. 위의 코드에서 this를 출력하면 무엇이 나올까요?

뭐가 나오냐면

```

생각이 안나시면 지금까지 배웠던 this의 1,2,3,4번 뜻을 각각 대입해보세요.

그럼 뭡니까.



4번뜻에 의하면.. eventlistener 안에서 쓴 건 아닙니다.

eventlistener내부는 맞지만 그 안에서 function을 하나 더 만났기 때문에 의미가 변합니다.

3번뜻에 의하면.. constructor는 아닌 것 같습니다.

실은 this의 1번이나 2번뜻이 맞습니다.

저렇게 쌩으로 있는 콜백함수는 그냥 일반함수랑 똑같기 때문에 window가 출력됩니다.



this의 값은 this가 어떤 함수안에 들어있는지만 잘 체크하시면 바로 아실 수 있습니다.


```

case 2. 오브젝트 안에서 콜백함수를 쓴다면 this는?

이번엔 이런 코드를 쓴다고 가정해봅시다.

```

var 오브젝트 = {
  이름들 : ['김', '이', '박'];
  함수 : function(){
      오브젝트.이름들.forEach(function(){
        console.log(this)
      });
  }
}

```

오브젝트라는 오브젝트 안에 이름들, 함수라는 자료를 각각 저장했습니다 .

함수라는 자료 안에 forEach 반복문을 돌렸는데,

Q .그럼 여기 안에서의 this값을 출력하면 뭐가나올까요?

뭐가 나오냐면

```
역시 잘 대입을 해보시면 되겠습니다.

this값을 판단하실 땐 가장 가까이 있는 함수를 살펴보시면 됩니다.



forEach() 안에 있는 함수에 this가 들어있죠?

근데 이 함수는 무슨 뭐 특별한 역할을 하는 함수인가요?

아닙니다. 그냥 일반 함수일 뿐입니다.

그래서 이것도 window입니다.

```

그래서 this값은 function을 만날 때마다 바뀔 수 있기 때문에

내가 원하는 this를 쓰기 힘든 경우가 있습니다.

그럴 땐 함수를 arrow function으로 바꿔보시길 바랍니다.

```
var 오브젝트 = {
  이름들 : ['김', '이', '박'];
  함수 : function(){
      오브젝트.이름들.forEach(() => {
        console.log(this)
      });
  }
}

```

자바스크립트 ES6 문법 중,

function () {} 대신 쓸 수 있는 () => {} 이라는 arrow function 문법이 있습니다.

똑같이 함수 만드는 문법입니다.

이걸 쓰시면 함수 내부의 this값을 새로 바꿔주지 않기 때문에 this를 사용하실 때 유용합니다.

심심하면 사용하시길 바랍니다. (아니면 애초에 this 키워드를 쓰지맙시다)

---

연습문제

this & arrow function 연습문제 3개

1. 간단한 메소드 만들기

사람이라는 오브젝트가 하나 있습니다.

이 오브젝트에 sayHi라는 함수를 (메소드를) 하나 추가하고 싶습니다.

var 사람 = {
name: '손흥민',
}

사람.sayHi(); //안녕 나는 손흥민

위의 코드처럼 사람.sayHi()라고 작성하면 콘솔창에 '안녕 나는 손흥민' 이라는 글자가 나와야합니다.

'손흥민'이라고 이름을 하드코딩해서 출력하기보다는 실제 내 오브젝트에 있는 name에 해당하는 값이 출력되면 참 좋을 것 같군요.

Q. sayHi()라는 함수를 어디서 어떻게 만들면 될까요?

A.

```
<script>
var 사람 = {
  name: '손흥민',
  sayHi : function(){
    console.log('안녕 나는 ' + this.name)
  }
}

사람.sayHi(); //안녕 나는 손흥민
</script>


```

2. 오브젝트 내의 데이터를 전부 더해주는 메소드만들기

오브젝트가 하나 있습니다.

var 자료 = {
data : [1,2,3,4,5]
}
그런데 이 오브젝트에 전부더하기() 라는 함수를 하나 만들어서 사용하고 싶습니다.

var 자료 = {
data : [1,2,3,4,5]
}
자료.전부더하기();
위처럼 자료.전부더하기()라고 쓰면 자료.data 안에 있는 모든 숫자를 더해서 콘솔창에 출력해주어야합니다.

(아마 15가 뜨게 되겠죠?)

Q. 어떻게 코드를 짜면 될까요?

조건) 위에있는 자료라는 object 중괄호 {} 내에 코드 작성 금지

A.

```


var 자료 = {
  data : [1,2,3,4,5]
};

자료.전부더하기 = function(){
  var 합 = 0;
  this.data.forEach(function(a){
    합 = 합 + a;
  });
  console.log(합);
}
자료.전부더하기();

```

3. setTimeout 이용해보기

자바스크립트엔 setTimeout이라는 유용한 함수가 있습니다.

특정 코드나 함수를 X초 후에 실행하고 싶을 때 사용하는 함수입니다.

어떻게 쓰냐면

setTimeout(콜백함수, ms단위의 시간)
이렇게 쓰면 됩니다.

예를 들어보면

setTimeout(function(){ console.log('안녕') }, 1000)
이렇게 한줄 쓰시면 1000ms 후에 왼쪽에 있는 콜백함수 내의 코드를 실행해줍니다.

그럼 1초후에 안녕이 콘솔창에 출력되겠네요.

또는 콜백함수자리에 여러분이 직접 만든 함수를 넣을 수도 있습니다.

역시 예를 들어보면

function 함수(){
console.log('안녕')
}

setTimeout(함수, 1000)
이렇게 콜백함수 대신 내가 미리 만들어놓은 함수의 이름을 적어도 실행됩니다.

다만 콜백함수자리에 내가만들어놓은 함수를 입력하고 싶으면 소괄호는 빼셔야합니다.

setTimeout 개념정리 끝입니다.

본격 문제들어갑니다.

버튼을 클릭하면 지금 누른 버튼에 담긴 글자를 출력하는 기능을 만들고 싶어서 이렇게 코드를 짰습니다.

```
<button id="버튼">버튼이에요</button>

<script>

  document.getElementById('버튼').addEventListener('click', function(){
    console.log(this.innerHTML)
  });

</script>

```

그럼 콘솔창에 '버튼이에요'라는 글자가 출력되죠? 잘 되는군요.

Q. 그럼 setTimeout을 이용해서 1초 후에 this.innerHTML을 콘솔창에 출력하고 싶으면 어떻게 코드를 수정해야할까요?

1초 후에 '버튼이에요'라는 글자가 콘솔창에 등장하면 성공입니다.

A.

```

button id="버튼">버튼이에요</button>


<script>

  document.getElementById('버튼').addEventListener('click', function(){
    this.innerHTML
    setTimeout(()=>{ console.log(this.innerHTML) }, 1000);  //이 this를 바로 위 줄 this와 같게 만들어야한다.(그러려면 arrow함수 이용해야) 아래와 같이 화살표함수로 바꾸면 된다.
  });

</script>


<script>

  document.getElementById('버튼').addEventListener('click', function(){
    setTimeout(()=>{ console.log(this.innerHTML) }, 1000);
  });

</script>


```

ES5때처럼 옛날스타일로는 이렇게 가능하다(화살표 함수가 없던 시절은 변수에 저장하고 사용했다.)

```
<button id="버튼">버튼이에요</button>

<script>

  document.getElementById('버튼').addEventListener('click', function(){
    var 버튼 = this;
    setTimeout(function(){ console.log(버튼.innerHTML) }, 1000);
  });

</script>



```

---

자바스크립트 변수는 이렇게 씁니다.



var 이름 = 'Kim';
변수는 자료를 임시로 저장하는 공간입니다.

1. var이라는 키워드 오른쪽에 작명을 하시고, 변수에 저장할 자료를 등호로 집어넣어주시면 됩니다.

2. 오브젝트, 어레이, 함수 등 모든 자료들을 담을 수 있습니다.

3. 그리고 var 이름이라는 부분은 선언, 이름 = Kim 이라는 부분은 값 할당이라고 전문 용어로 표현합니다. 보통 변수만들 땐 두개를 동시에 사용합니다.

4. 그리고 변수를 만들 땐 var, let, const라는 3개 키워드를 이용가능합니다.

3개 키워드마다 특징이 있습니다. 변수의 선언, 할당, 범위에서 차이가 좀 있는데 같이 알아보도록 합시다.  







변수의 선언


```
var 이름;
let 나이;
const 성별;
```

이렇게 var, let, const 키워드를 이용해 변수를 만들겠다고 선언할 수 있습니다. (등호는 안써도 변수는 만들어집니다)

그런데 var 키워드는 재선언이 가능하고

let, const 키워드는 재선언이 불가능합니다.

 ```

let 나이;
let 나이; //에러

const 성별 = '여자';
const 성별 = '남자'; //에러

```


let, const로 만들면 이렇게 같은 이름의 변수를 두번 이상 재선언할 수 없습니다. 에러가 납니다.

나중에 변수 이름을 실수로 중복해서 만드는 실수를 방지해주는 고마운 기능입니다.









변수의 값 할당



변수에 값을 할당한다는게 뭔소리냐면

```
var 이름;
이름 = 'Kim';
```
▲ 둘째줄에서 이렇게 만들어놓은 변수에 'Kim' 이라는 값을 집어넣는걸 할당이라고 합니다.





할당도 선언과 동시에 할 수 있고요.
```
var 이름 = 'Kim';
```
▲ 선언과 할당을 동시에 하는 멋진 모습입니다.







근데 변수를 var, let으로 만들면 재할당이 가능하고 const로 만들면 값 재할당이 불가능합니다.

const로 변수 만들면 나중에 등호를 이용해 값 변경하는게 안된다는 소리입니다.
```
let 이름 = 'Kim';
이름 = 'Park';  //가능

const 나이 = 30;
나이 = 40; //에러
```
const는 애초에 constant의 약자로 바뀌지 않는 일정한 값을 뜻합니다.

바뀌면 큰일날 값을 저장하고 싶을 때 사용하면 좋습니다.







* const 변수에 오브젝트를 담으면 오브젝트 내의 데이터는 변경 가능합니다.
```
const 오브젝트 = { 이름 : 'Kim' }
오브젝트.이름 = 'Park'; //가능
```
위의 예제는 엄밀히 말하면 변수를 재할당한게 아니기 때문에 가능합니다.

완전 변경불가능한 오브젝트를 만들고 싶다면

Object.freeze()라는 자바스크립트 기본함수가 있습니다.

Object.freeze() 소괄호에 오브젝트를 담으시면 불변의 Object가 완성됩니다.

(하지만 오브젝트 내의 오브젝트까지 freeze해주진 않습니다)











변수의 범위



변수를 만들면 존재범위가 있습니다.

var 변수는 존재범위가 function입니다.

let, const 변수는 존재범위가 거의 모든 {중괄호} 입니다. (for, if, function 등)




```
function 함수(){
  var 이름 = 'Kim';
  console.log(이름); //가능
}
```
console.log(이름); //에러
▲ 위의 예제처럼 var 변수는 function 내에서 만들면 function 내에서만 쓸 수 있습니다.

function 바깥에서 부르면 없다고 나옵니다.





if ( 1 == 1 ){
  let 이름 = 'Kim';
  console.log(이름); //가능
}

console.log(이름); //에러
▲ 위의 예제처럼 let 변수는 {} 중괄호 내에서 만들면 중괄호 내에서만 쓸 수 있습니다.

중괄호 바깥에서 부르면 없다고 나옵니다.


-------

![20210925_035115](/assets/20210925_035115.png)

자바스크립트만의 문법 호이스팅


변수뿐 아니라 함수 만들떄도 호이스팅이 일어난다.




---------




저번시간까진 선언, 할당, 범위라는 기초 필수 개념을 정리했는데

이번엔 변수의 부가 개념들을 정리해보도록 합시다.







자바스크립트 변수, 함수의 Hoisting 현상



자바스크립트는 변수나 함수를 선언하면 Hoisting이라는 현상이 일어납니다.

자바스크립트는 변수나 함수의 선언부분을 변수의 범위 맨 위로 강제로 끌고가서 가장 먼저 해석합니다.

그게 Hoisting입니다.





예를 들어봅시다.  

function 함수(){

  console.log('hello');
  var 이름 = 'Kim';

}
이렇게 함수 내에서 변수를 만들었다고 칩시다.

근데 자바스크립트가 이 코드를 해석하는 순서는 이렇게 됩니다.



function 함수(){

  var 이름;
  console.log('hello');
  이름 = 'Kim';

}
변수의 선언 부분을 강제로 변수의 범위 맨 위로 끌고가서 해석하고 지나갑니다.

우리 눈에 보이진 않지만 자바스크립트는 코드 동작 순서가 이렇습니다.

암튼 이게 Hoisting 현상입니다.

함수를 만들어도 똑같고, 변수를 let, const로 만들어도 똑같습니다.







그럼 이 코드는 실행결과가 어떻게될까요?

<script>

  console.log(이름);
  var 이름 = 'Kim';
  console.log(이름);

</script>
뭘까요


A.
콘솔창에 첫째로는 undefined가 출력되고

둘째로는 Kim이 출력됩니다.

왜냐면 Hoisting 때문에
```
var 이름;
console.log(이름);
이름 = 'Kim'
console.log(이름);
```
이런 순서로 코드가 실행되니까요.



undefined라는건 변수가 선언은 되었는데 값을 아무것도 할당하지 않았을 때 undefined가 출력됩니다.

일종의 자료형같은 것인데 그냥 정해지지않은 값이라고 생각하면 됩니다.

하지만 let, const 변수의 경우 Hoisting이 일어나긴 하는데 약간 이상한 방식으로 일어납니다.

그건 연습문제 강의에서 발견하실 수 있습니다.









변수 여러개 편리하게 만들기



변수를 콤마로 구분하시면 여러개를 동시에 만들 수 있습니다.

var 이름, 나이, 성별;
이렇게 하면 변수가 3개 생성됩니다. var 키워드 3번 쓰지않아도 되니 코드가 약간 더 줄어드네요.





var 이름 = 'Kim', 나이, 성별;
선언과 동시에 할당도 하고 싶으면 그냥 이렇게 하시면 됩니다.

그냥 var let const 키워드를 여러번 안써도 된다는 장점이 있습니다.





var 이름,
    나이,
    성별;
어떤 놈들은 이렇게도 씁니다.











전역변수와 변수의 참조



변수는 이런 특징이 있습니다.

바깥에 있는 변수는 안쪽에서 자유롭게 사용가능합니다.

이걸 전문 개발자용어로 참조가능하다 라고 합니다만 자바스크립트에서는 이 현상을 부르는 다른 말이 있습니다.

closure라고 합니다.

안쪽 바깥쪽이 뭔지 예를 들자면


```
var 나이 = 20;

function 함수(){
  console.log(나이)
}

```

함수();
지금 함수(){} 안쪽에서 바깥쪽에 있는 나이라는 변수를 가져다 쓸 수 있다는 것입니다.

함수(){} 안쪽에 나이라는 변수 정의가 있으면 그걸 쓰겠지만

없으면 자연스럽게 바깥에 있는 변수를 가져다 씁니다. (참조합니다)







프로그래밍에선 전역변수라는게 있습니다.

모든 함수나 if나 for 내부에서 공통적으로 사용할 수 있는 (참조할 수 있는) 유용한 변수를 뜻합니다.

전역변수를 만들어 쓰고싶으면 그냥 script태그 열고 다짜고짜 변수하나 만들어주시면 됩니다.


```
<script>
  var 나이 = 20;

  function 함수(){
    console.log(나이)
  }
```
</script>
그럼 밑에 나오는 모든 함수, for, if 등에서 전부 나이라는 변수를 사용가능합니다.

전역변수 완성!

근데 전역변수는 이상한 특징이 있습니다.







예전에 window라는 오브젝트가 있다고 배웠었습니다.

window는 자바스크립트 기본함수 보관하는 큰 오브젝트라고 배웠습니다.

alert, getElementById, console.log 이런 함수들이 다 들어있습니다.



진짠지 테스트해보시려면

자바스크립트 기본 함수들을 오브젝트 다룰 때 처럼 window.alert(), window.document.getElementById() 이렇게 사용해보십시오.

alert이런것도 window에 보관된 애들이기 때문에 window.alert('안녕') 이렇게 하셔도 잘 됩니다.

이게 window 오브젝트의 역할입니다. 끝!







근데 여러분이 쌩으로 전역변수를 만들면 window에도 보관이 됩니다. (let말고 var 키워드만요)

왜그런지 궁금하면 역시 자바스크립트 만든 사람에게 물어보길 바랍니다.
```
<script>
  var 나이 = 20;

  console.log(나이);
  console.log(window.나이);
</script>

```
나이라는 전역변수를 만들면

자동으로 window 오브젝트에 보관이 되었으니까

신기하게 window.나이를 써도 출력이 됩니다.

(전역함수도 마찬가지로 window에 자동으로 보관됩니다)





그래서 전역변수를 조금 더 엄격하게 관리하거나 구분짓고 싶으면

전역변수를 만들 때와 사용할 때 window를 활용해보십시오.


```
<script>
  window.나이 = 20;  //전역변수만들기
  console.log(window.나이);  //전역변수사용하기
  window.나이 = 30;  //전역변수변경하기
</script>

```
이런 식으로 사용할 수도 있습니다.

프로그래밍 엄격히하는걸 좋아하는 변태아조씨들이 많이 이용합니다.

(node.js 환경에선 window 대체품인 global 이라는 오브젝트가 있습니다)













간단한 연습문제



다음 코드를 실행하면 콘솔창에 무엇이 뜰까요?
```
<script>

  if (true) {
    let a = 1;
    var b = 2;
    if (true) {
      let b = 3;
    }
    console.log(b);
  }

</script>
```
답 펼쳐보기 전에 잘 생각해보도록 합시다. 함정이 있을 수 있음
실은 함정없음

b는 2라는 값이 출력됩니다.

let b = 3; 이 부분은 안쪽 if 내에서만 존재하는 놈이니 바깥의 console.log(b)와는 무관합니다.



-------


###### 변수 연습문제


1~4. 다음 코드의 콘솔창 출력결과는 무엇일까요?



(문제1)

```
함수();
function 함수() {
  console.log(안녕);
  let 안녕 = 'Hello!';
}
```

답은요

A.

![20210925_130441](/assets/20210925_130441.png)


undefined라고 생각하신 분은 훌륭하신 분들입니다. 강의에서 그렇게 배웠으니까요.

하지만 답은 에러입니다.

함수는 잘 실행됩니다.

하지만 함수내부 코드가 이상합니다.

let 변수는 특이하게도 Hoisting이 되긴 하지만 undefined라는 값이 할당되지 않습니다.

그래서 출력시 에러를 뿜습니다.



let 변수는 hoisting 되지만 var 변수처럼 지동으로 undefined 라는 값을 할당(일명 initialization) 해주지 않습니다.

선언과 할당 사이에 시간차가 있기 때문에 그런 현상이 일어나는 것이고 let 변수는 그래서 쓸 수 없습니다

그래서 그냥 let const 변수는 그래서 엄격하게 쓸 수 있는 변수구나 외우시면 되겠습니다. 끝



(문제2)

함수();
var 함수 = function() {
  console.log(안녕);
  var 안녕 = 'Hello!';
}
답은요

A.


![20210925_130826](/assets/20210925_130826.png)
이번에도 답은 에러입니다.

정확히 말하면 함수가 아닌데요? 라는 에러입니다.

지금 둘째줄에 있는 함수 선언부분을 잘 보시면 function 키워드 대신 변수만드는 것 처럼 함수를 선언과 할당하고 있습니다.

역시 이렇게 함수를 만드셔도 Hoisting이 되는데, 근데 Hoisting은 변수의 선언부분만 된다고 했었습니다.

그래서 변수 선언부분만 맨 위로 끌어올려지는데

그 변수에다가 소괄호를 붙여봤자 아직 함수가 아니기 때문에 실행이 되지 않습니다. (에러가 납니다. 함수가 아닌 변수에다가 소괄호 붙이면 함수 아니라고 에러를 뿜어줍니다.)



(문제3)

let a = 1;
var 함수 = function() {
  a = 2;
}
console.log(a);
답은요

A.

![20210925_131133](/assets/20210925_131133.png)

a는 1이 출력됩니다.

a는 1이라는 변수를 만들고

그 다음에 함수를 만들고 함수 안에서 a = 2라고 값을 변경시켰는데

함수를 정의만 했지 실행을 안시켜서 a = 2라는 부분은 없는 코드나 마찬가지입니다.

그래서 a 는 그냥 1입니다.



(문제4)

let a = 1;
var b = 2;
window.a = 3;
window.b = 4;

console.log(a + b);
답은요

A.

![20210925_131219](/assets/20210925_131219.png)

a는 1, b는 4가 출력됩니다.

b가 4가 되는 이유는 var b = 2 이것과 window.b = 4 이건 거의 동일한 기능을 하는 코드기 때문에

b는 그냥 4로 재할당이 되었다고 보시면 되겠습니다.

a는 let 변수로 1을 할당하고 글로벌 변수로 3을 할당했습니다.

이 경우 우리가 a를 사용했을 때 조금 더 범위가 작고 가까운 1을 참조해서 사용합니다.

(자바스크립트 변수를 사용할 때 참조할만한 변수가 내 주변에 없으면 계속 상위 중괄호로 시선을 돌리면서 참조합니다.)



5. 콘솔창에 1초에 한번씩 1부터 5까지의 정수를 출력해주고 싶습니다.


![20210925_131332](/assets/20210925_131332.png)

저번 연습문제에서 setTimeout이라는 유용한 함수를 배운 것 같습니다.

그래서 코드를 이렇게 작성했습니다.


```
setTimeout(function() { console.log(1); }, 1000 );
setTimeout(function() { console.log(2); }, 2000 );
setTimeout(function() { console.log(3); }, 3000 );
setTimeout(function() { console.log(4); }, 4000 );
setTimeout(function() { console.log(5); }, 5000 );

```

그럼 1초마다 1~5까지의 숫자를 콘솔창에 출력해줍니다.

하지만 반복되는 코드가 보기 싫어서 반복문 안에 담았습니다.






```
for (var i = 0; i < 5; i++) {
  setTimeout(function() { console.log(i); }, i*1000 );
}
```

논리적으로 완벽한 for 반복문입니다.

그런데 반복문으로 축약하자마자 제대로 작동하지 않습니다.

계속 5라는 숫자가 1초마다 출력되네요.



Q. 위 코드는 왜 의도대로 동작하지 않는 것이죠? 해결할 방법은 무엇일까요?

답은요

A.




자바스크립트 입장에서 하단 코드를 해석해보겠습니다.

```
for (var i = 0; i < 5; i++) {
  setTimeout(function() { console.log(i); }, i*1000 );
}
```


자바스크립트는 일단 반복문을 만나면 반복문 내의 코드를 반복해서 실행합니다.

지금 반복문이 i가 0부터 5가 되기 전까지 반복해주세요~라고 써놓았으니 총 5번 반복이 되겠네요.

근데 내부 코드는 setTimeout 어쩌구 입니다. X초후에 콜백함수 내의 console.log(i)를 실행해주세요~ 라는 코드입니다.

그래서 그 부분은 반복문과 동시에 실행되지 않습니다. 좀 나중에 실행되겠죠 뭐.

반복문 끝입니다.





반복문을 해석한 후.. 1초가 지나면 setTimeout 내의 console.log(i)가 발동됩니다.

근데 i를 채워넣고싶어서 주변을 살펴보았더니 i값은 3밖에 없는 것입니다.

왜냐면 아까 반복문이 5번 실행되면서 i값은 0,1,2,3 ... 이렇게 차례로 변하다가 i값이 5가 되어 종료했습니다.

그리고 i 값은 var로 만든 전역변수입니다.

그래서 i값을 쓰려고 봤더니 전역변수 i = 5밖에 없어서 5를 집어넣어서 계속 실행해서 콘솔창에 5가 계속 출력되던 것입니다.







해결책은 for 반복문에서 i변수를 만들 때 var 대신 let으로 바꾸는 것입니다.

let 변수는 범위가 중괄호랬죠? for반복문도 중괄호에 해당됩니다.

그럼 이제 1초 후 console.log(i)가 실행될 때 i값을 채우려고 살펴보면

i값이 for 반복문 내에 남아있기 때문에 그걸 가져다 쓰게 됩니다.

그래서 아까처럼 계속 5를 출력해주는게 아니라 1,2,3,4,5를 출력해줍니다.

(위의 예제는 0,1,2,3,4가 출력되겠군요 이런)



6. 버튼을 누르면 모달창을 띄우고 싶습니다.



버튼(button)과 모달창(div)가 3개 있습니다.


```
<div style="display : none">모달창0</div>
<div style="display : none">모달창1</div>
<div style="display : none">모달창2</div>

<button>버튼0</button>
<button>버튼1</button>
<button>버튼2</button>

<script>
  //?
</script>
```

지금 display : none 덕분에 모달창이 아무것도 안보이는 상태입니다.

자바스크립트를 잘 짜서

0번째 버튼을 누르면 0번째 모달창,

1번째 버튼을 누르면 1번째 모달창을 보여주고 싶습니다.

그럼 코드를 어떻게 짜면 될까요?







여기까진 기본 자바스크립트 내용이니 친절히 알려드리겠습니다.


```
<div style="display : none">모달창0</div>
<div style="display : none">모달창1</div>
<div style="display : none">모달창2</div>

<button>버튼0</button>
<button>버튼1</button>
<button>버튼2</button>

<script>
var 버튼들 = document.querySelectorAll('button');
var 모달창들 = document.querySelectorAll('div');

버튼들[0].addEventListener('click', function(){
  모달창들[0].style.display = 'block';
});

버튼들[1].addEventListener('click', function(){
  모달창들[1].style.display = 'block';
});

버튼들[2].addEventListener('click', function(){
  모달창들[2].style.display = 'block';
});

</script>
```

document.querySelectorAll은 jQuery의 $('') 셀렉터와 매우 유사합니다. 동시에 여러 요소를 찾아 어레이 비슷한 자료형에 담아줍니다.

아무튼 이렇게 쭉 쓰면

0번째 버튼을 누르면 0번째 모달창,

1번째 버튼을 누르면 1번째 모달창을 보여줍니다.

그런데 비슷한 코드들이 좀 보이죠? 이걸 반복문 안에 담아서 한번 다시 개발해보겠습니다.





두근두근

```
<script>
var 버튼들 = document.querySelectorAll('button');
var 모달창들 = document.querySelectorAll('div');

for (var i = 0; i < 3; i++){

  버튼들[i].addEventListener('click', function(){
    모달창들[i].style.display = 'block';
  });

}

</script>
```


이렇게 반복문으로 반복적인 코드를 축약가능합니다.

그런데 문법에 맞게 쓰긴 했는데 모달창이 제대로 작동하지않고 있습니다.

Q. 위 코드는 왜 의도대로 동작하지 않는 것이죠? 해결할 방법은 무엇일까요?



답은요

A.

![20210925_131836](/assets/20210925_131836.png)


방금 전 문제랑 거의 똑같은 경우의 문제입니다.

자바스크립트 입장에서 하단 코드를 해석해보겠습니다.

```
for (var i = 0; i < 3; i++){

  버튼들[i].addEventListener('click', function(){
    모달창들[i].style.display = 'block';
  });

}
```

자바스크립트는 일단 반복문을 만나면 반복문 내의 코드를 반복해서 실행합니다.

지금 반복문이 i가 0부터 3이 되기 전까지 반복해주세요~라고 써놓았으니 총 3번 반복이 되겠네요.

근데 내부 코드는 addEventListener 어쩌구 입니다. 클릭 되면 콜백함수 내의 모달창들[i].style.display = 'block'; 을 실행해주세요~ 라는 코드입니다.

그래서 그 부분은 반복문과 동시에 실행되지 않습니다. 좀 나중에 클릭 되면 실행되겠죠 뭐.

반복문 끝입니다.


반복문을 해석한 후..  누군가 버튼을 클릭하면 addEventListener 내의 모달창들[i].style.display = 'block'; 코드가 발동됩니다.

근데 i를 쓰고싶어서 주변을 살펴보았더니 i값은 3밖에 없는 것입니다.

왜냐면 아까 반복문이 3번 실행되면서 i값은 0,1,2,3 ... 이렇게 차례로 변하다가 i값이 3이 되어 종료했습니다.

그리고 i 값은 var로 만든 전역변수입니다.

그래서 i값을 쓰려고 봤더니 전역변수 i = 3밖에 없어서 3을 집어넣어서 계속 에러가 났던 것입니다.

![20210925_131805](/assets/20210925_131805.png)
해결책은 for 반복문에서 i변수를 만들 때 var 대신 let으로 바꾸는 것입니다.

let 변수는 범위가 중괄호랬죠? for반복문도 중괄호에 해당됩니다.

반복문이 돌고 나서도 let i = 어쩌구 값이 {for 반복문} 내에 남아있기 때문에 그걸 모달창들[i].style.display = 'block'; 의 i값으로 가져다 쓰게 됩니다.

그럼 이제 의도된 i값으로 코드가 잘 실행됩니다.
