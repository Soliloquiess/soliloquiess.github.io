---
title: "[js] Node js & MongoDB part3"
layout: post
subtitle: JS
date: "2021-09-12-23:45:51 +0900"

categories: study
tags: JS
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---




edit.ejs 페이지를 만들어보도록 합시다.  



수정기능을 구현할 수 있는 방법은 여러가지인데, 가장 쉬운 방법이 바로 edit 페이지를 따로 만드는 것입니다.

뭐 다르게 하시려면 write 페이지를 그대로 쓰는데 전송시 'post'가 아니라 '수정'요청으로 바꾸는 경우도 있을 수 있겠군요.

우리는 그냥 구분이 쉽게 edit.ejs 페이지를 만들어보도록 합시다.



(views/edit.ejs)

```
안에 들어갈 내용은 그냥 write.ejs에 있던 모든 코드 복붙

```
그냥 파일 새로 만드시고 write.ejs에 있던 코드 전부 복붙하시면 되겠습니다.


다만 새로운 점은 input태그에 value속성을 집어넣어야한다는 것입니다.

(views/edit.ejs)
```
<input type="text" value="111111">
안에 들어갈 내용은 그냥 write.ejs에 있던 모든 코드 복붙

```

input 태그에 이렇게 value 속성을 집어넣으시면 input태그에 미리 채워진 값을 설정할 수 있습니다.

위 코드는 111111이라는 값을 input에 미리 채워준 코드입니다.

이 자리에 원래있던 제목이나 날짜데이터를 넣어주면 수정하기 편하겠죠?

그건 나중에 생각하도록 합시다.



##### 누군가 /edit으로 접속하면 방금 만든 edit.ejs 로 안내해야합니다.



이런 코드 작성은 이제 눈감고도 할 수 있을 것 같습니다.

눈감고 하세요.

(server.js)
```
app.get('/edit', function(요청, 응답){
 응답.render('edit.ejs')
});

```

이제 /edit 으로 접속하면 edit.ejs 파일을 보내고 렌더링해줍니다.

끝입니다. 그런데 생각해보니 게시물마다 각각 다른 edit 페이지가 구성되어야 합니다.

2번게시물과 4번게시물 edit 페이지는 각각 페이지 안의 내용이 달라야하지않겠습니까.

그래서 경로를 이렇게 수정해보도록 합시다.













/edit/2로 접속하면 2번게시물 수정화면이 보여야합니다.   



그럼 코드를 고치면 되겠네요 뭐

(server.js)

```
app.get('/edit/:id', function(요청, 응답){
 응답.render('edit.ejs', {DB에 있던 :id번 게시물의 제목과 날짜})
});

```
1. 일단 경로를 /edit/:id로 고쳤습니다. 그러면 누군가 /edit/뒤에 아무 문자나 적어도 edit.ejs 페이지를 보내주게 됩니다.

왜 그랬냐고요? 안그러면 /edit/2, /edit/3, /edit/4 이런 여러가지 페이지들을 만들어내야하잖아요.

(발행했던 글이 100개면 코드가 100줄이 되겠군요)



2. 그리고 누군가 /edit/2로 접속하면 DB에 있던 2번게시물의 제목과 날짜를 ejs파일로 보내야합니다.

그래야 아까 input에 value속성으로 제목을 채워넣을 수 있으니까요.

그럼 여기서 문제 들어갑니다.


-----



Q. DB에 있던 (URL에 적힌 :id)번 게시물의 제목과 날짜를 꺼내오려면 어떤 코드를 작성해야할까여?


알아서 해보십시오.

정 안되면 밑을 봅시다.











(server.js)
```
app.get('/edit/:id', function(요청, 응답){
  db.collection('post').findOne({ _id : (URL에 적힌:id) }, function(에러, 결과){
    응답.render('edit.ejs', { post : 결과 })
  })

});
```
1. findOne함수를 이용해서 DB에 저장되어있던 _id가 URL에 적힌 :id인 게시물을 찾습니다.

2. 그리고 그 찾은 결과를 post라는 이름으로 edit.ejs에 보내도록 코드를 짰습니다.

3. 그냥 대충 복붙했을 까봐 한글로 적은 함정이 하나 있습니다. URL에 적힌 :id라는걸 자바스크립트로 어떻게 표현하면 될까요?





- 저번시간에 한것이지만 그것은 요청.params.id 라고 쓰시면 되겠습니다.

이런거 까먹으면 언제나 구글찬스를 사용가능합니다. 까먹어서 기억에 없는건 열심히 생각한다고 나오지 않습니다.







(server.js)
```
app.get('/edit/:id', function(요청, 응답){
  db.collection('post').findOne({ _id : parseInt(요청.params.id) }, function(에러, 결과){
    응답.render('edit.ejs', { post : 결과 })
  })

});

```
그래서 edit페이지 안내하는 최종코드입니다. (parseInt는 정수로 변환해주는 고마운 함수입니다.)

이제 어떤 사람이 /edit/4로 접속하면 {_id : 4}인 게시물을 찾고, 그 결과를 edit.ejs에 보내주게됩니다.
![20220425_110432](/assets/20220425_110432.png)

▲ 그럼 edit.ejs에서 input안에 기존 게시물의 제목과 날짜를 채워주려면?



HTML내에 변수를 꽂아넣는 <%= 어쩌구 %>EJS 문법을 쓰면 됩니다.

강의 10:37 부분을 참고합니다.













이제 edit.ejs에서 전송버튼을 누르면 수정(PUT)요청을 해야합니다.



서버에 요청할 수 있는 방법은 4가지라고 배웠습니다. GET POST PUT DELETE

4개 중에 수정할 땐 PUT요청을 쓰면 좋다고 배웠습니다.

그럼 폼태그를 이렇게 수정하면 되지않을까 생각해보면 되는데..

(edit.ejs)
```
<form action="/어쩌구" method="PUT">
  <input 어쩌구>
</form>
```
그쵸? method란을 POST가 아니라 PUT으로 바꾸면 될 것 같은데

그건 되지 않습니다. form태그 내에선 POST, GET 이 두가지 방식만 지원합니다.

해결책은.. DELETE 강의 처럼 AJAX를 쓰던가.. 아니면

PUT을 기어코 여기에 쓰려면 method-override라는 라이브러리를 설치하면 됩니다.

1. 터미널에 npm install method-override 를 입력해서 설치하시면 됩니다.



2. 설치를 완료하기 위해 server.js 상단에 다음 코드를 추가합니다.
```
const methodOverride = require('method-override')
app.use(methodOverride('_method'))
```
const와 app.use가 모여있는 곳에 복붙하시면 됩니다.



3. 이제 form 태그에 PUT요청을 사용할 수 있습니다.

(edit.ejs)
```
<form action="/add?_method=PUT" method="POST">
 <input 어쩌구>
</form>
```
이렇게 URL란과 method란을 수정해주면

폼 전송시 /add 경로로 PUT요청을 해줍니다.

PUT요청 해결!

이제 PUT 요청을 받으면 DB 게시물을 수정해주는 서버코드 짜는 일만 남았습니다.


-------


### 글 수정 기능 2 : DB 데이터를 수정해보자 (이쯤되면 혼자서도 가능 ㅇㅋ)


/edit으로 PUT요청하면 게시물을 수정해주는 코드를 작성합시다.

일단 저번시간 구현한 form을 이렇게 수정하면 되겠습니다.

(edit.ejs)
```
<form action="/edit?_method=PUT" method="POST">
  <input 어쩌구>
</form>
```
action 속성을 /edit 으로 바꿔주시면 이제 /edit 경로로 PUT 요청이 가능합니다.

그럼 서버는 /edit 경로로 PUT 요청을 했을 때 코드를 작성해주면 되겠군요.


(server.js)
```
app.put('/edit', function(요청, 결과){
  DB 데이터를 수정해주세요
});
```
이렇게 짜면 되는거 아니겠습니까. 정말 눈감고도 하겠군요.







DB 데이터를 수정하려면 updateOne을 씁니다


(server.js)
```
app.put('/edit', function(요청, 결과){
  db.collection('post').updateOne( {_id : ??}, {$set : { 제목 : ??, 날짜 : ?? }}, function(){
    console.log('수정완료')
  });
});
```
구글 찾아보시면 MongoDB에는 updateOne 이라는 고마운 함수를 쓸 수 있다고 합니다.

사용법은 updateOne( 1.업데이트할게시물찾기, 2.수정할내용, 3.콜백함수) 라고 합니다.

일단 1. 업데이트할 게시물을 찾으시려면 저렇게 기존 게시물의 _id 같은걸 작성해주면 되겠습니다.

2. 그리고 그 게시물을 업데이트하시려면 $set 이런 operator를 사용하시면 되겠습니다. 그러면 기존 값을 수정/추가 해줍니다.

3. 콜백함수는 업데이트 완료시 실행할 코드를 적으면 되겠습니다.  



?? 물음표 자리에 유저에게 요청받은 데이터를 채워넣어봅시다



(server.js)
```
app.put('/edit', function(요청, 결과){
  db.collection('post').updateOne( {_id : ??}, {$set : { 제목 : ??, 날짜 : ?? }}, function(){
    console.log('수정완료')
  });
});
```
{_id : ??} 자리엔 무엇이 들어가야할까요. 당연히 유저가 수정요청한 글번호가 들어가야할 것 같습니다.

유저가 수정요청한 글번호가 어딨습니까.

아무데도 없어염!

그래서 하나 만들어주면 될 것 같습니다.


----------


form태그에 몰래 안보이는 input을 추가해보도록 합시다.



(edit.ejs)

```
<form action="/edit?_method=PUT" method="POST">
  <input value="<%= post._id %>" name="id" style="display : none">
  나머지 어쩌구~
</form>
```
edit 페이지에서 전송버튼을 누르면 input의 value들이 전부 폼으로 전송되는데,

함께 전송될 input을 하나 만들어준 것일 뿐입니다.

그 input에는 사용자가 수정요청하는 게시물의 _id를 적어주는 것입니다.

그럼 이제 총 3개의 input 데이터가 서버로 전송됩니다. (제목, 날짜, id)







그럼 서버는 전송된 input 데이터들을 어떻게 알 수 있냐면 ..

예전에 요청.body.title 이런 식으로 쓰면 된다고 배웠죠?


(server.js)
```
app.put('/edit', function(요청, 결과){
  db.collection('post').updateOne( {_id : 요청.body.id }, {$set : { 제목 : 요청.body.title , 날짜 : 요청.body.date }}, function(){

    console.log('수정완료')

  });
});

```
그래서 사용자가 폼전송시 함께 요청한 id를 요청.body.id 이런 식으로 꺼내쓸 수 있습니다. (id라는 단어는 input에 부여한 name 속성입니다.)

그리고 나머지 수정할 데이터 $set 어쩌구 부분의 물음표도 실제 사용자가 요청한 데이터로 채워넣어봤습니다.





다시 한번 위 코드를 해석하자면

"사용자가 /edit으로 PUT요청을 하면"

"post라는 콜렉션에 있는 {_id : 요청.body.id } 데이터를 찾아서 { 제목 : 요청.body.title , 날짜 : 요청.body.date } 로 바꿔주세요"

입니다.





그리고 마지막 화룡점정으로 parseInt()를 추가해줍니다.

(server.js)
```
app.put('/edit', function(요청, 결과){
  db.collection('post').updateOne( {_id : parseInt(요청.body.id) }, {$set : { 제목 : 요청.body.title , 날짜 : 요청.body.date }}, function(){

      console.log('수정완료')

  });
});
 ```

왜냐면 DB에 저장한 _id : ? 는 숫자니까요.

끝!







그리고 마지막 화룡점정2로 응답.redirect()를 추가해줍니다.





(server.js)
```
app.put('/edit', function(요청, 결과){
  db.collection('post').updateOne( {_id : parseInt(요청.body.id) }, {$set : { 제목 : 요청.body.title , 날짜 : 요청.body.date }},
    function(){

    console.log('수정완료')
    응답.redirect('/list')
  });
});
```
왜냐면 응답을 안해주면 브라우저가 멈출 수 있으니까요. 성공이든 실패든 응답을 해주어야합니다.

진짜 끝임 수정 잘 되는지 테스트까지 해보십시오.


-----


### 세션, JWT, OAuth 등 회원인증 방법론 쉽게 이해하기


1. Session-based Authentication



사용자의 세션정보를 저장해서 로그인 기능을 구현하는 방법입니다.

그냥 쉽게말하면

- 이 사람이 로그인 했었다는 정보를 서버의 메모리에다가 기록해놓습니다. (세션을 저장합니다.)

- 그리고 고객이 로그인이 필요한 페이지(Mypage 등)를 요청을 하면

- 세션을 들춰봐서 이 사람이 로그인했다는 정보가 나오면 통과시켜줌~!

이런 방식입니다.

그럼 약간 더 자세히 설명해보도록 합시다.





1. 로그인시 제출한 아이디, 비번이 DB 저장된 회원정보와 맞다면

서버는 옳다구나 하고 세션스토어에 세션 하나를 만들어서 저장합니다.

세션은 용어가 어려워서 그렇지 그냥 이 사람이 언제 어디서 로그인 했는지 이런 정보를 담은 자료라고 보시면 됩니다.

"Kim 이라는 사람이 7시에 로그인했습니다."

뭐 이런 정보를 서버 메모리에 저장해둡니다.



2. 그리고 로그인한 유저마다 각각 유니크한 세션아이디라는걸 발급합니다.

당연히 로그인한 사람이 여러명일 수 있으니 유니크한 세션아이디를 발급해서 구분지어주는게 좋겠죠.

그래서 abc123 이라고 세션아이디를 하나 예쁘게 발급해줬습니다.



3. 발급한 세션아이디는 쿠키에 담아서 고객 브라우저에 전송해줍니다.

세션아이디는 고객과 서버 둘다 보관합니다. 그래서 쿠키에 담아서 고객에게 보내줍니다.

* 쿠키란 브라우저에 마련되어있는 쪼그만한 문자데이터 저장공간입니다. 여기에 세션아이디가 abc123 이렇게 기록됩니다.

- 여기까지가 로그인 기능 구현 끝입니다.



그럼 이제 고객에 로그인이 필요한 페이지를 요청한 경우,

이 사람이 적법하게 로그인 했던 사람인지 검사해보도록 합시다.



1. 고객이 로그인합니다.

아이디 / 비번을 서버로 전송하면

서버는 기존에 있던 DB에 아이디/비번 세트가 존재하면 옳다구나 하고 세션아이디를 만들어줍니다.

그리고 세션아이디들을 담을 변수나 뭐 DB 공간을 마련해서 거기 저장해둡니다. 그걸 세션데이터라고 부릅시다.

(저장은 DB에 할 수도 있고 서버 메모리(그냥 변수)에 저장할 수 있습니다. )

그리고 세션 아이디를 쿠키라는 것에 이쁘게 포장해서 고객의 브라우저에 쿠키를 강제로 저장시킵니다.



2. 고객이 마이페이지를 요청합니다.

/mypage를 달라고 요청하면 서버는 응답.render() 해주기 전 일단 가로막습니다.

"님 로그인 했었음?" 이라고 물어봐야하니까요.

물어보는 과정은 심플합니다.



3. 쿠키에 세션아이디가 포함되어있는지 검사합니다.

원래 고객이 페이지를 요청할 때 마다 자동으로 쿠키가 서버로 전송됩니다.

그럼 서버는 쿠키에 기록된 세션아이디를 서버메모리 or DB에 저장되어있던 세션아이디와 비교해서

있으면 통과시켜줍니다.



4. 서버는 마이페이지를 보내줍니다.

그 전에 이 회원의 이름, 나이, 성별 등의 DB 정보가 필요하다면

세션데이터를 참고해서 이 사람의 이름, 나이 등의 정보를 DB에서 꺼내옵니다.

끝입니다.







실은 로그인기능 구현 그거 별거 아닙니다.

아이디/비번을 DB에 기록할 수 있는 회원가입 폼 알아서 만들어두시고 (진심 별거아님)

어떤 사람이 로그인하면 세션아이디를 하나 발급해서 서버와 고객이 나눠가집니다.

그리고 고객이 마이페이지같은거 요청할 때마다 "니 세션아이디 뭔데" 라고 물어보면 됩니다.



세션은 매우 전통적이고 범용적으로 사용되는 인증방식입니다.

그러므로 여러분이 개발 중 위기에 처했을 때 참고할 구글 검색결과가 풍부합니다.











2. JSON Web Token (JWT)



토큰 방식은 세션데이터를 서버에 저장하지 않고

마이페이지를 열람할 수 있는 열쇠(토큰)를 사용자에게 쥐어주는 것입니다.

그래서 그 열쇠에는 session방식보다 약간 더 많은 정보들이 들어갑니다.

요즘 토큰토큰 거리면 JSON Web Token을 말하는 것인데, 아무튼 어떤 방식인지 자세히 알아보도록 합시다.



1. 로그인시 제출한 아이디, 비번이 DB 저장된 회원정보와 맞다면

서버는 옳다구나 하고 Token 하나를 만들어서 고객 브라우저로 보내줍니다.

Token은 그냥 긴 암호화된 문자열일 뿐이고, 사용자가 로그인 했었는지, 아이디는 무엇인지 이런 정보들을 넣을 수 있습니다.

물론 위조가 불가능하도록 특별한 서명이 추가됩니다.

토큰은 쿠키나 로컬스토리지라는 곳에 저장됩니다.

(+ 코드를 잘 짜서 고객이 페이지 방문시마다 Token이 서버로 보내지도록 미리 장치를 추가합니다. )



2. 고객이 마이페이지를 요청하면  

/mypage를 달라고 요청하면 서버는 응답.render() 해주기 전 일단 가로막습니다.

"님 로그인 했었음?" 이라고 물어봐야하니까요.

물어보는 과정은 그냥 토큰 검사입니다.



3. 서버는 토큰을 검사합니다

고객이 마이페이지 요청시 함께 보낸 Token이 적법한지 검사합니다.

유통기한이 지나지 않았는지, 서명이 잘 되어있는지, 블랙리스트에 등록된 토큰인지 이런 검사를 거친 후

이상이 없으면 마이페이지로 통과시켜줍니다.





끝입니다.

기본적인 토큰 구현은 매우 간단합니다.

그리고 서버는 세션데이터 등을 메모리/DB에 저장해둘 필요가 없으니 나중에 서버 스케일링시 큰 문제가 없다는 장점도 있습니다.







하지만 단점이나 보안상 취약점이 존재할 수 있습니다.

이 사람이 로그인 했는지에 대한 정보 전체를 서버는 가지고 있지 않고 사용자가 가지고 있게 하는 것 자체가 보안상 좋은 방법은 아닙니다.

JWT 정보를 다른 사람이 훔치면 어쩔 것임? 이제 훔친 사람은 자유롭게 로그인이 가능하겠는데요?

그래서 stateful JWT 라고 부르는 '어떤 사람이 언제 로그인했는지'를 서버에 저장해두는 방식이 좋은 관습이긴 한데

그 중 하나가 refresh token 이런 방식입니다.  

그러면 위에서 말했던 세션 방식이랑 기능 상 다를바가 없습니다.

3. Open Autentication



이 방법은 쉽게말하면 페이스북, 구글 로그인입니다.

고객의 페이스북, 구글 계정정보를 불러와서 그걸 가지고 가입을 승인시켜주는 방법입니다.  



간략히 어떻게 작동하는지 구경해봅시다.

![20220425_111244](/assets/20220425_111244.png)

1. 어떤 사람이 '페이스북으로 로그인' 버튼을 눌렀다고 칩시다.

그럼 페이스북 팝업이 뜹니다.

"코딩애플 앱에 본인의 페이스북 이름, 아이디 제공을 승인하시겠습니까?"

승인을 눌러봅니다.



2. 그럼 페이스북은 우리 server.js에게 이 유저의 이름, 아이디 정보를 보내줍니다.

그럼 뭘 해야할까요. 여러분이 하고싶은거 하시면 됩니다.



3. 이 사람 페이스북 정보를 바탕으로 세션이나 토큰을 만들어줍니다.

DB에 이름, 아이디를 저장해서 회원 목록을 하나 만들어주든가,

그와 동시에 세션 데이터를 만들어주든가 하시면 됩니다.

server.js에 코드를 잘 짜서 하면 되겠죠.



4. 고객이 마이페이지를 요청하면  

/mypage를 달라고 요청하면 서버는 응답.render() 해주기 전 일단 가로막습니다.

"님 로그인 했었음?" 이라고 물어봐야하니까요.



5. 서버는 토큰이나 세션을 검사합니다

위에서 세션을 만들어 줬다면 세션이 있는지 검사하면 되고,

위에서 토큰을 만들어 줬다면 토큰이 적법한지 검사하면 되겠죠?

통과되면 마이페이지를 응답.render() 해줍니다.





비밀번호를 취급안해도 된다는 장점 때문에 관리도 편리하고 유저도 편리함을 느낍니다.

페이스북 등에서 제공하는 공식 개발문서가 많기 때문에 따라하기만 하면 일사천리로 개발이 가능합니다.

하지만 단점은 구글이나 페이스북이 1. OAuth를 중단하거나 2. 방법을 수정하거나 3. 페이스북 API 서버 다운으로 접속이 불가능하다면

우리 사이트 로그인도 불가능합니다.

페이스북은 맨날 OAuth 방법이나 정책 이런걸 변경했다고 메일자주보내는데 그래서 약간 관리하기 귀찮은 면도 있습니다.







다음 시간엔 가장 범용적인 세션을 이용한 로그인 기능을 구현해보도록 합시다.


------------


### (회원인증기능 1) 로그인 페이지 만들기 & 아이디 비번 검사


준비1. 일단 로그인 & 세션생성을 도와줄 라이브러리 설치가 필요합니다.



npm install passport passport-local express-session

을 터미널에 입력해서 설치하도록 합시다.

저렇게 띄어쓰기로 동시에 3개 라이브러리를 설치하시면 됩니다.

로그인, 로그인 검증, 세션생성을 도와주는 라이브러리 들입니다.

(실제 서비스시 express-session 말고 MongoDB에 세션데이터를 저장해주는 라이브러리를 이용하시면 좋습니다.)







준비2. server.js 상단에 설치한 라이브러리를 require 해줍니다.



그래야 설치한 것들을 사용할 수 있으니깐요. (라이브러리 사용법에 이렇게 나와있는거 그대로 작성한 것입니다)
```
const passport = require('passport');
const LocalStrategy = require('passport-local').Strategy;
const session = require('express-session');

app.use(session({secret : '비밀코드', resave : true, saveUninitialized: false}));
app.use(passport.initialize());
app.use(passport.session());
```
이렇게 6줄이 필요합니다. 대소문자 틀리면 코딩인생이 끝날 수 있기 때문에 대소문자 잘 구분하십시오.





잠깐 문법설명을 하나 드리자면 app.use() 어쩌구 부분은 '미들웨어를 쓰겠다'라는 뜻입니다.

미들웨어가 뭐냐면..

서버는 요청을 받으면 응답을 해주는 기계랬죠?

그런데 요청과 응답 사이에 뭔가 실행시키는 코드들이 바로 미들웨어입니다.

뭐.. 요청이 적법한지 검사하는 그런 기능들을 미들웨어에 많이 담습니다.



미들웨어를 어떻게 쓰냐면.. app.use 안에 담는 코드들은 전부 미들웨어 역할을 할 수 있습니다.

그러니깐 위에 있는 코드 중에 passport.initialize() 그리고 passport.session() 이런 코드들이

모든 요청과 응답 중간에 실행된다는 뜻입니다.





나중에 미들웨어를 직접 하나 만들고 싶다면 그것도 가능합니다.

그냥 app.use() 안에 집어넣어주시면 되겠습니다.


이제 어떤 흐름으로 개발할 것이냐면..

어떤 사람이 로그인을 해주면 일단 그 사람의 아이디와 비번이 DB에 있는 아이디와 비번이 맞는지 검사해야합니다.

그리고 검사 결과가 맞으면 세션을 하나 생성해주고 성공페이지로 이동시키기,

실패하면 실패페이지로 이동시키기 입니다.









개발1. 로그인페이지를 만들고 라우팅을 해줍시다.



로그인할 페이지를 ejs로 만들고 /login 방문시 보여주도록 합시다.

로그인 페이지는 login.ejs 파일을 하나 생성해주면 될 것 같군요.

(login.ejs)
```
write.ejs에 있는 내용 그대로 복붙
```
write.ejs 처럼 input이 두개 있으면 좋을 것 같아서 그대로 복붙해서 만들었습니다.

그리고 1. input의 이름만 조금 바꿔주시고 2. action="" 속성 경로를 살짝 수정해줍니다.

(login.ejs)
```
<div class="container mt-4">
 <form action="/login" method="POST">
   <div class="form-group">
     <label>아이디</label>
     <input type="text" class="form-control" name="id">
   </div>
   <div class="form-group">
     <label>비번</label>
     <input type="text" class="form-control" name="pw">
   </div>
   <button type="submit" class="btn btn-danger">로그인</button>
 </form>
</div>
```
두개의 input태그의 name 속성을 하나는 id, 하나는 pw라고 바꿔주시면 되겠습니다.

name 속성은 별건 아니고 서버에서 input 데이터를 찾기 쉬우려고 달아주는 것입니다.

login 페이지 제작 끝!

그럼 누군가가 /login으로 접속시 login.ejs 페이지를 보여주도록 합시다.

서버 코드를 어떻게 짜면 되겠습니까.
```
app.get('/login', function(요청, 응답){
  응답.render('login.ejs')
});
```
이제 이런거 짜는데 10초도 안걸릴 것 같습니다.













Q. 그런데 지금 로그인할 아이디랑 비번이 없는데요?

DB에 테스트용 아이디와 비번을 하나 만들어주시면 됩니다.

![20220425_111529](/assets/20220425_111529.png)



▲위처럼 login 이라는 새로운 콜렉션을 만드신 후에

안에 id 는 test, pw는 test인 하나의 자료를 집어넣어주시면 됩니다.

(자료 강제로 넣는건 insert document 버튼, 콜렉션 생성은 + 버튼 누르면 됩니다)













##### 개발2. 로그인 페이지에서 로그인을 하면 아이디, 비번을 검사해야합니다.



누군가 로그인폼에서 POST 요청을 하면 ~~ 를 실행해주세요 라는 코드는 어떻게 짭니까.
```
app.post('/login', function(요청, 응답){
  응답.redirect('/')
});
```
누군가 /login 경로로 POST 요청을 하면 (폼전송을 하면)

특정 코드를 실행시켜주는 코드입니다. 빨리 server.js에 추가합시다.

그리고 응답.redirect()라고 쓰시면 다른 페이지로 이동시켜줄 수 있습니다.

홈으로 이동시키는 것입니다.





그런데 로그인시 그냥 홈으로 이동시키기만 하면 되는게 아니라 중간에 검사를 해야합니다.

아이디랑 비번이 맞나요? 이렇게 물어보시면 됩니다.

그런 코드는 어떻게 짜냐면


```
app.post('/login', passport.authenticate('local', {failureRedirect : '/fail'}), function(요청, 응답){
  응답.redirect('/')
});
```
post() 라는 함수 두번째 파라미터로 뭐 이상한걸 추가해주시면 요청과 응답 사이에 특정 기능을 실행할 수 있습니다.

이상한 코드는 passport 라는 라이브러리가 제공하는 '아이디 비번 인증도와주는 코드'입니다.

응답해주기 전에 local 방식으로 아이디 비번을 인증해주세요 라는 뜻으로 해석하시면 되겠습니다.

(failureRedirect라는 부분은 로그인 인증 실패시 이동시켜줄 경로를 적으시면 됩니다. 위의 코드는 실패시 /fail 경로로 유저를 이동시켜줍니다.)


##### 개발3. 어떻게 인증할건지 세부 코드를 작성해야합니다.



그냥 저렇게만 냅두면 자동으로 인증해주진 않습니다.

세부사항을 잘 정의해주셔야합니다.

그건 다행히 passport 라이브러리 예제코드를 복붙하시면 됩니다.  



(server.js 하단에 복붙)
```
passport.use(new LocalStrategy({
  usernameField: 'id',
  passwordField: 'pw',
  session: true,
  passReqToCallback: false,
}, function (입력한아이디, 입력한비번, done) {
  //console.log(입력한아이디, 입력한비번);
  db.collection('login').findOne({ id: 입력한아이디 }, function (에러, 결과) {
    if (에러) return done(에러)

    if (!결과) return done(null, false, { message: '존재하지않는 아이디요' })
    if (입력한비번 == 결과.pw) {
      return done(null, 결과)
    } else {
      return done(null, false, { message: '비번틀렸어요' })
    }
  })
}));
```
이것이 여러분의 아이디/ 비번을 검사해주는 코드입니다.

직접 창조해서 작성하기 어려우니 그냥 복사붙여넣기를 해주시고 원하는 부분 수정하는 식으로 접근하면 충분합니다.





LocalStrategy() 라고 부르는 이상한 코드가 있습니다. 이게 여러분 local 방식으로 아이디/비번 검사를 어떻게 할지 도와주는 부분이라고 보시면 됩니다.

그리고 그 안에 세부설정을 해주시면 됩니다.

LocalStrategy( { 설정 }, function(){ 아이디비번 검사하는 코드 } )

이런 흐름으로 되어있습니다.





일단 오늘은 {설정}부분 설명만 드리겠습니다.





설정은 여러가지가 가능한데 그중 필수로 해야하는 것들만 적었는데

상세히 무슨 뜻인지 설명해드리자면

```
passport.use( new LocalStrategy({
   usernameField: 'id', (요기는 사용자가 제출한 아이디가 어디 적혔는지)
   passwordField: 'pw', (요기는 사용자가 제출한 비번이 어디 적혔는지)
   session: true, (요기는 세션을 만들건지)
   passReqToCallback: false, (요기는 아이디/비번말고 다른 정보검사가 필요한지)
});
```

옆에 하나씩 한글을 적은 것만 읽어도 충분하겠군요.

usernameField는 사용자가 제출한 아이디가 어떤 input인지 input의 name 속성값을 적어주시면 됩니다.

passwordField도 마찬가지입니다.

session : true는 세션을 하나 만들어줄건지 입니다. 만들어줘야 나중에 다시 로그인 안해도 되겠죠?

passReqToCallback 부분은 사용자의 아이디/비번 말고도 다른 정보를 검사해야할 경우 true로 바꿔주시면 됩니다.

그러면 옆에 있는 콜백함수의 첫번째 파라미터로 기타 정보들이 들어가는데 파라미터.body 이런 식으로 출력해보시면 알 수 있습니다.

아직은 쓸 일이 없기 때문에 쓸일 있으시면 그 때 구글에 사용법을 찾아서 쓰도록 합시다.





그러면 이제 아이디 비밀번호를 검사할 준비가 끝났습니다.

다음 시간엔 사용자의 아이디, 비번을 실제 DB에 저장된 데이터와 한번 비교해보도록 합시다.

그리고 이거 코드 길다고 무서워할 필요가 없습니다.

어짜피 다른사람이 만든 라이브러리 갖다 쓰는건데 외우거나 전부 이해할 필요 전혀 없습니다.

그저 웹을 만들고 싶다면 그냥 복붙잘하고 사용법만 익히면 끝입니다.





------------------


### (회원인증기능 2) 아이디 비번을 DB와 비교하고 세션 만들어주기


저번시간까지 이런 스텝으로 개발했었습니다.

개발1. 로그인 페이지 제작 / 라우팅

개발2. 로그인 요청시 아이디/비번 검증 미들웨어 실행시키기

개발3. 아이디/비번 검증하는 세부 코드 작성

그럼 오늘을 뭘 해야할까요.

로그인을 시키려면.. 아이디 비번을 DB와 검사하고 그게 맞으면 세션을 하나 만들어주면 되겠군요.

진행하도록 합시다.










##### 개발4. 아이디/비번 DB와 맞는지 비교



하지만 코드는 다행히 저번시간에 작성을 끝냈기 때문에 작성할게 없습니다.



(server.js)
```
passport.use(new LocalStrategy({
  usernameField: 'id',
  passwordField: 'pw',
  session: true,
  passReqToCallback: false,
}, function (입력한아이디, 입력한비번, done) {
  //console.log(입력한아이디, 입력한비번);
  db.collection('login').findOne({ id: 입력한아이디 }, function (에러, 결과) {
    if (에러) return done(에러)

    if (!결과) return done(null, false, { message: '존재하지않는 아이디요' })
    if (입력한비번 == 결과.pw) {
      return done(null, 결과)
    } else {
      return done(null, false, { message: '비번틀렸어요' })
    }
  })
}));
```
여기 function(){} 안에서 아이디/비번을 DB데이터와 비교하시면 됩니다.

그럼 어떻게 코드를 짜야할까요.

1. DB에서 {id : 입력한아이디} 인 문서를 찾은 다음에

2. 그게 있으면 그 문서에 있는 pw 값과 입력한 비번을 비교하면 되지 않을까요?

3. 성공하면 찾은 유저를 출력해주든가 그러시면 되겠군요.


그래서 1, 2, 3 대로 위에 코드를 다 짜놓았습니다.

그냥 이렇게 냅두시면 됩니다.

그리고 아이디/비번 검사가 성공하면 return done(null, 결과) 를 실행해주어야합니다.











하지만 문제점이 하나 있습니다.



지금 if ( 입력한비번 == 결과.pw ) 라는 부분에서 사용자가 입력한 비밀번호와 DB의 pw 항목을 같은지 비교하고 있는데

- 애초에 DB에 pw를 저장할 때 암호화해서 저장하는 것이 좋으며

- 사용자가 입력한 비번을 암호화해준 뒤에 이게 결과.pw와 같은지 비교하는게 조금 더 보안에 신경쓴 방법입니다.

하지만 보안보안 암호화암호화 거리면 강의가 너무나 복잡해져서 이해도가 떨어질 수 있기 때문에

나중에 구글에 좋은 비번저장 예제를 찾아서 한번 그대로 적용해보시길 바랍니다.


##### 개발5. 세션 만들고 세션아이디 발급해서 쿠키로 보내주기



아이디/비번을 DB데이터와 비교해서 이게 맞다면 어떻게 해야합니까.

세션 방식을 적용한다고 했으니 세션데이터를 하나 만들어주면 되겠죠? (이건 라이브러리가 알아서 합니다)

그리고 세션데이터에 포함된 세션아이디를 발급해서 유저에게 보내면 됩니다.

실은 쿠키로 만들어서 보내주시면 됩니다.

세션데이터를 만들고 세션아이디를 만들어 보내주는 것도 라이브러리 도움을 받으면 딱 3줄이면 됩니다.

server.js 하단에 따라칩니다.


```
passport.serializeUser(function (user, done) {
  done(null, user.id)
});

passport.deserializeUser(function (아이디, done) {
  done(null, {})
});
```
serializeUser 라는 함수가 바로 그 역할을 합니다.

- 유저의 id 데이터를 바탕으로 세션데이터를 만들어주고

- 그 세션데이터의 아이디를 쿠키로 만들어서 사용자의 브라우저로 보내줍니다.



deserializeUser 라는 함수는 다음 시간에 알아보도록 합시다.

얘는 이제 로그인 된 유저가 마이페이지 등을 접속했을 때 실행되는 함수입니다.


그럼 테스트를 해보도록 합시다.



지금까지 이런 스텝으로 개발했습니다.

- 개발1. 로그인 페이지 제작 / 라우팅

- 개발2. 로그인 요청시 아이디/비번 검증 미들웨어 실행시키기

- 개발3. 아이디/비번 검증하는 세부 코드 작성

- 개발4. 아이디/비번을 DB데이터와 비교

- 개발5. 맞으면 세션아이디 만들어서 쿠키로 보내기



그럼 어떤 사람이 DB에 저장된 아이디/ 비번 한쌍으로 로그인시  

쿠키가 만들어져서 고객의 브라우저로 전송되어야합니다.

그럼 로그인 페이지에서 로그인을 시도해보고

쿠키가 진짜 서버에서 들어오는지 확인해보도록 합시다.







▼ 쿠키는 여기서 확인할 수 있습니다.

여러분 사이트 localhost:8080 미리보기 들어가신 다음 우클릭 - 검사 - Application 탭 - 좌측 Cookies 에서 확인가능합니다.

![20220425_112237](/assets/20220425_112237.png)


▼ 로그인 성공시 session 어쩌구라고 적힌 쿠키가 새로 하나 생성되면 성공입니다.


![20220425_112300](/assets/20220425_112300.png)

다음 시간은 유저가 마이페이지 등으로 접속을 요청할 때

세션아이디가 진짜 있는지 쿠키를 검사해서 접속을 허가하거나 허가하지 말도록 합시다.

--------

### (회원인증기능 3) 로그인 유저만 접속할 수 있는 페이지 만들기

로그인 유저만 접속할 수 있는 페이지를 만들고 싶다면 어떻게 할지 알아보도록 합시다.

예제로 가장 간단한 마이페이지를 만들어봅시다.







1. 마이페이지.ejs를 만들고 라우팅을 합시다.



(mypage.ejs)
```
<p> ~~의 마이페이지입니다.</p>
```
mypage.ejs 파일을 views 폴더에 만드신 후 내용을 채워주시면 됩니다.

그냥 다른 ejs 파일에 있던 HTML 내용 다 복붙하신 다음에 필요없는거 지우고

위와 같은 글씨 하나만 추가해주면 되겠는걸요?





그럼 이제 서버에서 /mypage 접속시 이 페이지로 라우팅을 시켜주도록 합시다.

(server.js)
```
app.get('/mypage', function (요청, 응답) {
  응답.render('mypage.ejs', {})
})
```
끝입니다. 이제 /mypage 접속하면 누구나 mypage.ejs를 보여주죠?



2. 로그인한 사람만 마이페이지를 보여줍시다.



지금은 마이페이지를 개나소나 다 접속이 가능한데..

로그인한 유저만 이 페이지를 보여주고 싶기 때문에 여기다가 미들웨어를 하나 추가하려고 합니다.

미들웨어는 누가 mypage를 요청시 mypage.ejs를 응답해주기 전에 실행할 짧은 코드를 의미합니다.

그 미들웨어에서 "야 너 로그인했니?" 라고 물어보면 좋지 않을까요?

그럼 미들웨어를 만들어봅시다.







(server.js)
```
app.get('/mypage', 로그인했니, function (요청, 응답) {
  console.log(요청.user);
  응답.render('mypage.ejs', {})
})

function 로그인했니(요청, 응답, next) {
  if (요청.user) {
    next()
  }
  else {
    응답.send('로그인안하셨는데요?')
  }
}
```
server.js 를 위와 같이 업데이트 했습니다.

1. get() 이런 함수 안에 저렇게 미들웨어를 집어넣을 수 있습니다. 그러면 /mypage 요청과 mypage.ejs 응답 사이에 로그인했니라는 코드를 실행시켜줍니다.  

2. 로그인했니() 라는 코드는 함수입니다. 밑에서 함수를 디자인해봤습니다.

이 함수는 "요청.user 가 있으면 next()로 통과시켜주시고요, 없으면 에러메세지를 응답.send() 해주세요~" 라는 뜻입니다.


3. 요청.user 라는건 뭡니까?



로그인 한 유저의 DB상 정보입니다. (아이디, 비번, 유저명 등)

하지만 그냥 출력해보면 아무것도 없고, 이걸 사용하려면 deserializeUser 라는 부분 기능개발이 필요합니다.

deserializeUser 라는 부분은 고객의 세션아이디를 바탕으로 이 유저의 정보를 DB에서 찾아주세요~ 역할을 하는 함수입니다.

그리고 그 결과를 요청.user 부분에 꽂아줍니다.



그래서 deserializeUser 부분을 이렇게 바꿔주시면 됩니다.
```
passport.deserializeUser(function (아이디, done) {
  db.collection('login').findOne({ id: 아이디 }, function (에러, 결과) {
    done(null, 결과)
  })
});
```
그러면 DB에서 {id : 세션아이디에 숨겨져있던 유저의 아이디} 인 게시물을 하나 찾아서

그 찾은 DB데이터 결과를 done(null, 결과) 이렇게 해줍니다.

그러면 결과가 요청.user 부분에 꽂히게 됩니다.

중간중간 궁금한 변수나 파라미터같은게 있으면 항상 console.log()로 출력해보시면 됩니다.



아무튼 그래서, 누군가 mypage로 요청시

방문자가 세션아이디 쿠키가 존재하면 deserializeUser 라는 함수 덕분에 항상 요청.user라는 데이터가 존재합니다.

출력해보시면 로그인한 유저의 정보가 나오쥬?

아무튼 결론은

요청.user는 deserializeUser가 보내준 그냥 로그인한 유저의 DB 데이터입니다.











그래서 로그인/비로그인 시 /mypage 방문 테스트를 해보시면 되겠습니다.

로그아웃을 하고 싶다면 직접 브라우저 우클릭 - 검사창 열어서 - 쿠키를 삭제하시면 됩니다.

멋지게 로그아웃시키는 방법은 누군가 /logout 페이지 방문시(GET 요청시) 요청.logout() 이라는 짧은 코드를 실행하시면 됩니다.

server.js에 하나 작성하시면 되겠습니다.

(작성할 때 까먹지 말고 응답도 꼭 해주셔야합니다)

4. 마이페이지 방문시 유저의 이름을 HTML에 박아넣고 싶어요



그것은 매우 쉽게 구현할 수 있습니다.

왜냐면 아까 요청.user 라는 이상한 듣도보도 못한 변수에 유저의 데이터가 다 담겨있다고 했죠?
```
app.get('/mypage', 로그인했니, function (요청, 응답) {
 console.log(요청.user);
 응답.render('mypage.ejs', { 사용자: 요청.user })
})
```
그러면 그 요청.user 라는 데이터를 mypage.ejs에 전송하면 되는게 아닐까요?

그럼 mypage.ejs에 지금 요청.user라는 데이터를 사용자라는 이름으로 전송하고 있습니다.

그럼 이제 mypage.ejs 파일에서 이 데이터를 자유롭게 원하는 자리에 박아넣고 그럴 수 있겠군요.









(mypage.ejs)
```
<p> <%= 사용자.id %>의 마이페이지입니다.</p>
```
mypage.ejs 파일을 이런 식으로 업데이터하시면 요청.user 데이터가 쏙 박히게 됩니다.  

여긴 사용자의 아이디/ 비번 이런 정보들이 들어가있겠군요.

끝입니다.



이제 회원가입 기능만 한번 직접 만들어보시길 바랍니다.

누군가 회원가입 POST 요청을 하면,

회원가입 form에 입력했던 아이디/ 비번/ 이름 이런 정보들을 DB(login이라는 콜렉션)에 저장시키면 됩니다.

하지만 저장하기 전에 아이디가 이미 DB에 있는지 중복검사도 한번 해주면 좋겠죠?

그리고 비밀번호를 저장할 땐 비밀번호를 암호화해서 저장하는 것도 매우 좋은 관습입니다. (라기보단 그냥 필수죠)

암호화하는 라이브러리를 하나 찾아서 그대로 따라하시면 되겠습니다.



그럼 DB에 qwer1234 라는 멋진 패스워드를

qwer1214 -> 35d91262b3c3ec8841b

뭐 이런 식으로 암호화해서 저장할 수 있습니다.  



그리고 로그인할 때도 지금은 사용자가 입력한 비번을 그대로 DB와 비교하고 있는데

사용자가 입력한 qwer1234 비밀번호를

qwer1214 -> 35d91262b3c3ec8841b

이런 식으로 암호화해서 DB에 있는 암호화된 비번과 같은지 비교하면 되겠죠?















Q. 내가 이런 기능을 만들고 싶은데 동작 프로세스를 어떻게 짜야할지 모르겠어요.

A. 시작은 벤치마킹입니다. 비슷한 프로세스를 가진 사이트를 구경해보십시오.

쇼핑몰을 만들고 싶다면 쇼핑몰 관리자 페이지를 구경해보십쇼. (요즘은 무료 쇼핑몰개설 사이트 많으니까요)

그 사이트에 나와있는 페이지와 프로세스를 똑같이 따라 구현하시면 기능개발 끝입니다.





Q. 실제 서버 제작을 위해 신경쓰거나 더 공부해봐야할 사항들이 있나요?

- 디자인, UI 개발, IE 호환성, 반응형 웹 등 프론트엔드 내용

- 악성 유저가 아이디를 너무 길거나 이상하게 적으면 어떻게 할지 (직접 악성 유저가 되어 이것저것 테스트해보시면 됩니다)

- DB에 저장하기 전에 빈칸이 없는지, 길이가 너무 길지 않은지 정규식과 if문으로 검증하기

- helmet 라이브러리 등으로 보안 약간 더하기

- 이미지 업로드 등 서버에서 이미지 처리하기 (압축, 저장, 리사이즈 등)

- Oauth 등 다른 로그인 방식 도입해보기

- express-session 라이브러리는 세션이 많아지면 서버의 메모리를 많이 잡아먹기 때문에 connect-mongo 등의 라이브러리로 DB에 세션데이터를 저장해서 사용하기



등 여러분이 필요한 서비스에 따라 많은 것들이 달라질 수 있습니다.


### .env 파일에서 민감한 환경변수들 관리하기


글로 진행하는 매우 짧은 강의입니다.

선택사항이긴 하지만 실제 서버배포시 필수라고 볼 수 있는 .env 파일에 대해 알아봅시다.







여태까지 작성한 server 코드를 잘 보시면 이런 코드가 존재합니다.
```
var db;
MongoClient.connect('mongodb+srv://codingapple1:어쩌구@저쩌구', function(err, client){
  if (err) return console.log(err)
  db = client.db('Example1');
  app.listen(8080, function() {
    console.log('listening on 8080')
  })
})
```
서버 띄울 때 맨 처음 작성했던 코드인데

여기에 잘 보시면 8080이라는 포트번호, mongodb+srv라고 시작하는 이상한 DB접속 문자열이 존재합니다.

이런 값들은 다른 개발환경이나 다른 컴퓨터로 코드를 옮긴다면 수정이 필요할 수 있습니다.



-다른 컴퓨터에선 8070 포트를 연다든지,

- 나중에 DB 이사를 가서 DB접속 문자열이 바뀐다든지

- 아니면 내가 만든 코드를 팀원과 share 해야하는데 내 아이디 비번이 적혀있으면 좀 그렇잖습니까

이런 환경에 따라 가변적인 변수 데이터들을 보통 환경변수라고 부르는데

(멋있는 영어로 environment variable 이라고 합니다.)




그래서 개발자들은 미래를 생각하는 코딩을 하기 위해 환경변수를 한곳에 모아서 관리합니다.

.env파일이라는 곳입니다.

.env파일에 모든 중요 환경변수들을 다 쑤셔박아넣은 뒤에,

server.js에 가서 ".env파일에 있는 포트숫자를 여기에 넣어주세요~" 이런 식으로 코딩합니다.

이 경우 server.js 파일이 털릴 경우에도 중요한 정보들은 env 파일에 있기 때문에 조그만한 보안상 이점도 있긴 있습니다.

구체적으로 어떻게 사용하는지 튜토리얼 들어갑니다.



1. 환경변수 사용을 위한 라이브러리를 설치합니다.

오늘도 어김없이 라이브러리 설치입니다.

터미널을 켜시고 npm install dotenv 라고 입력하셔서 설치하시면 됩니다.







2. 환경변수가 있는 server.js에 방금 설치한 라이브러리를 등록합니다.

(server.js)

require('dotenv').config()
server.js 상단에 (const 모여있는 곳에) 이렇게 적어주시면 됩니다.

이제 하단에서 환경변수를 자유롭게 사용가능합니다.

![20220425_113608](/assets/20220425_113608.png)

3. server.js와 같은 경로에 .env 파일을 하나 만들어줍니다.

그리고 내부에 여러분이 나중에 변경이 될 것 같은 환경변수들을 전부 다 적고 저장해주시면 됩니다.

(.env 파일)
```
PORT=8080
DB_URL="mongodb+srv://codingapple1@저쩌구"
```
이런 식입니다.

형식은 var 문법으로 숫자, 문자 변수만드는거랑 똑같이 왼쪽엔 변수명, 오른쪽은 값을 넣는다고 보시면 됩니다.

다만 변수 이름들은 보통 대문자로 표기합니다.

여기 파일에 모든 환경변수를 모아놓으면 나중에 이 파일만 수정하면 되니까 관리도 편해지고,

나중에 작업환경이 바뀌거나 클라우드에 올릴 때도 요것만 변경해주면 쉽게 환경셋팅이 가능해집니다.



4. 그럼 환경변수들을 server.js에다가 불러오도록 합시다.

server.js에서 env파일의 변수들을 불러오실 때는 process.env.변수이름 이렇게 불러올 수 있습니다.

(기존 server.js 코드)
```
var db;
MongoClient.connect('mongodb+srv://codingapple1:어쩌구@저쩌구', function(err, client){
  if (err) return console.log(err)
  db = client.db('Example1');
  app.listen(8080, function() {
    console.log('listening on 8080')
  })
})
```

(env 파일을 적용하는 server.js 코드)
```
var db;
  MongoClient.connect(process.env.DB_URL, function(err, client){
  if (err) return console.log(err)
  db = client.db('Example1');
  app.listen(process.env.PORT, function() {
    console.log('listening on 8080')
  })
})
```
위는 기존 코드, 밑은 env파일 내의 환경변수를 적용한 코드입니다.

밑에 처럼 코드를 짜시면 이제 나중에 환경변수 변경이 필요할 때

직접 server.js 코드를 뒤져서 바꾸는게 아니라 .env 파일만 손보면 되니 약간 더 편리하겠죠?

여러분이 나중에 AWS, Google, Naver 클라우드 등을 이용해서 서버를 발행할 때

env파일을 똑같이 이용할 수 있습니다.

구글 클라우드 서비스에 올릴 경우 env 파일을 따로 만드는게 아니라 app.yaml 파일 내에 환경변수들을 포함해야하는데

https://cloud.google.com/appengine/docs/standard/nodejs/config/appref#environment_variables

이런 곳을 참고해서 똑같이 환경변수를 제작하면 되겠습니다.

다만 변수만드는 문법에 등호 대신 콜론 (:)을 씁니다.





그러니 어서 .env 파일을 활용해보시길 바랍니다.

.env 파일 만드실 때 파일명에 마침표 있는거 잊지 마시고요.

### 검색기능 만들기 1 : URL query string

오늘의 숙제 : 검색결과 보여주는 ejs 페이지를 알아서 만들어오시면 됩니다.

search.ejs 라고 작명하는게 어떨까요.

디자인은 알아서 하시고 DB에서 찾은 검색결과를 보여주면 됩니다.







우리가 발행한 게시물의 검색기능을 만들어봅시다. 검색창 UI 그리고 검색결과 보여주는 html 페이지가 필요하겠군요.

검색창 UI를 다음과 같이 list.ejs 아무데나 추가합시다.


```
<div class="container input-group mb-2">
  <input class="form-control">
  <button class="input-group-append btn btn-danger">검색</button>
</div>
```
Bootstrap 설치되어있으면 CSS짤 필요 없이 이쁜 UI가 빠르게 완성되는군요.





님들 검색기능 만드는거 혼자하실 수 있습니다. 여태 배웠던 기본 기능들로 못만들게 없으니깐요.

1. 서버에게 "이닦기" 라고 검색어를 보내면

2. 서버는 DB에서 "이닦기"라는 제목이 포함된 게시물을 찾아줍니다.

3. 그 게시물들을 ejs 파일로 보여주면 되는 것 아니겠습니까



DB에서 게시물 찾는건 collection().findOne() 하면 하나 찾을 수 있다고 했고

collection().find().toArray() 하면 여러개 찾을 수 있다고 했습니다.

이제 알아서 하시길 바랍니다. ㅂㅂ

##### GET 요청으로 서버에게 데이터 보내는 법



서버로 데이터 보낼 땐 POST 요청을 쓰면 된다고 했습니다.

그러면 요청.body 이런 식으로 꺼내서 쓸 수 있다고 했는데 이거 말고도 GET 요청으로도 간단한 데이터전달이 가능합니다.

GET요청시 URL 뒤에 몰래 데이터를 심으면 됩니다.

![20220425_114200](/assets/20220425_114200.png)

▲ 네이버 이미지 검색에서 '사과'라는 검색어를 입력하면 저렇게 됩니다.

잘 보면 사과라는 정보와 image검색이라는 정보가 서버로 전달되고 있습니다.

저게 GET요청시 서버로 데이터 전해주는 법입니다. ? 물음표 뒤에 정보들을 입력하면 끝입니다.



작성할 때 형식은 정해져있는데

데이터이름1=데이터값1&데이터이름2=데이터값2

이렇게 작성해야합니다.



이걸 query string 혹은 query parameter라고 합니다.



Query string 작성해서 GET 요청하기
```
<div class="container input-group mb-2">
  <input class="form-control">
  <button class="input-group-append btn btn-danger" id="search">검색</button>
</div>

<script>
  $('#search').click(function(){
    window.location.replace('/search?value=이닦기')
  });

</script>
```
1. 검색버튼에 id=""를 추가하고

2. 그걸 누르면 현재 URL 주소를 /search?value=이닦기로 바꾸라고 코드를 짰습니다.

실은 URL 주소 변경하는게 GET요청이랑 똑같은 짓거리기 때문에

검색버튼 누르는 순간 /search로 GET요청을 날리게 되고

value : 이닦기라는 정보가 서버로 전달됩니다. 끝!

(jQuery문법은 jQuery 설치한 곳 밑에 코드짜셔야 잘 작동합니다)





근데 저거 이닦기 대신에 사용자가 저기 input에 입력한 값을 채워넣으면

실제 검색기능이랑 유사해지지않을까요. 아까 검색기능만드는 1~3 step 이거에서 1번구현 끝인듯요?


```


<div class="container input-group mb-2">
  <input class="form-control" id="search-input">
  <button class="input-group-append btn btn-danger" id="search">검색</button>
</div>

<script>
  $('#search').click(function(){
    var 입력한값 = $('#search-input').val();
    window.location.replace('/search?value=' + 입력한값)
  });

</script>

```

1. 검색 input에 id를 추가했습니다

2. 그리고 거기에 사용자가 입력한 값을 query string으로 집어넣으라고 했습니다 끝

그러면 이제 input에 똥싸기라고 입력하고 전송누르면

value : 똥싸기라는 데이터가 서버로 전달됩니다.


##### 서버에서 query string 확인하는 법


```
app.get('/search', (요청, 응답)=>{
  console.log(요청.query);
})
```
이러면 끝인데 요청.query 하시면 query string을 전부 꺼내볼 수 있습니다.



이건 object자료로 전달이 되기 때문에 요청.query.value 하시면 아까 작성했던 똥싸기 이런 데이터가 잘 출력됩니다.

그리고 참고로 function 이라는 키워드 대신 => 이거 쓰셔도 똑같은 함수문법입니다. 더 뭔가 간단해보임





그럼 이제 사용자가 보낸 검색어로 db에서 게시물 어떻게 꺼냅니까

글의 제목이 "사용자가 입력한 검색어"인 게시물을 꺼내봅시다.

어떻게 꺼내게요


알아서 해야합니다

```
app.get('/search', (요청, 응답)=>{
  console.log(요청.query);
  db.collection('post').find({제목 : 요청.query.value}).toArray((에러, 결과)=>{
    console.log(결과)
  })
})
```
이러면 끝입니다. '이닦기' 검색하면 진짜 콘솔창에 '이닦기'라는 제목의 게시물이 출력됩니다.

근데 문제는 정확히 제목이 일치하는 것만 찾아줍니다.

제목이 "이닦기입니다" 이런 게시물은 안찾아준다는 것임

이 문제는 다음시간에 해결해보도록 합시다.

오늘의 숙제나 해오십시오 검색결과 보여주는 ejs 페이지를 알아서 만들어오시면 됩니다.

search.ejs 라고 작명하는게 어떨까요.

------



### 검색기능 만들기 2 : 게시물이 100만개일 때 쓰는 indexing 개념설명


저번시간 숙제는 어떻게 했냐면


검색결과 보여주는 페이지가 필요해서

일단 search.ejs 파일을 만들고 list.ejs에 있던거 그대로 복붙했습니다. 끝





그리고 서버는 이렇게 했다고 합니다.
```
app.get('/search', (요청, 응답)=>{
  console.log(요청.query);
  db.collection('post').find({제목 : 요청.query.value}).toArray((에러, 결과)=>{
    console.log(결과)
    응답.render('search.ejs', {posts : 결과})
  })
})

```
/search로 GET요청시 검색결과를 search.ejs와 함께 보여주라고 했습니다.

아마 그럼 posts라는 변수로 결과가 search.ejs로 전달될겁니다. 이걸 ejs 문법으로 어찌저찌하든 하면 됩니다.


하지만 문제점 : 정확히 일치하는 것만 찾아줍니다.

"글쓰기"라고 검색하면 "글쓰기를 잘해야합니다" 이런 게시물은 못찾는 겁니다.

어떻게 해결하냐면





간단한 해결책 : 정규식을 씁니다.



정규식은 문자를 검사하는 식입니다. // 안에다가 문자를 담으면 검사해줍니다.

/abc/ 이렇게 적으면 문자에 abc라는게 들어있냐~ 라고 검사해줄 수 있으니 이거 쓰면 해결입니다.


```
db.collection('post').find({제목 : /글쓰기/})
```
그니까 find() 함수쓸 때 이렇게 검색하면 되는 것임

끝

Database가 게시물을 찾는 방법



원래 게시물을 그냥 찾으면 매우 느립니다.

원하는걸 찾으려면 게시물 100만개를 전부 탐색해야하니까요.

그래서 데이터베이스는 보통 Binary Search라는걸 사용할 수 있습니다.



이게 뭐냐면 제가 1부터 100까지 숫자를 하나 생각해볼테니 여러분이 한번 찾아보시길 바랍니다.

빠르게 찾고싶으면 저에게 어떻게 질문을 던져야할까요.



1입니까 2입니까~~ 이렇게 하나하나 물어보면 평생걸리겠죠?

그래서 똑똑한 사람들은 "50 이상입니까?" 라고 물어봅니다.

예라고 답하면 그 다음은 "75 이상입니까?" 라고 물어봅니다.

이렇게 반을 잘라가면서 물어보면 매우 빠르게 최소한의 질문으로 찾아낼 수 있습니다.

5~6번만 질문 던지면 100개 중에 내가 원하는 항목을 빠르게 찾을 수 있게 됩니다.

게시물이 100만개라도 20번만 물어보면 될걸요?

이게 Binary Search라는 알고리즘입니다.



거의 모든 Database들은 기본적으로 이걸로 게시물을 찾아주는데

근데 이걸 쓰려면 조건이 있습니다. 숫자가 1부터 100까지 미리 정렬이 되어있어야합니다.

그래야 "50 이상입니까~" 라고 물어보죠.



------

그럼 글제목도 빠르게 찾으려면



미리 정렬해두면 되지 않을까요? (글자도 정렬이 가능합니다)

맞습니다 이걸 멋진 용어로 indexing이라고 합니다.

indexing을 해두면 이제 글자로 뭔가 검색할 때 매우 빠르게 찾을 수 있습니다.

indexing 하려면 MongoDB Atlas 들어가셔서

원하는 Collection 안에서 Index 만들기 누르시면 됩니다.

![20220425_114717](/assets/20220425_114717.png)
▲ 잘 찾아보셈 어딘가에 있음

![20220425_114735](/assets/20220425_114735.png)

▲ 그 다음에 저렇게 설정해주면 됩니다.

{ 인덱스만들항목이름 : 'text' }

이렇게 기입하면 끝입니다.

글자인 경우 'text' 숫자인 경우 1 또는 -1을 기입하면 끝입니다.

그러면 index가 생성됩니다.





인덱싱이라는 용어가 어려워 보이지만 그냥 collection을 사본을 하나 더 만들어주는 작업일 뿐입니다. 근데 정렬된 사본임

아무튼 index를 만들어두면 빠르게 찾아낼 수 있는데 한글 게시물들의 경우 문제점이 있을 수 있습니다.

다음시간에 해결해보도록 합시다.





(참고) 정규식을 사용하면 항상 index를 사용하는게 아닙니다.

정규식을 쓸 때 시작하는 단어가 '이닦기'인걸 찾아주세요~ 라고 명령을 주면 index를 사용하고

'이닦기'가 포함된걸 다찾아주세요~ 라고 명령을 주면 index를 사용하지 않습니다.

그래서 인덱싱 이런게 항상 만능은 아닙니다.

이런 문제도 다음시간에 해결합시다.


------

### 검색기능 만들기 3 : 네이버같은 검색기능 만들려면 (Search index)


aggregate() 검색조건에 들어갈 코드

```
var 검색조건 = [
    {
      $search: {
        index: '님이만든인덱스명',
        text: {
          query: 요청.query.value,
          path: '제목'  // 제목날짜 둘다 찾고 싶으면 ['제목', '날짜']
        }
      }
    }
]
```

###### (참고) 프론트엔드에서 Query string을 쉽게 만들려면



jQuery 문법 중에 param, serialize를 쓰면 됩니다.
```
var 자료 = { 이름1 : '값1', 이름2 : '값2' }
$param(자료) //이름1=값1&이름2=값2 이거가 남음
```
이렇게 하면 object 자료를 query string으로 쉽게 변환가능하고






```
$(폼태그를찾고).serialize()
```
이렇게 하면 폼태그 안에 있는 모든 <input>을 query string으로 쉽게 변환해줍니다.

다만 input에 name 속성이 있어야합니다.

인덱스를 활용하여 검색하려면



정확한 문법을 쓰셔야합니다.
```
app.get('/search', (요청, 응답)=>{
  console.log(요청.query);
  db.collection('post').find( { $text : { $search: 요청.query.value }} ).toArray((에러, 결과)=>{
    console.log(결과)
    응답.render('search.ejs', {posts : 결과})
  })
})
```
find() 안에 저렇게 $text 어쩌구로 시작하시면 만들어둔 text 인덱스에서 검색이 가능합니다.

이렇게 기능개발해놓으면 간단한 검색엔진처럼 검색도 가능한데



검색창에

이닦기 글쓰기라고 검색하면 이닦기 or 글쓰기가 포함된 모든 문서를 찾아줌

이닦기 -글쓰기라고 검색하면 이닦기인데 글쓰기라는 단어 제외 검색

"이닦기 글쓰기" 라고 검색하면 정확히 이닦기 글쓰기라는 phrase가 포함된 문서 검색

이렇게 가능합니다.



심각한 단점 :

글쓰기라고 검색하라면 글쓰기입니다~ 이런 문장은 못찾아줍니다.

영어는 상관없는데 영어가 아닌 언어들은 그래서 text search 기능을 쓸 수가 없습니다.

그래서 그냥 영어서비스 개발할거면 쓰시고 아니라면 지웁시다.

그럼 100만개에서 '글쓰기'라는 단어가 포함된 문서를 검색해야하면 어떻게 하죠 ㄷㄷ





해결책 1. 검색할 문서의 양을 제한을 둡니다.

DB에다가 검색요청을 날릴 때 특정 날짜에서만 검색하라고 요구할 수도 있고

skip(), limit() 이런 함수를 이용하시면 pagination 기능을 개발할 수 있습니다.

그니까 맨 처음 검색할 땐 맨앞에 20개만 찾아줘~

그 다음엔 다음 20개를 찾아줘~

이렇게 요구할 수 있다는 겁니다. 대부분의 게시판들은 이런 방법을 이용합니다.







해결책 2. text search 기능을 굳이 쓰고 싶으면

MongoDB를 님들이 직접 설치하셔야합니다.

그리고 indexing할 때 띄어쓰기 단위로 글자들을 indexing하지말고

다른 알고리즘을 써라~ 라고 셋팅할 수 있습니다.

nGram 이런 알고리즘을 쓰면 된다고 하는데 이걸 언제하고 있습니까 패스합시다







해결책 3. Search index를 사용합니다.

MongoDB Atlas에서만 제공하는 기능인데

클러스터 들어가보시면 아마 Search 어쩌구라는 메뉴가 있을겁니다. 그거 누르시면 됩니다.

![20220425_120826](/assets/20220425_120826.png)


▲ 그러면 Search index라는걸 만들 수 있습니다.

전에 만든 text index랑 비슷한 기능을 제공하는데

아무튼 이름 잘 지어서 만들어주십시오.



![20220425_120853](/assets/20220425_120853.png)
▲ index 이름은 자유 작명이고

어떤 collection에 있는 항목을 indexing 할건지 선택하면 됩니다.



![20220425_120919](/assets/20220425_120919.png)

▲ 그리고 Analyzer를 설정하는 부분이 있습니다.

이걸 lucene.korean으로 바꿔주시면 똑똑하게 한국어에 딱 맞게 인덱싱을 해줍니다.

lucene이 뭐냐면 그 형태소분석기 이런건데 한국어는 쓸데없는 조사 이런게 붙지 않습니까

글쓰기를

글쓰기입니다

글쓰기지만

글쓰기라도

이런 식으로 단어 뒤에 쓸데없는 조사가 붙는데 이걸 다 제거하고 필요한 단어만 남긴다고 보시면 됩니다.

아무튼 이렇게 하시면 Search index를 만들 수 있습니다. 끝









Q. Atlas만 되는건가요?

A. 다른 DB호스팅 서비스들도 이런 유사한 기능이 있을겁니다.



Search index 이용해서 검색요청하는 법





app.get('/search', (요청, 응답)=>{
```
 var 검색조건 = [
   {
     $search: {
       index: '님이만든인덱스명',
       text: {
         query: 요청.query.value,
         path: '제목'  // 제목날짜 둘다 찾고 싶으면 ['제목', '날짜']
       }
     }
   }
 ]
 console.log(요청.query);
 db.collection('post').aggregate(검색조건).toArray((에러, 결과)=>{
   console.log(결과)
   응답.render('search.ejs', {posts : 결과})
 })
})
```
aggregate() 함수를 쓰는데 이건 검색조건 여러개를 붙이고 싶을 때 유용한 함수입니다.

aggregate() 안에 [ {검색조건1}, {검색조건2} ... ] 이렇게 조건을 여러개 집어넣을 수 있습니다.

지금은 하나만 집어넣어봄

그리고 연산자인 $search를 넣으면 search index에서 검색이 된다고 하는군요.

뭔가 길어보이지만 search index쓰는 방법을 그대로 카피해서 썼을 뿐입니다. 이것도 원리이해보다는 복붙의 영역임



아무튼 저렇게 쓰시면 '글쓰기' 라고 검색했을 때 '글쓰기합니다~' 이런 문장들도 잘 검색해줍니다. 끝   


-------


여러가지 검색용 연산자


```
var 검색조건 = [
    {
      $search: {
        index: '님이만든인덱스명',
        text: {
          query: 요청.query.value,
          path: '제목'  // 제목날짜 둘다 찾고 싶으면 ['제목', '날짜']
        }
      }
    },
   { $sort : { _id : 1 } },
   { $limit : 10 },
   { $project : { 제목 : 1, _id : 0 } }
]
```

aggregate() 안에 [ {검색조건1}, {검색조건2} ... ] 이렇게 여러개 넣을 수 있댔는데

그래서 여러개 저렇게 넣으시면 됩니다.

$sort를 쓰면 결과를 정렬해서 가져옵니다. _id를 오름차순으로 정렬해주세요~ 라고 썼습니다.

$limit을 쓰면 결과를 제한해줍니다. 맨위의 10개만 가져오라고 시켰습니다.

$project를 쓰면 찾아온 결과 중에 원하는 항목만 보여줍니다. 0은 안보여주고 1은 보여주라는 뜻입니다. 위의 코드는 _id는 빼고 제목만 가져오겠군요.

이 외에도 백만개의 $연산자가 있다고 합니다.

이걸 다 어떻게 외움 필요할 때 찾아서 씁니다.


-----


### 회원 기능을 포함한 게시판 기능


회원들이 자유롭게 게시물을 올릴 수 있다면 그것이 게시판아니겠습니까 만들어봅시다.

근데 게시판 기능은 이미 다 만들어놨는데요

CSS 디자인만 게시판이 아닐 뿐 write/list 페이지 보니까 게시판 맞습니다.

다만 지금은 누구나 게시물을 삭제가 가능한데 이걸 본인 글만 삭제가능하게 제한을 두면 되겠습니다.

그러려면 유저가 몇명 필요해서 일단 회원가입기능부터 만들어봅시다.











회원가입기능 어떻게 만들죠



이런건 알아서 만들 수 있지 않겠습니까

그냥 form 만들고 거기다가 아이디/비번 입력할 수 있게 만듭니다.

그리고 전송 누르면 서버로 보내고, 그걸 DB에 저장시키면 끝 아니겠습니까.

여기까지 배운 이상 여러분이 혼자 못만들 기능은 없습니다.





그래서 저는 login.ejs에 가입창을 하나 만들어놨습니다.


(login.ejs)
```
<div class="container mt-4">
 <form action="/register" method="POST">
   <div class="form-group">
     <label>아이디</label>
     <input type="text" class="form-control" name="id">
   </div>
   <div class="form-group">
     <label>비번</label>
     <input type="password" class="form-control" name="pw">
   </div>
   <button type="submit" class="btn btn-danger">가입</button>
 </form>
</div>

```
실은 로그인창이랑 똑같음 근데 /register로 POST요청하는 것만 다릅니다.



아무튼 이거 전송하면 입력한 아이디와 패스워드로 가입이 되도록 합시다.

그럼 서버에다가 코드를 어떻게 짭니까.

알아서 해보도록 합시다.

알아서 하셨습니까

```
app.post('/register', function (요청, 응답) {
  db.collection('login').insertOne({ id: 요청.body.id, pw: 요청.body.pw }, function (에러, 결과) {
    응답.redirect('/')
  })
})
```

저는 누군가 /register로 POST 요청을 하면

login이라는 컬렉션에다가 게시물하나를 추가하라고 했습니다.

{id : 입력한아이디, pw : 입력한패스워드} 이런 게시물이 저장되겠네요.

그리고 _id는 자동으로 부여되는걸 그대로 사용할겁니다.





그럼 이제 아이디/비번을 tester/1234 이렇게 입력하고 가입버튼을 누르면

MongoDB Atlas에 이런 식으로 저장이 되어있겠군요

![20220425_121616](/assets/20220425_121616.png)

별거 아닙니다







Q. 회원의 _id는 왜 0,1,2 이런 숫자로 만들어서 저장안하죠?

A. 원래 이런걸 Auto increment 이용해서 정수로 넘버링을 해서 저장할 필요는 없습니다.

SQL의 잔재 이런건데.. 실은 정수로 번호매기는 기능이 필요한 경우는 정말 없기 때문입니다.

회원 번호를 정수로 만들어버리면 총 회원이 몇명인지 이런것도 유추하기 쉽겠고 장점이 없어보입니다.

생각해보십시오 굳이 글번호, 회원번호를 정수로 기록해둘 이유가 없지않습니까. 있으면 알려주십시오

----



(참고1) 아이디 중복체크는 어떻게할까요?

당연히 DB에 저장시키기 전에 한번 검사를 거치는게 좋겠군요.

1. 만약 DB에 id가 test인게 이미 있으면 가입안된다고 메세지를 띄우기

2. 그게 아니면 DB에 저장시키기   

이게 끝일 것 같은데요 여러분 if문법 아시지 않습니까. 모른다면 자바스크립트를 공부할 때입니다.



(참고2) 아이디는 알파벳과 숫자로 구성되어있는지 이런건 어떻게 검사할까요

자바스크립트 잘하시면 프론트엔드에서도 거를 수 있지만

서버에서도 입력한 아이디가 이상한 문자면 걸러주는 코드를 작성해두는게 좋습니다. 역시 if문이 필요합니다.

이거 말고도 비번 길이라든지 여러가지 제약을 걸어도 되겠죠?



(참고3) 간단히 보여드리기 위해 암호화는 안했으나

비밀번호를 저장할 땐 난수로 바꿔서 DB에 저장하고 로그인시에도 난수로 바꿔서 비교하셔야합니다.

이것도 쉽게 암호화해주는 라이브러리들이 매우 많습니다.


------

글 주인만 삭제가능하게 만들어봅시다



지금은 글발행할 때 제목, 날짜, _id 이것만 저장하고 있습니다.

그러면 안되겠군요. 누가 발행했는지도 함께 저장해야 나중에 주인만 삭제가능하게 만들 수 있지 않을까요.




 ![20220425_121707](/assets/20220425_121707.png)


 ▲ 그래서 작성자라는 항목에 작성자의 _id를 집어넣는겁니다.

이건 여러분의 글발행하는 코드를 고치면 됩니다.

요청.user 하면 로그인한 유저의 개인정보들이 가득 담겨있다고 했죠?

(이 정보들은 deserializeUser() 이 함수에서 제공하고 있고요)

그럼 글 발행할 때 요청.user._id 이것도 저장하면 됩니다. 끝



이거 말고도 유저의 _id, 아이디명, 이름 있으면 유저 이름도 함께 저장하면 좋습니다.

근데 여기서 궁금한 점이 하나 생깁니다.

Q. 유저 아이디와 _id 이런거 동시에 저장할 필요 없는거 같은데여?
넹 맞습니다 유저의 _id를 알면 다른 컬렉션에서 조회해보면 아이디를 알 수 있으니까

유저의 _id만 저장해두면 끝 아니겠습니까.



근데 싫습니다. 전부 게시물과 함께 저장해버릴거임

게시물에다가 유저이름, 아이디 이런걸 다 저장해두면 이게

글쓴이 이름과 아이디가 필요해질 때 다른 컬렉션을 굳이 검색할 필요가 없기 때문에

DB 검색횟수를 줄일 수 있어서 성능적으로 이득이라 그렇습니다. 다만 하드용량은 늘어나겠지만요.

하드용량을 희생해서 검색성능을 높일 수 있다면 그게 이득 아니겠습니까.



이걸 denormalizing이라고 하는데 NoSQL 데이터베이스들은 항상 이런 식으로 데이터를 저장하는걸 권장합니다.

그래서 자주 바뀌지 않는 아이디 이런 정보들은 필요한 게시물들에 함께 저장해두면 좋습니다.

단점 : 나중에 유저 아이디를 바꾸고 싶어하면 그걸 쓰고 있는 게시물들을 다 찾아서 바꿔줘야하겠군요. 이게 단점입니다.  

옛날에 SQL하던 분들은 싫어할 수 있습니다.

따로 denormalizing 검색해보시면 여러 관습들을 배울 수 있습니다.



그래서 게시물 발행하는 POST 요청처리하는 코드를 이렇게 바꿨습니다.

한 곳 바꿈


```
app.post('/add', function (요청, 응답) {
  console.log(요청.user._id)
  응답.send('전송완료');
  db.collection('counter').findOne({ name: '게시물갯수' }, function (에러, 결과) {
    var 총게시물갯수 = 결과.totalPost;
    var post = { _id: 총게시물갯수 + 1, 작성자: 요청.user._id , 제목: 요청.body.title, 날짜: 요청.body.date }
    db.collection('post').insertOne( post , function (에러, 결과) {
      db.collection('counter').updateOne({ name: '게시물갯수' }, { $inc: { totalPost: 1 } }, function (에러, 결과) {
        if (에러) { return console.log(에러) }
      })
    });
  });
});
```

▲ 게시물 저장할 때 { 작성자 : 요청.user._id } 이것도 저장하라고 바꿨습니다.

심심하면 날짜 이런것도 저장하셈

자바스크립트로 new Date() 이렇게 쓰면 그 자리에 날짜데이터가 남습니다. 그거 그대로 DB에 저장하면 날짜 저장 끝임



게시물 삭제기능 업그레이드



지금은 개나소나 삭제가 가능한데

내 게시물만 삭제 가능하도록 만들려면 삭제기능을 어떻게 바꿔야되겠습니까.

7번 게시물을 삭제하라~라는 요청이 들어오면

1. 지금 삭제요청중인 유저의 요청.user._id를 까봐야하지 않을까요?

2. 그리고 그게 7번 글에 저장되어있는 작성자 정보랑 일치하면 삭제해야합니다.




```
app.delete('/delete', function (요청, 응답) {
    요청.body._id = parseInt(요청.body._id);
    //요청.body에 담겨온 게시물번호를 가진 글을 db에서 찾아서 삭제해주세요
    db.collection('post').deleteOne({_id : 요청.body._id, 작성자 : 요청.user._id }, function (에러, 결과) {
      console.log('삭제완료');
      console.log('에러',에러)
      응답.status(200).send({ message: '성공했습니다' });
    })
});
```
▲ 삭제요청할 때 예전엔 { _id : 요청.body._id } 이거 글번호만 확인하라고 해놨는데

{ 작성자 : 지금로그인한사용자의_id } 이것도 가지고 있으면 삭제하라고 업그레이드 해놨습니다.

그러면 사용자1은 사용자2가 발행한 게시물 삭제가 불가능합니다.







응용1. 삭제말고 글 수정기능은요? 그것도 여러분이 한번 해보십시오.

응용2. 삭제버튼이 안보이게 하려면? 그건 프론트엔드에서 처리해야겠는데얌

원하는 게시물은 button을 안보이게 처리하면 되는데 그건 자바스크립트 잘하면 될 것 같기도 합니다.

응용3. 이외에도 직접 악성유저가 되어서 여러가지 조작을 해봅시다.

삭제 버튼을 2번 빠르게 누르면?

글쓸 때 제대로 제목과 내용을 안넣으면?

로그인 안하고 조작하려하면?

그럼 앞으로 어떤 코드를 더 짜야할지 자연스럽게 알게 됩니다.

이런게 보안잡는거지 보안은 어렵고 그런거 아닙니다.


--------


### router 폴더와 파일을 만들어 API들 관리하기


실제 사이트를 개발하실 땐 app.get() app.post() 이런 코드가 100개 200개가 넘어갑니다.

그럼 다른 파일로 관리하고 싶은 욕구가 저절로 샘솟는데 그건 어떻게 하는지 알아봅시다.





연습용으로 URL route 2개를 만들었습니다.



연습용으로 두개를 만들어놓고 시작합시다. 여러분도 빨리 똑같이 따라 적어보시길 바랍니다.
```
app.get('/shop/shirts', function(요청, 응답){
   응답.send('셔츠 파는 페이지입니다.');
});

app.get('/shop/pants', function(요청, 응답){
   응답.send('바지 파는 페이지입니다.');
});
```
이제 이 route들을 다른 파일에서 관리해보도록 합시다.


route 보관용 폴더와 파일을 하나 만들어줍니다.


![20220425_122624](/assets/20220425_122624.png)

server.js와 나란한 곳에 routes라는 폴더를 만들고 그 안에 shop.js라는 파일을 만들어줍니다.

이제 shop.js 라는 파일에 저 코드들을 다 복붙할 것입니다.

왜 shop.js냐고요? 지금 route 경로들 보시면 다 shop으로 시작하니까 제 맘대로 이름지었습니다.

근데 그냥 복붙하면 끝이 아니라 Node express가 권장하는 스페셜한 방법으로 해보도록 합시다.


shop.js에 다음 코드를 따라 작성합니다.



일단 따라 적으십시오.

(shop.js)
```
var router = require('express').Router();

router.get('/shop/shirts', function(요청, 응답){
   응답.send('셔츠 파는 페이지입니다.');
});

router.get('/shop/pants', function(요청, 응답){
   응답.send('바지 파는 페이지입니다.');
});


module.exports = router;
```
뭘 적은거냐면 express라는 라이브러리가 제공하는 Router() 기능을 가져다 쓰고 있는 것입니다.

그냥 라우트들을 관리할 수 있게 도와주는 일종의 함수이며

이 함수의 도움을 받으면 이전에 app.get()하던 형식 똑같이 그대로 shop.js파일에도 작성 가능합니다.



방금 만든 것 처럼 URL route들을 이리저리 안내해주는 파일을 라우터라고 칭하며

그리고 파일 최하단에서 작성한 라우터를 module.exports 라는 문법을 이용해 배출해줍니다.

그럼 이제 이 라우터를 server.js에 적용하는 일만 남았습니다.  



Q. module.exports가 뭡니까




문법설명들어갑니다.

일단 Node.js 환경에서 JS파일들을 불러와서 쓸 수 있는데 그 문법이 바로 require() 이것과 module.exports 이것입니다.




```
 module.exports = 변수명;

```
JS파일 하단에 이렇게 쓰시면 다른곳에서 쓸 수 있게 변수를 내뿜어줄 수 있습니다.

함수도 가능합니다.


```
require('./파일경로');
```
이렇게 쓰시면 다른 파일을 불러올 수 있습니다. 그 불러온 파일이 내뿜은 변수를 가져다 쓸 수 있습니다.

(혹은 파일경로 대신 npm으로 설치한 라이브러리 명을 써도 됩니다)

근데 파일경로는 항상 ./ 부터 시작합니다. 이 쩜슬래시 기호는 현재경로라는 뜻입니다.

자바스크립트 신문법인 import / export 문법으로 바꿔서 쓸 수 도 있습니다. 그건 알아서 하십시오.




server.js에 라우터를 적용합시다





빨리 따라적어주십시오.

(server.js)

```
app.use('/', require('./routes/shop.js') );
app.use()는 미들웨어를 사용하고 싶을 때 쓰는 함수였습니다.
```

요청과 응답 사이에 실행되는 코드가 바로 미들웨어라고 배웠었죠?

app.use()를 사용해서 전역 미들웨어의 형식으로 라우터를 넣어주시면 라우터를 적용할 수 있습니다.

(express가 그렇게 쓰래요)



근데 예전에 했던 app.use() 코드랑 살짝 다른 측면이 있습니다.

app.use('/') 이런 식으로 URL 경로를 넣어줬습니다.

이게 뭐냐면 미들웨어를 조건부로 실행하고 싶을 때 쓰는 문법입니다.

누군가 /post 경로로 요청하면 실행할 미들웨어는 app.use('/post', 미들웨어명)

누군가 /list 경로로 요청하면 실행할 미들웨어는 app.use('/list', 미들웨어명)

이렇게 사용할 수 있습니다.





그래서 / 경로로 접속하면 shop.js라는 라우터를 적용하겠습니다~라고 방금 적으신겁니다.

(require는 아까 배웠던 다른 JS파일 첨부하기 문법이죠? 첨부하면 이제 router라는 변수를 가져와서 미들웨어처럼 실행해줍니다)

아무튼 위의 예제처럼 작성하면 고객이 /shop/shirts 그리고 /shop/pants로 접속시

shop.js라는 라우터가 라우팅을 해주게 되며, 실제 테스트해보시면 응답메세지가 잘 뜹니다.

URL route들 다른 파일로 관리하기 끝!


URL을 단축시킬 수도 있습니다.



이런 식으로 코드를 수정해도 잘 된다는 소리입니다.

(server.js)
```
app.use('/shop', require('./routes/shop.js') );

(shop.js)

var router = require('express').Router();

router.get('/shirts', function(요청, 응답){
  응답.send('셔츠 파는 페이지입니다.');
});

router.get('/pants', function(요청, 응답){
  응답.send('바지 파는 페이지입니다.');
});

module.exports = router;
```
server.js와 shop.js의 URL 경로를 저렇게 3곳을 바꿨습니다. 이래도 잘 됩니다.

server.js 에서는 "누군가 /shop 경로로 접속하면 shop.js 라우터를 사용해주세요"

shop.js 에서는 "/shop이후 /shirts로 접속하면 셔츠파는 페이지라고 응답해주세요"

라고 작성한 것입니다.



이렇게 하면 장점은..

1. 이건 /shop에 관련된 route들이구나~! 라고 보기가 쉬워집니다.

2. /shop과 관련된 route들에만 미들웨어를 적용하고 싶을 때도 매우 편리해집니다.


--------


연습삼아 이것도 한번 분리해보십시오



(server.js)
```
app.get('/board/sub/sports', function(요청, 응답){
   응답.send('스포츠 게시판');
});

app.get('/board/sub/game', function(요청, 응답){
   응답.send('게임 게시판');
});
```
위의 두개의 route도 한번 다른파일로 분리해보십시오. 답은 강의에 있습니다.











/shop과 관련된 route들에 미들웨어를 적용하고 싶다면



그러니까 /shop과 관련된 페이지들을 방문하기 전 로그인했는지 검사를 해주고 싶으면 어떡하죠?

예전에 로그인 배울 때 로그인했니라는 미들웨어를 적용했었죠?




```
app.get('/mypage', 로그인했니, function(요청, 응답){
   응답.send('마이페이지인데요');
});
```
▲ 이렇게 작성했던 기억이 납니다.



그럼 /shop 관련된 라우트들에도 위의 예제처럼 똑같이 미들웨어를 적용하실 수 있습니다.  

(shop.js)
```
var router = require('express').Router();

function 로그인했니(요청, 응답, next) {
  if (요청.user) { next() }
  else { 응답.send('로그인 안하셨는데요?') }
}
router.get('/shirts', 로그인했니, function(요청, 응답){
   응답.send('셔츠 파는 페이지입니다.');
});

router.get('/pants', function(요청, 응답){
   응답.send('바지 파는 페이지입니다.');
});

module.exports = router;
```
▲ 이렇게 똑같이 하면 이제 로그인한 사람만 /shop/shirts 페이지를 접속할 수 있습니다. 확인해보십쇼.


혹은 라우터 파일 내에 있는 전체 route에 다 적용하고 싶으면 이렇게 쓰시면 됩니다.

(shop.js)
```
var router = require('express').Router();

router.use(로그인했니);

function 로그인했니(요청, 응답, next) {
  if (요청.user) { next() }
  else { 응답.send('로그인 안하셨는데요?') }
}
router.get('/shirts', function(요청, 응답){
   응답.send('셔츠 파는 페이지입니다.');
});

router.get('/pants', function(요청, 응답){
   응답.send('바지 파는 페이지입니다.');
});

module.exports = router;
```
▲ 이렇게 router.use(로그인했니); 라고 적어주시면 밑에나온 모든 라우트들에 미들웨어를 적용해줄 수 있습니다.

혹은 router.use('/shirts', 로그인했니); 이렇게 하시면 /shirts에 접속할 때만 로그인했니라는 미들웨어를 적용할 수 있습니다.

----


-----
### Google Cloud로 5분만에 내 사이트 배포하자 ($300 무료 크레딧)


(변동사항이 많아서 글로 진행합니다)



이제 부끄럽게도 여러분이 만든 서버를 웹에 공개할 시간입니다.









배포 전 여러분 프로젝트 확인사항 :



1. 여러분 프로젝트 폴더에 app.yaml파일을 하나 만들어줍니다.

app.yaml 파일은 구글 클라우드 배포시 프로젝트 설정 등을 내포한 파일입니다.

에디터를 이용해 server.js랑 동일한 위치에 app.yaml 파일을 하나 만드시면 되겠습니다.

그리고 다음 코드를 복붙합니다.

 ```

runtime: nodejs
env: flex

manual_scaling:
  instances: 1
resources:
  cpu: 1
  memory_gb: 0.5
  disk_size_gb: 10

```
위 코드는 구글에서 샘플로 보여주는 app.yaml 파일 예시입니다.

그대로 따라 적으면 되겠습니다. 서버의 CPU, 메모리 용량도 셋팅 가능합니다.

위 예시는 돈많이 안쓰려고 극 저용량으로 셋팅한 예시입니다.

(CPU두개에 메모리 4GB는 되어야 보통 사이트를 운영할 만 합니다.)



실제 사이트 운영하시려면 맨 위 두줄만 적어보셔도 됩니다.  

구글이 알아서 트래픽에 따라 서버 크기와 사양을 늘려줍니다.



다만 instances : 1 이게 아닌 경우 구글이 서버컴퓨터를 여러대 돌리면서 get post요청을 분산처리해줍니다.

지금 강의에선 로그인 세션정보를 서버의 램에 저장하고 있는데

로그인은 A서버가 처리해줬는데 했었는데 post요청을 B서버가 채어가면 로그인 안되었다고 나오는 경우도 발생할 수 있습니다.

그래서 세션데이터를 db나 다른 곳에 저장하는게 안정적으로 서비스가 가능합니다.

https://github.com/googleapis/nodejs-datastore-session

이런거 찾아보셔도 됩니다



2. server.js에 서버를 띄울 때 포트가 8080인지 확인합니다.


```
app.listen 이 부분이 8080인지 확인합시다.

app.listen(8080, function() {
    console.log('listening on 8080')
  })
```
아니라면 8080으로 변경해줍시다.

왜냐면 구글클라우드에서 기본적으로 이용하는 포트가 8080입니다.

8080쓰기 싫으시면 따로 설정해주시면 되는데 귀찮으니 8080으로 맞춥니다.









3. MongoDB Atlas의 Network Access 메뉴에서 Whitelist IP를 모든 아이피에서 허용으로 변경합니다.

MongoDB Atlas 오랜만에 들어가신 후

▼ 왼쪽에서 Network Access 메뉴에서 아이피 등록하는 부분 있죠?

![20220425_123853](/assets/20220425_123853.png)


여기서 모든 아이피 (0.0.0.0)에서 DB 접속을 허용하도록 변경해줍니다.

(혹은 Allow Access from Anywhere 버튼 클릭)

구글 클라우드에 배포한 여러분의 서버에서도 접속을 해야하니 그렇습니다.

물론 이러면 보안이 걱정되니 나중에 서버아이피 찾아와서 적거나 그러시면 됩니다.

구글 클라우드 안에서 모든걸 해결하고 싶다면 구글이 제공하는 Firestore 라는 NoSQL DB도 이용가능합니다.

지금까지 썼던 MongoDB Atlas 이것도 구글 클라우드 파트너어쩌구던데 아무튼 찾아보십시오.







 -----------






1. Google cloud platform 가입


![20220425_123913](/assets/20220425_123913.png)


cloud.google.com 혹은

구글에 구글클라우드라고 검색하신 후 들어가서 로그인까지 합시다.

그리고 시작하기 버튼을 눌러보도록 합시다.



2. 가입창 버그 해결하기

![20220425_124015](/assets/20220425_124015.png)

시작하기 버튼을 누른 후 정보등록까지 진행하시면 끝입니다.



간혹 '계속' 버튼을 눌러도 다음으로 안넘어가는 버그가 있을 수 있습니다

https://cloud.google.com/gcp/getting-started/?hl=ko

버그가 있을 땐 여기서 가입 진행해주시면 됩니다.









▼ 그리고 여기서 무료로 사용 or 활성화 버튼을 눌러서 카드 등록까지 마치십시오.

![20220425_124102](/assets/20220425_124102.png)

필히 카드를 하나 등록하셔야 서비스 이용이 가능하며 등록하면 무료 크레딧 $300을 줍니다. (사용기간 3개월)

- 아마존처럼 자동으로 과금되진 않습니다. 여러분 승인이 있어야 자동과금됩니다.









3. 새로운 프로젝트를 만들거나 기존 프로젝트를 선택합니다.








상단에 프로젝트 선택하는 드롭다운 메뉴가 있는데 여기서 프로젝트를 하나 고르시거나 만드시면 됩니다.

하나 새로 만드시면 프로젝트 이름이랑 ID를 예쁘게 맘대로 설정가능합니다.

(기본적으로 My First Project가 하나 만들어져있는데 그거 쓰셔도 됩니다)

 ![20220425_124142](/assets/20220425_124142.png)



상단에 프로젝트 선택하는 드롭다운 메뉴가 있는데 여기서 프로젝트를 하나 고르시거나 만드시면 됩니다.

하나 새로 만드시면 프로젝트 이름이랑 ID를 예쁘게 맘대로 설정가능합니다.

(기본적으로 My First Project가 하나 만들어져있는데 그거 쓰셔도 됩니다)











4. 왼쪽 메뉴에서 App Engine을 선택한 후 애플리케이션 만들기를 진행합시다.

 ![20220425_124258](/assets/20220425_124258.png)

 App Engine 이라는게 여러분이 만든 웹서버 배포할 수 있는 상품이라고 보시면 됩니다.

아무튼 application 만들기 쭉 따라하시면 됩니다.



Region 선택시 서울로 위치를 설정합시다. (asia-northeast3) 서울 없으면 일본 이런거 하셈

여러분이 사용할 서버용 컴퓨터를 한대 구매하는거라고 보시면 되는데

그 컴퓨터가 물리적으로 가까워야 응답시간이 줄어듭니다.



서버에 있는 HTML 파일이 무슨 위성 전파를 타고 오는게 아니라 광케이블을 타고 빛의 속도로 이동하는데

빛의 속도로 미국에서 한국까지 이동해도 최소 150ms 정도 소요됩니다.

그래서 미국에 있는 HTML 파일을 가져올 땐 요청 & 응답이 이루어져야하니 최소 300ms 는 지연되고 시작하는 겁니다.

그래서 여러분이 보는 미국 야동사이트들이 느린것이고

미국인들과 실시간 FPS게임을 즐길 수 없는 이유입니다.





그래서 국내 서비스를 할거라면 네이버 클라우드, cafe24 등을 이용하는 것도 좋은 옵션인데

이제 구글이나 아마존도 서울서버 제공하니까 뭐 암튼 그렇습니다.

근데 서울같은 변두리 지역은 요금이 미국 이런 곳보다 약간 비쌉니다.

![20220425_124324](/assets/20220425_124324.png)

- 환경은 당연히 Node.js, 표준으로 설정하시면 됩니다.

그럼 끝입니다. SDK 어쩌구 뭘 다운받으라고 하네요. 다운받읍시다.













5. 배포를 위해 Cloud SDK라는 프로그램을 다운로드하고 설치까지 합니다.



Cloud SDK 설치파일을 다운받습니다.

![20220425_124348](/assets/20220425_124348.png)
![20220425_124401](/assets/20220425_124401.png)

이런게 안뜬다면 구글에 google cloud SDK 검색해서 설치하셔도 됩니다. https://cloud.google.com/sdk?hl=ko

설치과정에서의 어려움은 없을테니 뭐 건드리지말고 그냥 쭉 넘어갑시다.

맥북을 쓰신다면 설치 방법이 약간 복잡할 수 있으니 위 링크의 튜토리얼 잘 따라하시길 바랍니다.  

맥 설치시 python2.7이 없다고 나오면 구글에 검색하여 설치하시면 됩니다.



6. 여러분 여태까지 만든 프로젝트 폴더를 VScode 에디터로 오픈한 뒤 터미널을 엽니다.



빨리 오픈하십시오.



6-1. 그 다음에 터미널에 gcloud init 이라고 입력합니다.
```
gcloud init
```
gcloud 명령어를 찾을 수 없습니다 그렇게 나오면 설치가 제대로 되지 않은 것입니다.

(혹은 윈도우라면 시작 - 검색 - cmd 에서 실행해보시길 바랍니다)





6-2. 구글 계정으로 로그인합니다.
```
To continue, you must log in. Would you like to log in (Y/n)? Y
```
Y를 입력하면 됩니다.

당연히 구글 클라우드 플랫폼 개설한 구글아이디로 로그인하십시오.





6-3. 원하는 프로젝트를 선택합니다. (프로젝트가 하나면 안나옴)
```
Pick cloud project to use:
[1] [my-project-1]
[2] [my-project-2] ...
Please enter your numeric choice:
```
여러분이 클라우드 플랫폼에서 만든 프로젝트 중 하나를 택하라고 합니다.

숫자를 입력해서 택하시면 됩니다.

끝입니다. 뭔가 해커가 된 느낌입니다.









7. 터미널에 다시 gcloud app deploy라고 입력합니다.


```
gcloud app deploy
(여러분 작업폴더에서 터미널을 여신후 이 명령어를 입력하십시오 제발!)
```

![20220425_124509](/assets/20220425_124509.png)

그럼 이상한 안내문이 뜨는데 여러분이 배포할 소스파일, 이름, url 등을 알려줍니다.

(target url이 여러분 사이트 주소입니다)

source : 어쩌구 부분이 여러분 작업폴더가 맞으면 y를 입력합니다.

이제 구글 AI가 우리 프로젝트 뭔지 분석하고 npm install도 해주고 알아서 다 해줍니다.

AWS ec2였다면 인스턴스 생성부터 시작해서 어려운거 하라그러고 개발이 처음이라면 불편한 점이 많았을 텐데

구글 클라우드 서비스는 알아서 다 해줍니다. 5~10분 기다리는 것 밖에 할 일이 없습니다.

뭔가 서비스 개발에 집중할 수 있고 좋음









8. 에러가 뜨면 해결합니다.  



보통 에러메세지가 뜨면 구글 검색하시면 대부분 쉽게 해결가능합니다.

하지만 AWS 이런거보다 검색결과가 적어 문의 채팅 보내는게 더 빠를 수 있습니다.

대표적인 에러 몇개만 봅시다.





0. app.yaml 파일이 없어요 에러

위를 참고해서 빨리 만드십시오.



1. 결제가 안되었습니다 에러

에러 메세지에 Billing Must be Enabled~ 카드 등록이 안되었어요~ 결제 계정 등록이 안되었어요~ 그러면 빨리 구글 클라우드 홈으로 가서 카드를 등록하십시오



2. MongoDB 연결 에러

DB 접속 어쩌구가 안된다고 하면 MongoDB Atlas로 가서 왼쪽 Network Access 에서 IP whitelist를 모든 아이피 접속가능하도록 등록하십시오.



3. deploy중 계속 멈춰있는 에러 (Updating Service [default]...)

대부분 2번 문제입니다. MongoDB Atlas에서 Network Access - 모든 IP가 접속가능하도록 바꿔주십시오.

혹은 진짜 에러메세지는 좌측 App Engine - 대시보드 - 하단에서 구경가능합니다.


![20220425_124538](/assets/20220425_124538.png)


MongoDB 어쩌구라면 95% 확률로 2번과 동일한 문제입니다.













9. 사이트 어떻게 접속하나요?



배포 완료하면 터미널에 여러분 사이트 주소 뜹니다.

까먹으면 여러분 구글 클라우드 플랫폼 - 좌측 App Engine - 대시보드에 가면 주소 나옵니다.











10. 업데이트는 어떻게하나요?



위의 gcloud init, gcloud app deploy 하던걸 똑같이 반복하시면 됩니다.  











11. 테스트용이지만 과금이 두렵습니다. 어떻게 완전 삭제합니까?



어짜피 자동과금 안되니까 걍 냅두세요.

일시정지하려면 좌측 App Engine - 설정 - 어플리케이션 사용중지 누르시면 됩니다.

(데이터 보관 비용은 쪼끔 청구될 수도 있을 듯 합니다)

아예 삭제하려면 파란 상단메뉴에서 원하는 프로젝트 선택 - 좌측 메뉴 IAM 및 관리자 - 설정 - 삭제 누르시면 됩니다.


![20220425_124603](/assets/20220425_124603.png)

구글 클라우드 만으로도 충분히 웹서비스 구현이 가능합니다.

AWS에 비해선 사용자가 적어 참고문헌(구글검색결과..) 등은 떨어질 수 있으나

초심자에게 매우 쉬운 인터페이스와 사용법을 제공하고 있습니다.

그리고 AWS에 비해 모든게 자동화되어있어서 초보자에게 특히 좋습니다.  

실은 AWS에도 Elastic Beanstalk 쓰시면 이거랑 비슷하게 쉽게 배포가 가능한데 구글이 더 쉽습니다. 그래서 구글 주식을 일단 샀고

국내서비스 중에 네이버 클라우드도 초심자 친화적이니 한번 고려해보십시오.



 ---------


### 이미지 업로드 & 이미지 서버 만들기



무슨 사이트를 운영하든 이미지를 업로드하고 보여줄 일이 많습니다.

이미지는 어떻게 어디에 저장해야하는지 알아보도록 합시다.

이미지는 그냥

1. server.js 근처에 폴더를 하나 만들어서 거기 저장하거나

2. 아마존 이런데서 하드를 구매해서 거기로 저장하거나 (Amazon S3)   

3. DB에 직접 저장하거나 합니다.

하지만 3번은 너무 느리거나 비싸거나 용량문제 때문에 보통 1, 2번 방법을 씁니다.

그리고 이미지를 누가, 어디에, 어떤 이름으로 업로드했는지 같은 메타 정보들은 DB에 저장하는게 일종의 웹개발 관습입니다.  아무튼 우린 1번으로 배워보도록 합시다.

저장할 이미지가 백만개라면 2번으로 하셔야합니다. 구글에 튜토리얼 100만개 있음











일단 이미지 업로드할 수 있는 페이지를 하나 만들어줍니다



이 새로운 페이지엔 업로드버튼과 전송버튼만 있으면 됩니다.

그냥 upload.ejs 파일을 이렇게 만들어주시고

upload.ejs)
```
<form method="POST" action="/upload" enctype="multipart/form-data" >
    <input type="file" name="프로필">
    <button type="submit">전송</button>
</form>
```
(참고로 enctype은 보내는 파일의 인코딩형식이며 파일, 이미지업로드시엔 multipart 어쩌구라고 적어주시는게 좋습니다)







서버는 하단과같이 작성해서 /upload로 방문시 upload.ejs를 보여주도록 합시다.

(server.js)
```
app.get('/upload', function(요청, 응답){
  응답.render('upload.ejs')
});
```
이젠 이런건 발로도 하죠?



업로드한 이미지를 하드에 저장합시다



사용자가 업로드한 이미지는 그냥 우리 서버돌리는 컴퓨터에 그대로 저장을 해보도록 합시다.

우리 작업폴더안에 public/image라는 폴더를 하나 만들어서 거기다가 다 몰아넣을겁니다.

그 일을 쉽게하려면 일단 라이브러리가 하나 필요합니다.



터미널 키셔서
```
npm install multer
```
라고 입력해줍니다.

위 라이브러리는 multipart/form-data를 통해 업로드된 파일을 매우 쉽게 저장, 이름변경, 처리할 수 있게 도와주는 라이브러리입니다.



그리고 설치가 끝났으면 server.js에서 multer 셋팅을 이렇게 해주시면 됩니다.
```
let multer = require('multer');
var storage = multer.diskStorage({

  destination : function(req, file, cb){
    cb(null, './public/image')
  },
  filename : function(req, file, cb){
    cb(null, file.originalname )
  }

});

var upload = multer({storage : storage});
```
require 어쩌구는 multer 설치한거 갖다쓰겠습니다~ 라는 뜻이고

그 밑에는 전부 셋팅입니다. 이런건 라이브러리 사용법일 뿐이라 이해의 영역이 아닙니다. 암기와 복붙의 영역입니다.



1. diskStorage라는 함수를 쓰면 업로드된 파일을 하드에 저장할 수 있습니다. memoryStorage라고 쓰시면 하드 말고 램에 저장할 수 있습니다 (휘발성)

2. destination : 업로드된 파일을 하드 어떤 경로에 저장할지 정하는 부분입니다. 알아서 정하십쇼

3. filename : 파일의 이름을 결정하는 부분입니다. 저장할 때 어떤 이름으로 저장할겁니까. file.originalname이라고 쓰면 그냥 원본 그대로라는 뜻입니다.



나중에 file.originalname + '오늘날짜~' 이런 식으로 저장하면 중복없이 유니크하게 저장할 수도 있겠군요?



4. 그리고 마지막줄에서 var upload라는 변수를 만들고 multer 셋팅을 다 저장해주시면 됩니다. 끝!



업로드한 파일의 확장자 필터로 원하는 파일만 거르는 법


```
var path = require('path');

var upload = multer({
    storage: storage,
    fileFilter: function (req, file, callback) {
        var ext = path.extname(file.originalname);
        if(ext !== '.png' && ext !== '.jpg' && ext !== '.jpeg') {
            return callback(new Error('PNG, JPG만 업로드하세요'))
        }
        callback(null, true)
    },
    limits:{
        fileSize: 1024 * 1024
    }
});
```

▲ 셋팅하는 부분 안에 fileFilter라는 항목을 추가해주시면 됩니다.

path라는 변수는.. nodejs 기본 내장 라이브러리 path 라는걸 활용해 파일의 경로, 이름, 확장자 등을 알아낼 때 사용합니다.

위의 예제에서는 업로드한 파일의 확장자를 알아내서 png랑 맞는지 비교하는 과정입니다.

limits는 파일의 사이즈 제한을 걸고 싶을 때 씁니다. 1024 * 1024는 1MB를 뜻합니다.


셋팅이 완료되었으면 누군가 폼으로 이미지를 전송할 때 실행해보도록 합시다.



그건 역시나 server.js에다가 app.post 어쩌구 하면 되겠습니다.
```
app.post('/upload', upload.single('프로필'), function(요청, 응답){
  응답.send('업로드완료')
});
```
근데 미들웨어처럼 실행시켜주시면 됩니다.

미들웨어는 요청과 응답 사이에 실행하는 코드랬죠?

누군가 /upload로 POST 요청을 하면 upload.single('input의name속성') 을 실행시키시면 됩니다.

그럼 multer 셋팅한대로 알아서 지가 업로드한 파일을 처리해줍니다.





* input의 name속성 적으라는 곳에는 파일 업로드시킬 input의 name 속성명을 진짜로 적으시면 됩니다.



그럼 /upload 페이지 들어가서 실제 사진 업로드 테스트해보십시오.

전송버튼까지 누르면 업로드한 사진이 public/image 폴더 안에 저장됩니까?

저장이 잘 됩니다. 성공!



업로드한 이미지 보여주는 법 (이미지 API 만들기)



그냥 이렇게 서버코드를 짜면 됩니다.

"누가 /image/music.jpg로 접속하면 music.jpg 파일을 보내줌"

이게 끝입니다. app.get 하면 될 것 같지 않습니까. 맞습니다.

그렇게 해놓으시면 이제 여러분
```
<img src="/image/music.jpg">
```
이렇게 HTML에 쓰면 이미지가 보입니다.









만드는 법은 이번만 알려드리겠습니다.
```
app.get('/image/:imageName', function(요청, 응답){
 응답.sendFile( __dirname + '/public/image/' + 요청.params.imageName )
})
```

누군가 /image/:파라미터 로 접속하면

/public/image/:파라미터 라는 파일을 보내주세요~ 라는 코드입니다.

그냥 일반 파일을 유저에게 보내고 싶으면 sendFile이라는 함수를 쓰면 됩니다. (강의 초반에 잠깐 보고 지나가긴 했습니다)

그리고 __dirname은 특별한 기본 변수인데 출력해보시면 그냥 현재 파일의 경로가 나옵니다.

그래서 현재 server.js 경로 + /public/image/ + 파라미터라고 입력해준겁니다. 그럼 원하는 이미지가 나오겠군요.





실제로 브라우저에서 /image/music.jpg 라고 접속하면 아까 업로드한 파일이 잘 나오네요 성공!


아마존 같은 클라우드 서비스에서 하드를 구매하셨다면 과정이 대충 이렇게 쉽습니다.

0. id가 admin인 유저가 마이페이지에서 자기 프로필 사진을 업로드합니다.

1. 그럼 서버는 뭘해야하냐면.. 이미지 저장 요청이 들어오면 아마존에서 제공하는 예제코드를 실행하시면 됩니다. 그럼 아마존 하드에 저장해줌

2. 저장이 성공하면 아마존에서 이미지 URL을 퉤 뱉어줍니다. amazon.com/image/music.jpg 대충 이렇다고 칩시다.

3, 그 amazon.com/image/music.jpg 이라는 URL을 프로필 이미지만 따로 모아놓은 MongoDB document에 { id : admin, 프로필이미지 : amazon.com/image/music.jpg } 이런 정보를 저장합니다. 이미지 URL와 이미지가 누구 것인지의 정보를 저장하는 셈이죠? 그럼 저장과정 끝!

4. 이미지 보여주기는 더 쉽습니다. 그 이미지가 필요한 페이지에선 amazon.com/image/music.jpg 이라는 URL을 DB에서 불러와서 img 태그 안에 넣기만 하시면 됩니다.



어려운거 아닙니다 ㅅㄱ


-------

### 쇼핑몰 등 실제 서비스 만들 때 자주묻는 질문들


1. Mongoose 써야하나요?



MongoDB에 데이터입출력을 하고 싶은 경우 nodejs 환경에선 2개의 라이브러리를 사용가능합니다.

- MongoDB native driver (지금까지 썼던거)

- Mongoose

둘 중 하나 택1 하면 됩니다.



두 개의 차이점은 JavaScript & jQuery의 차이와 비슷합니다.

MongoDB native driver로도 모든걸 구현 가능하지만

Mongoose를 쓰면 약간 더 짧고 편하게 쓸 수 있습니다. (함수가 약간 달라짐)





Mongoose를 쓰면 DB에 데이터를 저장하기 전에 schema라는걸 정의하셔야합니다.

title 필드엔 문자만 넣으세요

content 필드엔 문자만 넣으세요

age 필드엔 숫자만 넣으세요

이런 식으로 필드에 들어갈 내용을 정의부터 합니다.

어떤 식으로 코드를 짜는지 맛을 보자면

```
var blog = new Schema({
    title : String,
    content : String,
    Age : Number
})

var Blog = mongoose.model('Blog', blog)
```
▲ Mongoose에서 Schema 만드는 방법입니다. 그냥 대충 이렇게 먼저 코드를 짜는구나~ 라는 느낌만 가져가면 됩니다.

그럼 이제 유저가 title, content, age를 DB에 저장할 때

미리 정의한 schema와 맞는지 미리 검사할 수 있습니다.
```
var article = new Blog({
    title:'강남 우동 맛집',
    content: '돈받고 작성한 블로그 글입니다',
    age : 30
})

article.save();
```
▲ Mongoose에서 DB에 게시물 하나 저장하는 법입니다.

뭔가 코드가 짧아지고 데이터가 문자인지 숫자인지 validation 작업이 쉬워집니다.





근데 개발 초기엔  document 1개에 어떤 필드들이 들어가야할지 미리 정의하기 어려운 경우가 있습니다.

그럴 땐 Mongoose 쓰는게 귀찮을 수 있긴 하지만 결국 항상 DB에 들어갈 내용을 엄격하게 통제하는게 좋긴 합니다.


MongoDB native driver에선 저런 validation 어떻게 하냐면 그냥 if문 짜면 됩니다.

"유저가 보낸 age 데이터가 숫자 맞는지 확인하고 DB 저장해라~" 라는 if문이요.

근데 귀찮으면 MongoDB Compass 라는 프로그램을 설치하시면

Mongoose처럼 validation을 넣을 수 있습니다.


![20220425_141032](/assets/20220425_141032.png)

▲ MongoDB Compass는 Atlas 그거랑 똑같은 기능을 제공하는 DB조작 프로그램인데

Validation메뉴가 있어서 저렇게 Mongoose 식으로 추가할 수 있습니다.





Validation 쉬워지고 함수 짧아지고 그런 장점이 있으니

필요할 것 같으면 Mongoose 설치해서 써보면 됩니다.

쓰려면 DB 접속 문법부터 DB 입출력 문법도 Mongoose 식으로 바꾸셔야합니다.

-------

2. 보안 강화



보안은 어려운게 아니라 그냥 악성유저가 되어서 여러분 사이트 테스트해보시면 됩니다.



- 이상한 페이지나 URL로 요청을 하는 경우

- 버튼을 두번 누르거나 해서 중복된 요청을 하는 경우

- 회원가입시 아이디란에 한글 넣는 경우

- 필수 입력란인데 빈칸을 보내는 경우

- DB 접속시 회원 비밀번호가 그대로 1234 이렇게 노출되는 경우



그리고 헛점들을 막는 코드를 프론트엔드, 백엔드에서 작성하시면 되겠습니다.

물론 프론트엔드에 있는 자바스크립트는 누구나 위조할 수 있으니 서버에서 if문으로 거르는게 완벽한 방어책입니다.







그리고 자주 알려진 서버 공격 방법에 대한 대응책을 하나 마련해놓는 것도 좋습니다.



- 아이디 등 input 입력란에 <script></script> 혹은 db에서 정보를 꺼내는 문법을 작성할 경우

- 다른 유저의 비밀번호를 100만번 시도해서 때려맞추려고 하는 경우

- DB 접속 공용 비밀번호를 qwer1234로 때려맞추는 경우



이런 공격들이 유명한데

넘나 유명해서 express-rate-limit 라이브러리 등 쉽게 해결할 수 있는 라이브러리가 많습니다.

검색 후 필요한 것들을 적용해보시길 바랍니다.


3. 관리자기능?



무슨 서비스든 관리자 기능이 필요합니다.

관리자 기능도 만드셔야 실제 서비스 완성이라 관리자 기능도 추가해주면 되는데

예를 들어 어떤 관리자 유저는 모든 글 삭제가 가능해야합니다.

어떻게 코드를 짜야할까요?





당연히 DB에 회원정보 저장할 때

role : '관리자'

role : '일반유저'

이런 필드도 집어넣어두고

"만약에 role이 '관리자' 라도 글삭제 가능하게 해주세요"

이런 식으로 삭제기능을 업그레이드 해주면 되겠군요.  

















4. 쇼핑몰 어떻게 만드는데요



큰 프로젝트같은거 만들고 싶을 때는

크게 보면 어려워보입니다. 작은거 부터 하나하나 구현해보십시오.

그러면 매우 쉬워집니다.



(1) 상품등록페이지

팔려면 관리자가 상품 게시물 발행부터 해야합니다.



(2) 상품진열페이지

이게 있어야 상품을 어디 보여주고 그러지 않을까요.



(3) 주문기능 넣기

그냥 이것도 주문자, 날짜, 상품명, 수량 이런게 들어있는 게시물 발행입니다

무통장입금이면 그냥 주문완료하면 계좌번호만 보여주면 되겠군요



(4) 주문관리페이지

관리자는 모든 주문 게시물을 볼 수 있어야하고

유저는 나의 주문게시물을 볼 수 있어야합니다.



(5) 카드결제

카드결제는 PG사와 계약해서 PG사 결제모듈을 쓰는게 일반적입니다. (다날 같은 회사)

어렵다면 아임포트 이런 서비스 쓰면 복붙식으로 개발이 가능합니다.



(6) 기타 필요한 페이지와 기능

님들 DB와 서버에 대해 모르는거 없으니 그냥 알아서 하나씩 만들면 됩니다.








5. 하지만 실제 쇼핑몰 서비스는

![20220425_141301](/assets/20220425_141301.png)

▲ 관리자 페이지만 40개 + 유저가 보는 페이지 10개 만드셔야합니다.

정말 필요한 최소한의 페이지만 뽑아도 페이지 20개는 만들어야할걸요

혼자 다 하려면 매우 오래걸릴듯





마케팅 어떻게 할지

쿠팡에 상품등록 어떻게 할지

배송 주문 생산 재고관리는 어떻게 할지

제품촬영 운영 고객전화문의는 어떻게 할지

많은 고민이 필요합니다.





개발자 되는게 목표라면 쇼핑몰 만들어보는 것도 좋은 연습이겠으나

빠르게 물건 파는게 목표라면 임대형 쇼핑몰을 이용하는게 가장 빠른 길입니다.

네이버 스마트스토어, cafe24, nhn commerce 이런 곳에서 쇼핑몰 다 완성된거 빌려줍니다.

기능은 완성되어있으니 html css js로 프론트엔드만 슥삭 바꿔주면 됩니다.

요즘은 비용도 무료임



매출 수백억 찍는 스타일난다, 임블리 같은 곳들도

쇼핑몰 기능개발 직접하지 않았고 cafe24에서 임대해서씁니다.



재화말고 서비스 이런것도 판매가 가능하나

특이한 기능의 쇼핑몰이 필요하다면 직접 만드는 것도 좋겠군요.







6. 앞으로 더 공부해봐야할 사항들



1. 보안강화 기술들

2. ejs 말고 웹앱을 만들 수 있는 프론트엔드 기술 (Vue, React, Angular)

3. 사용자가 업로드한 이미지, 파일 다루는 방법 (이미지 리사이즈, 축소, 검열 등)

4. OAuth 소셜로그인

5. 서버 컴퓨터 메모리 터짐을 방지하기 위해 세션데이터를 서버메모리가 아니라 MongoDB에 저장하는 법



등이 있습니다.







[자주 묻는 질문 코너]



Q. 심화 내용도 배우고 싶습니다

A. 일부 분들이 다 듣고나서 더 심화 내용 없냐고 찾으시는데

지금까지 배운 1. get, post요청 처리 2. DB에 데이터 입출력 방법 알면 이론상 모든 서비스 알아서 만들 수 있습니다.

nodejs 책 보면 뭔가 더 깊은 내용 다루는 것 같지만

복잡한 것 vs 깊은 것을 잘 구분하시길 바랍니다.

"1. get, post요청 처리 2. DB에 데이터 입출력하기로 웹사이트 복잡하게 만들기"를 깊은 내용으로 오해들 많이 하십니다.

실은 심화 내용은 유저가 많아지면 어떻게 해야할지 + 코드 관리 편하게 하려면 어떻게 해야할지 그런 내용이 전부입니다.



유저가 많아지면 구글클라우드에서 자동으로 알아서 서버 용량 늘려줍니다.

개발자 입장에선 GET요청 수를 줄이거나, 이미지 크기를 줄이거나 해서 서버 비용을 줄이는 방법 같은 것도 생각해볼 수 있겠군요.

그리고 관리편하게 하기 위한 해결책은 마이크로서비스 + 컨테이너화하기가 요즘 유행인데

네이버 카카오급은 되어야하는 것들이고 강의 주제를 많이 벗어나겠군요





웹서비스 만드는데 필요한 내용은 다 가르쳐드렸으니 여러분 만들고 싶었던걸 혼자 만들어보는게 가장 좋은 학습방법입니다.

유튜브는 사람들 조회수가 높은 게시물 + 영상을 보여주는 게시판일 뿐이고

인스타그램은 내가 고른 친구들 게시물만 보여주는 게시판일 뿐이고

당근마켓은 내 근처 게시물만 보여주는 게시판일 뿐입니다



물론 "내 근처 게시물만 보여주려면 어떻게 코드를 짜야하지"

같은 새로운 내용이 필요하면 구글 검색정도면 충분합니다.

그러면 아마 유저의 위도와 경도를 DB에 게시물과 함께 저장하라는 소리를 할듯요

내가 혼자 구현을 못할 것 같은 기능은 게시판 ㄱㄱ


 ----------


### 유저간 채팅기능 만들기 1. 채팅방 만들기

이번엔 채팅기능을 만들어볼 것입니다.

근데 웹상의 거의 모든 기능들은 그냥 게시물 발행과 구현방법이 똑같습니다.

그래서 제가 계속 님들 배울거 다 배웠다고 하는 것임



Q. 회원가입기능 어떻게 만들어요?

A. 게시물 발행기능과 똑같습니다. 근데 거기에 회원 아이디 비번이 기록될 뿐



Q. 상품 무통장입금 주문기능 어떻게 만들어요?

A. 게시물 발행기능과 똑같습니다. 근데 거기에 주문자아이디, 상품명, 가격, 날짜가 들어가있을 뿐



Q. 채팅메세지는요?

A. 채팅메세지도 게시물 발행기능과 똑같습니다. 근데 카톡처럼 메세지 내용, 보낸사람, 날짜 등이 기록될 뿐입니다.

근데 하나 새로운 점이 있는데 채팅메세지는 채팅방 게시물에 종속되어야합니다.

이해를 돕기 위해 채팅과 비슷한 게시물 + 댓글만드는 법을 잠깐 배워봅시다.


댓글을 어떻게 만드냐면



게시물에 댓글기능을 추가하고 싶습니까.

그러면 댓글 게시물 발행기능을 추가하면 됩니다.

그냥 댓글 collection 하나 새로 만들어서 모든 댓글을 저장하면 됩니다.


![20220425_141533](/assets/20220425_141533.png)


▲ 근데 collection안에 대충 전부 집어넣어버리면 대체 무슨 글에 달린 댓글인지 구분이 안되겠죠?

잘 생각해보면 댓글들은 부모 게시물이 존재합니다.

모든 댓글은 부모 게시물에 달려있어야하니까요.

그것까지 기록해놔야 나중에 댓글을 불러올 때 내가 원하는 댓글만 불러올 수 있을텐데

댓글을 저장할 때 부모 게시물정보도 함께 저장하면 문제 해결일듯요

![20220425_141552](/assets/20220425_141552.png)

왼쪽 collection은 원래 개발해놨던 할일리스트 게시물들입니다.

오른쪽 collection에 댓글 게시물을 기록할 땐 어떤 할일 게시물에 속하는지도 함께 기록하는겁니다.

그러면 나중에 게시물A의 댓글만 불러오고싶을 때 "{ 부모 : '게시물A' } 가진 댓글만 가져와주세요~" 라고 query를 줄 수도 있겠네요.

이렇게 해놓으면 댓글기능 개발 끝일듯요

부모를 기록하는 작업을 전문용어로 "컬렉션끼리 관계를 맺는다~" 라고 합니다.

어떤 게시물에 종속된 게시물이 필요할 때 저런 식으로 관계를 지정해보십시오.

----


채팅기능은 어떻게 만드냐면



위에서 설명한 게시물 + 댓글이랑 똑같습니다.

카톡보시면 카톡은 일단 채팅하고 싶으면 채팅방을 고르죠?

채팅방 누르면 댓글들이 쭉 나옵니다.

그래서 그냥 글작성 + 댓글이랑 똑같은 기능입니다. (나중에 실시간업데이트 기능만 추가될 뿐임)

지칭하는 이름만 채팅방 + 메세지로 바꾸면 됩니다.

![20220425_141623](/assets/20220425_141623.png)


이런 식으로 디자인하면 이쁘겠군요.

아무튼 선생 코드 아무 생각없이 따라치면 타자실력만 늘테니

혼자서도 코드 잘 짜고 싶으시면

1. 모든 기능은 게시물 발행이랑 똑같다

2. 종속관계가 필요하면 관계를 맺으면 된다

이것만 있으면 이제 정말 혼자서도 대부분의 기능 개발할 수 있습니다.

Q. 채팅메세지 이렇게 저장하면 쉽지 않나요?

메세지를 채팅방 게시물의 필드하나에 다 밀어넣는겁니다.

![20220425_141656](/assets/20220425_141656.png)


▲이것도 가능합니다. 근데 하나의 document는 16MB 용량제한이 있어서

갯수가 많으면 하나의 게시물로 빼서 다루는게 좋습니다. 그게 나중에 수정삭제도 쉬움

데이터 갯수가 적고 변동이 적으면 저렇게 저장하는 것도 나쁘지 않습니다.











채팅방 만들기



채팅방 게시물이 있어야

그 밑에 댓글들을 (메세지들을) 쭉 기록할거 아닙니까.

우선 채팅방을 만들어보도록 합시다.





DB에 뭐 저장하는건 맨날 하던거라 그냥 숙제로 해오도록 합시다.

(숙제1) /list페이지 글 옆의 버튼을 누르면 채팅방 게시물을 발행해보십시오.



답보고 싶어서 손이 덜덜 떨린다면 개쉬운 가이드를 드리겠습니다.

1. /list 페이지에 있는 게시물들 옆에 '이 유저와 채팅하기' 버튼을 아무데나 추가합시다.

2. 그 버튼 누르면 그냥 채팅방 게시물을 하나 DB에 저장해주면 끝입니다. chatroom 컬렉션 하나 만들어서 거기 넣으십시오.

3. 채팅방 게시물 document 하나 안에 들어갈 정보는 하단과 같습니다.

(DB에 저장될 채팅방 게시물 document 모습)
```
{
  member : [채팅당한 유저의 _id, 채팅건 유저의 _id],
  date : 지금날짜,
  title : 채팅방이름(아무거나)
}

```

그래서 로그인하고 글들 옆에 있는 채팅버튼을 누르면



![20220425_141725](/assets/20220425_141725.png)


▲ 게시물 하나가 chatroom collection 안에 생기면 숙제 성공입니다.





(팁1) list페이지 게시물에 발행한 사람의 _id가 어딘가에 기록이 되어있어야 편리합니다. (저번시간에 구현한듯)

(팁2) 어떤 내용들은 ejs 파일에서 전송할 필요는 없습니다. date, title, 채팅건 유저의 _id 이런건 서버에서 만들어주는게 편할 수 있습니다.

(팁3) 채팅방 게시물의 _id는 ObjectId() 어쩌구로 자동생성되게 냅둡시다.

(팁4) 날짜는 new Date() 라고 쓰면 날짜 나옵니다. 그거 바로 저장하면 됩니다.

알아서 숙제로 해옵시다.









남의 코드 따라치면 남의 코드 따라치기 실력이 늘고

혼자 코드짜보면 혼자 코드짜는 실력이 늡니다.

그래서 숙제가 하나 더 있는데



(숙제2) 유저가 /chat으로 접속하면 chat.ejs 파일을 보내줘야합니다.

그리고 그 안엔 내가 속한 채팅방 게시물들을 보여주면 됩니다.



1. 누가 /chat 접속하면 chat.ejs 파일 보내주면 되는데

2. 지금 로그인한 내 _id가 들어있는 채팅방 게시물들을 찾아서

3. ejs 파일에 꽂아서 보내주면 됩니다.



(팁1) 내가 속한 채팅방 게시물은 member : [ ] 안에 내 유저 _id 가 저장된 게시물을 뜻하겠군요.

.find({ member : 요청.user._id }) 이렇게 찾으면 [ ] 안에 있는 정보들도 찾을 수 있습니다.



chat.ejs 이쁘게 만들고 싶으면


채팅페이지스러운 html css 는 미리 짜드립니다 필요하면 사용합시다.

(Bootstrap 4 필요)


```
<div class="container p-4 detail">

 <div class="row">
   <div class="col-3">
     <ul class="list-group chat-list">
       <li class="list-group-item" data-id="">
         <h6>채팅방1</h6>
         <h6 class="text-small">채팅방설명</h6>
       </li>
       <li class="list-group-item">
          <h6>채팅방2</h6>
          <h6 class="text-small">채팅방설명</h6>
        </li>
      </ul>
    </div>

    <div class="col-9 p-0">
      <div class="chat-room">
         <ul class="list-group chat-content">
           <li><span class="chat-box">채팅방1 내용</span></li>
           <li><span class="chat-box">채팅방1 내용</span></li>
           <li><span class="chat-box mine">채팅방1 내용</span></li>
         </ul>
       <div class="input-group">
         <input class="form-control" id="chat-input">
         <button class="btn btn-secondary" id="send">전송</button>
       </div>
     </div>
   </div>
 </div>

</div>
```
css
```
.chat-content {
 height: 450px;
 overflow-y: scroll;
 padding: 10px;
}
.chat-content li {
 margin-top: 10px;
 list-style: none;
}
.text-small {
 font-size: 12px;
 color: gray;
 margin-bottom: 0;
}
.chat-box {
 background: #eee;
 padding: 5px;
 border-radius: 5px;
 float: left;
}
.mine {
 float: right;
}
```

---------


### 유저간 채팅기능 만들기 2. 채팅방 숙제


이제 점점 자바스크립트 문법이 중요해지기 시작합니다.

갈수록 자바스크립트 기초가 흔들흔들하다면 자바스크립트 기초 내용 학습이 먼저입니다.

아무튼 숙제나 같이 해봅시다.





일단 숙제하기 전에 저는 유저 계정을 3명 정도 만들어놓고 시작했습니다.

- me, kim, park 이름으로 유저를 만들었고

- kim, park 이름으로 게시물을 하나씩 발행해놨습니다. (게시물엔 작성자 _id가 잘 기록되어있습니다)

이제 me 라는 계정으로 로그인해서 kim, park에게 채팅을 걸어볼 겁니다.





(숙제1) /list페이지 글 옆의 버튼을 누르면 채팅방 게시물을 발행해보십시오.

```
(list.ejs)

<div class="container">
    <ul class="list-group">
      <% for (var i=0; i < posts.length ; i++){ %>
        <li class="list-group-item">
          <p>글번호 : <%= posts[i]._id %></p>
          <h4>할일 제목 : <%= posts[i].제목 %></h4>
          <p>할일 마감날짜 : <%= posts[i].날짜 %></p>
          <button class="btn btn-danger delete" data-id="<%= posts[i]._id %>">삭제</button>
          <button class="btn btn-secondary chat" data-id="<%= posts[i].작성자 %>">채팅하기</button>
        </li>
        <% } %>
    </ul>
</div>


<script>
    $('.chat').click(function(e){
      var _id = e.target.dataset.id;
      $.post('/chatroom', {당한사람id : _id})
      .then(()=>{
        console.log('채팅방 게시물 생성완료')
      })
    });
</script>

```
1. list.ejs 파일엔 작성자 정보가 숨겨진 버튼을 추가했습니다.

2. 그 버튼 누르면 post 요청을 보내달라고 코드 짜놨습니다. (ajax post 요청 쉽게하려면 $.post 써도 됩니다)

3. post 요청시 현재 글 작성한 유저의 _id까지 실어서 보냅니다. 필요할 것 같아서요









그럼 이제 서버는 post 요청 받으면 채팅방 게시물 하나 발행해주면 됩니다.



(server.js)

```
app.post('/chatroom', function(요청, 응답){

  var 저장할거 = {
    title : '무슨무슨채팅방',
    member : [ObjectId(요청.body.당한사람id), 요청.user._id],
    date : new Date()
  }

  db.collection('chatroom').insertOne(저장할거).then(function(결과){
    응답.send('저장완료')
  });
});

```
1. 서버는 /chatroom으로 post 요청을 받으면

2. 저런 데이터를 이쁘게 만들어줍니다. 저는 채팅당한사람, 현재 로그인한 사람의 _id 들은 [ ] 안에 담았습니다.

[ ] 싫으면 다르게 저장하셔도 됩니다.

3. 날짜는 new Date() 하면 나옵니다. 그거 저장하면 됩니다.

4. 저장 완료하면 '저장완료' 메세지를 보내줍니다. 추가로 에러체크 같은 것도 해줄 수 있겠군요.



참고로 db에 insert, find, delete 이런거 하고 콜백함수 대신 .then() 붙일 수 있습니다.

깔끔해보인다면 이렇게 합시다. 에러는 .catch() 붙이면 됩니다.


-----


(숙제2) 유저가 /chat으로 접속하면 chat.ejs 파일을 보내줘야합니다.

근데 ejs 파일 안엔 내 유저_id 가 있는 채팅방 게시물들을 다 보여줘야합니다.

어떻게 했냐면




(server.js)

```
app.get('/chat', 로그인했니, function(요청, 응답){

  db.collection('chatroom').find({ member : 요청.user._id }).toArray().then((결과)=>{
    console.log(결과);
    응답.render('chat.ejs', {data : 결과})
  })

});
```
1. 서버는 /chat으로 접속하면 chat.ejs 만든거 보내달라고 했습니다.

근데 ejs 파일 안에 내가 속한 채팅방 게시물들이 들어가야합니다.



2. 내가 속한 게시물을 전부 찾으라고 find() 이런걸 썼습니다. [ ] 안에 있는 것들도 그냥 저렇게 찾을 수 있습니다.

찾은 결과는 응답.render('chat.ejs', {data : 결과}) 이렇게 보냈습니다.









(chat.ejs)
```
<ul class="list-group chat-list">

  <% for (var i=0; i < data.length ; i++){ %>
    <li class="list-group-item" data-id="<%= data[i]._id %>">
      <h6> <%= data[i].title %> </h6>     
      <h6 class="text-small"> <%= data[i].member[0] %> </h6>
    </li>
  <% } %>

  <li class="list-group-item">
    <h6>채팅방1</h6>
    <h6 class="text-small">채팅방아이디</h6>
  </li>

</ul>
```

1. chat.ejs는 저번강의의 html css 코드 그대로 복붙했는데

2. 중간에 채팅방 리스트 부분만 저렇게 ejs 문법으로 반복문을 추가했다고 합니다.



그럼 이제 내가 속한 채팅방들을 <li>로 보여줍니다.


다 됐으면 다음시간에 채팅메세지 보내는 기능을 만들어볼겁니다.

메세지 보내는 기능도 그냥 게시물 발행입니다.

근데 댓글처럼 부모 게시물만 기록해주면 끝입니다.

그냥 다음강의 누르기 전에 직접 해보셔도 될듯요

-------------


### 유저간 채팅기능 만들기 3. 메세지 발행


오늘은 메세지 발행이나 해봅시다.

메세지 발행은 그냥 게시물 발행이랑 똑같습니다.

근데 댓글개념이기 때문에 부모 게시물도 기록해주면 끝이라고 했습니다.

이것도 새로운게 없어서 충분히 혼자할 수 있는데 자신있으면 혼자 해봅시다.

 ![20220425_142203](/assets/20220425_142203.png)

 - /chat 페이지에서 원하는 채팅방을 하나 누르고

- 메세지입력하고 전송버튼을 누르면 ▲ 이런 게시물이 DB에 저장되면 됩니다.  

(부모 게시물은 채팅방 게시물을 뜻합니다)









채팅 메세지 저장하기



그냥 누가 전송버튼을 누르면 서버로 메세지를 전달하고

그걸 DB에 저장해두면 끝입니다.



(chat.ejs)

(위에 있던 html)
```
<input class="form-control" id="chat-input">
<button class="btn btn-secondary" id="send">전송</button>

<script>
$('#send').click(function(){
  var 채팅내용 = $('#chat-input').val();   //1, 2
  var 보낼거 = {
    parent: 지금누른채팅방id,
    content: 채팅내용,
  };

  //3
  $.post('/message', 보낼거).then((a) => {  
     console.log(a)
  });

});


//4
var 지금누른채팅방id;

$('.list-group-item').click(function (){
   $(this).css('background-color', '#eee');
   지금누른채팅방id = $(this).attr('data-id');
});

</script>
```
1. 위에 있던 전송버튼을 누르면 서버로 보낼 데이터를 조물조물 만들어줍니다.

2. 아마 지금 어떤 채팅방에서 메세지 썼는지, 내용이 뭔지 이런 거가 담기면 되겠군요.

3. 만든 데이터를 post 요청해서 보낸다고 써놨습니다.



근데 지금 누른 채팅방의 _id 어떻게 찾냐고요? html 안에 박혀있을걸요 그거 찾으면 됩니다.

4. 왼쪽에 채팅방 리스트 클릭하면 / 배경 회색으로 이쁘게 주고 / 채팅방id를 찾아서 변수에 저장해놓는다고 써놨습니다.

그럼 채팅방 리스트 누르면 그 채팅방의 id가 변수에 저장됩니다.

그럼 이제 자유롭게 쓸 수 있겠군요.

서버는 그럼 데이터를 받았으면 DB에 저장하면 됩니다.



(server.js)
```
app.post('/message', 로그인했니, function(요청, 응답){
  var 저장할거 = {
    parent : 요청.body.parent,
    userid : 요청.user._id,
    content : 요청.body.content,
    date : new Date(),
  }
  db.collection('message').insertOne(저장할거)
  .then((결과)=>{
    응답.send(결과);
  })
});
```
1. 누군가 /message로 post 요청을 하면

2. 유저가 보낸 데이터 등을 활용해서 DB에 저장하고싶은 데이터를 귀엽게 만듭니다.

3. 그리고 DB에 집어넣습니다 끝



오늘의 교훈은 서버는 DB 입출력만 하면 끝이라

프론트엔드 자바스크립트 스킬이 더 중요할 수 있습니다.


---------

### 유저간 채팅기능 만들기 4. 서버와의 실시간 소통 (SSE)


오늘의 숙제 :

채팅방 누르면 서버에서 데이터를 보내주고 있습니다.

그 데이터를 실제 채팅메세지처럼 html로 보여주십시오.

데이터 수신시 자바스크립트로 html을 생성하면 되는데 처음이라면 당연히 검색이 필요합니다.









서버에서 채팅메세지 가져오기



왼쪽에 있는 채팅방을 누르면 거기 있는 채팅메세지를 가져와봅시다.

그럼 당연히 DB에서 "parent : 지금선택한 채팅방 게시물 _id" 이거인 게시물을 다 찾아주세요 라고 하면 됩니다.

근데 메세지 변경사항을 계속 실시간으로 업데이트해줘야합니다.

그건 여러가지 방법으로 해결할 수 있는데

- 1초마다 서버에게 메세지 달라고 요청을 또 할 수도 있고

- 서버랑 유저간 지속적인 소통채널을 열면 됩니다.

둘째가 서버에 부담이 덜하니 둘째로 합시다.













서버가 유저에게 실시간으로 정보를 보내고 싶으면



원래 get, post같은 http 요청은 1회 요청하면 1회 응답하고 끝입니다.

하지만 1회 응답이 아니라 지속적으로 서버에서 응답을 하고싶은 경우가 있습니다.

근데 응답.send() 이러면 1회 응답하고 끝이기 때문에

1. Header 라는 정보의 connection 항목을 keep-alive로 설정해주고

2. 응답.write('안녕하세요') 이렇게 보내면 계속 유저에게 지속적으로 응답이 가능합니다.

그럼 이제 실시간으로 유저에게 계속 정보전달이 가능합니다.


#### Header가 뭐냐면


서버와 유저가 get, post http 요청으로 정보를 주고 받을 때 부가정보도 몰래 전달됩니다.

유저의 경우 사용하는 브라우저, OS, 쓰는 언어, 보유한 쿠키 등

이런 것을 get요청시 서버로 몰래 전달합니다.

반대로 서버도 응답시 유저에게 몰래 서버정보를 전달합니다.

이 정보를 보관하는 곳은 Header 라고 부릅니다.



유저 -> 서버 이렇게 전달되는 Header는 Request Header,

서버 -> 유저 이렇게 전달되는 Header는 Response Header라고 합니다.

Header가 어떻게 생겼는지 보고싶으면 크롬 개발자도구 Network 탭가면 됩니다.



그래서 누가 /message/어쩌구 로 요청을 하면 실시간 소통 채널을 열어봅시다.



(server.js)
```
app.get('/message/:parentid', 로그인했니, function(요청, 응답){

  응답.writeHead(200, {
    "Connection": "keep-alive",
    "Content-Type": "text/event-stream",
    "Cache-Control": "no-cache",
  });

  응답.write('event: test\n');
  응답.write('data: 안녕하세요\n\n');

});
```
1. 서버는 응답.writeHead() 어쩌구 저렇게 쓰면 지속적 소통채널 개설 완료입니다.

2. 유저에게 계속 메세지를 보내고 싶을 때마다 응답.write() 하면 됩니다.

3. 근데 event: 이벤트명을 잘 작성하고 data: 전달할내용을 쓰면 됩니다.

그리고 한줄 끝나면 \n (엔터키)를 잘 넣으면 됩니다.



그러면 간단한 문자 등을 바로바로 유저에게 전송가능합니다.

확인하고 싶으시면 응답.write('data: 안녕하세요\n\n'); 이거 여러개 써보십시오.

응답 몇번이고 해줍니다.


(chat.ejs)
```
var 지금누른채팅방id;
var eventSource;   //일단변수

$('.list-group-item').click(function(){
  지금누른채팅방id = this.dataset.id;

  //프론트엔드에서 실시간 소통채널 여는법
  eventSource = new EventSource('/message/' + 지금누른채팅방id);
  eventSource.addEventListener('test', function (e){
    console.log(e.data);
  });

});
```
1. 유저는 GET요청 이런게 아니라 new EventSource('/message/' + 지금누른채팅방id);

이런 코드를 실행하면 서버에서 만들어놓은 실시간 채널에 입장가능합니다.

2. eventSource.addEventListener('서버에서작명한이벤트명') 이런 코드를 쓰면 서버가 보낸 데이터를 수신할 수 있습니다.

그럼 서버가 응답.write() 할 때마다 내부 코드를 실행해줍니다.

3. e.data 안에는 서버가 보낸 data : 어쩌구가 들어있습니다.

그럼 일단 실시간 채널 개설시 메세지들 가져오기



채널 개설시 DB에서 메세지들을 가져와서 보여줍시다.



(server.js)
```
app.get('/message/:parentid', 로그인했니, function(요청, 응답){

  응답.writeHead(200, {
    "Connection": "keep-alive",
    "Content-Type": "text/event-stream",
    "Cache-Control": "no-cache",
  });

  db.collection('message').find({ parent: 요청.params.parentid }).toArray()
  .then((결과)=>{
    console.log(결과);
    응답.write('event: test\n');
    응답.write(`data: ${JSON.stringify(결과)}\n\n`);
  });

});
```
1. 서버는 누군가 /message/어쩌구로 실시간 채널에 접속하면

2. DB에서 { parent : 어쩌구 } 를 가진 게시물을 다 찾아서 보내줍니다.

근데 실시간 채널이니까 응답.write 이용해서 보내줍니다.

3. 근데 찾은 자료는 [{ }, { } ... ] 이렇게 생겼습니다. 그걸 보내고 싶으면 JSON.stringify() 안에 넣어서 보내면 됩니다.

왜냐면 실시간 채널 이용할 때 문자만 전송가능하기 때문입니다.  


##### JSON.stringify가 뭔데요


{ }, [ ] 자료 내부에 전부 따옴표를 붙이고 싶으면 JSON.stringify() 함수 안에 넣어주시면 됩니다.

반대로 { }, [ ] 여기에 따옴표 붙였던걸 떼고 싶으면 JSON.parse() 함수 안에 넣어주시면 됩니다.

따옴표 왜 붙이냐고요?

붙이면 JSON이라는 자료가 되는데 일종의 문자자료 취급을 받습니다.



서버와 실시간 소통할 때는 { } [ ] 이런건 주고받을 수 없습니다.

문자만 주고받을 수 있습니다.

그래서 저렇게 따옴표 쳐서 JSON으로 만들어서 전송하기도 합니다.




근데 문제는 지금 DB에 메세지 document가 하나 추가되어도 실시간으로 그걸 감지하는 기능이 없습니다.

MongoDB 실시간 변동사항을 바로바로 알고싶을 땐 changeStream 기능을 쓸 수 있습니다.

쓰는 법은 다음 시간에 알아봅시다.

-------


### 유저간 채팅기능 만들기 5. DB 변동사항 실시간 업데이트

채팅방 누르면 서버에서 데이터를 보내주고 있습니다.

그 데이터를 실제 채팅메세지처럼 html로 보여주라고 했습니다.

그럼 자바스크립트로 "데이터 수신시 html 저기다가 만들어주세요" 라고 코드짜면 끝입니다







(chat.ejs)
```
var 지금누른채팅방id;
var eventSource;

$('.list-group-item').click(function(){
  지금누른채팅방id = this.dataset.id;
  $('.chat-content').html('') //일단 메세지들 전부 비우기

  eventSource = new EventSource('/message/' + 지금누른채팅방id);
  eventSource.addEventListener('test', function (e){
    console.log(e.data);

    var 가져온거 = JSON.parse(e.data);
    가져온거.forEach((a) => {
        $('.chat-content').append(`<li><span class="chat-box">${a.content}</span></li>`)
    });
  });

});
```
몇 줄을 추가했는데

1. 가져온 데이터를 다시 따옴표를 제거해서 { }, [ ] 로 만들어줍니다. 문자보다 array, object 자료 조작이 쉽습니다.

2. 아마 가져온건 [{ }, { } ... ] 이렇게 생겼습니다. { } 안에 하나하나 메세지 document 들이 들어있을텐데

3. 그걸 반복문 돌리면 { } 하나씩 나옵니다.

4. 그거 안에 있던 메세지들을 <li></li> 태그로 만들어서 원하는 곳에 집어넣었습니다.

jQuery를 쓰는 경우 $(원하는요소).append(html태그) 이렇게 쓰면 html 추가가 가능합니다.



이제 채팅방 하나 누르면 DB에서 메세지가져와서 html로 진짜 보여줍니다. 끝

지금은 DB에 메세지가 하나 추가되어도 아무런 반응이 없습니다.

세상에 이런 채팅서비스는 없습니다.

DB에 메세지가 추가되면 그걸 서버가 응답.write()로 바로 전송해줘야 실제 메세지 서비스같겠군요.  

"DB에 데이터가 하나 추가되면 바로 응답.write() 해주세요~" 라고 코드를 짜고 싶으면

MongoDB 의 change stream 기능을 쓸 수 있습니다.







##### MongoDB change stream 기능



원래 데이터베이스는 수동적입니다.

서버가 명령하면 데이터 입출력만 얌전히 해줄 뿐인데

change stream 기능을 이용하면 지가 동적으로 DB 변동사항을 감시해줍니다.

그리고 변동이 생기면 서버에게 업데이트 사항을 알려줍니다.

그럼 이제 자기주도적으로 일하는 DB가 되는데

실시간 서비스 만들 때 이런거 쓰면 편리합니다.











change stream 쓰는 법

```
(server.js)

const 찾을문서 = [
    { $match: { fullDocument.name : 123 } }
];

const changeStream = db.collection('message').watch(찾을문서);

changeStream.on('change', (result) => {
    console.log(result.fullDocument);
});
```
change stream 기능을 사용할 때 기본 코드 이렇게 써놓고 시작하면 됩니다.

1. 우선 컬렉션에서 원하는 document만 감시하고 싶으면 $match 이런걸 이용해서 조건식을 적어주면 됩니다.

(위 코드는 DB에서 {name : 123} 인 document만 변동사항을 감시해줍니다.)



2. 그리고 watch(찾을문서)를 붙여줍니다.



3. 그리고 on('change') 어쩌구 이벤트 리스너를 붙여주면

DB에서 변동사항이 생길 때마다 콜백함수 내부 코드를 실행해줍니다.



3. 변동사항은 result.fullDocument 안에 저장되어있습니다.

change stream에서 뭐 할 때는 어쩌구.fullDocument라고 자주 사용합니다.

왜 result.fullDocument 써야하는지 궁금하면 언제나 console.log로 출력해보면 됩니다.


![20220425_142642](/assets/20220425_142642.png)

▲ 예를 들어 컬렉션에 document가 하나 생겼을 때 result를 출력해보면

이런 데이터가 나옵니다.

새로운 document가 'insert' 되었다, 그리고 저장된 데이터는 fullDocument에 있다

이렇게 바로바로 변동사항을 알려줍니다.










<br>



그래서 '/message/어쩌구'로 접속시 DB 변경사항을 실시간으로 감시하려면



저번시간에 했던 app.get('/message/:parentid' 부분 하단에 오늘 배운 코드를 추가하면 되겠군요.



(server.js)
```
app.get('/message/:parentid', 로그인했니, function(요청, 응답){

  응답.writeHead(200, {
    "Connection": "keep-alive",
    "Content-Type": "text/event-stream",
    "Cache-Control": "no-cache",
  });

  db.collection('message').find({ parent: 요청.params.parentid }).toArray()
  .then((결과)=>{
    console.log(결과);
    응답.write('event: test\n');
    응답.write(`data: ${JSON.stringify(결과)}\n\n`);
  });


  const 찾을문서 = [
    { $match: { 'fullDocument.parent': 요청.params.parentid } }
  ];

  const changeStream = db.collection('message').watch(찾을문서);
  changeStream.on('change', result => {
    console.log(result.fullDocument);
    var 추가된문서 = [result.fullDocument];
    응답.write(`data: ${JSON.stringify(추가된문서)}\n\n`);
  });

});
```
1. 누군가 app.get('/message/:parentid' 이런 실시간 소통채널에 입장하면 DB에서 게시물 쫙 가져오고 그러는데

2. change stream을 이용해서 DB 감시도 동시에 해줍니다.

- 우선 { parent : 요청.params.parentid } 인 게시물들만 감시합니다.

- 그런 게시물들에 변동사항이 생기면 [result.fullDocument] 이걸 유저에게 보내줍니다.

- 물론 [], {} 이런 자료들은 JSON으로 바꿔서 보내야합니다.





그럼 뭐 이제 DB에 누군가 메세지를 추가로 전송해도 바로바로 유저에게 보내주겠군요.

그럼 이제 html로 그 추가 메세지들을 보여주기만 하면 되는 것입니다.

오 이런 보여주는 코드는 저번 시간에 다 짜놨군요

채팅기능완성

추가로 응용해볼 사항은



1. 지금 /chat 페이지의 모든 메세지들은 회색으로 보입니다.

내가 보낸 메세지는 우측으로 옮기거나 색을 다르게 해주거나 그런건 어떻게 해야할까요?

아마 html css 잘하면 될듯요



2. 지금 change stream 개발해놓은건 document 추가만 예상하고 짜놓은 코드입니다.

document가 혹여나 수정되거나 삭제되는 경우는 어떻게 할까요?

(실은 카톡같은거 생각해보면 수정, 삭제기능은 없어도 될듯 합니다)



3. 같은 상대와의 중복 채팅방 개설을 막으려면?



알아서 해보면 좋은 연습이 되겠군요.

----------


### (Socket.io) 실시간 데이터 보내고 받는 법


저번에 SSE를 이용하면 서버에서 일방적으로 실시간 응답을 해줄 수 있다고 했는데

실시간으로 소통할 수 있는 방법이 하나 더 있습니다.

서버와 유저간 Web Socket을 뚫으면 됩니다.

그럼 양방향으로 실시간 응답이 가능합니다.

Web Socket은 쌩자바스크립트 문법으로 개발할 수도 있지만

대부분의 상황에선 브라우저간 호환성이 좋은 socket.io 라이브러리를 설치해서 사용합니다. 우리도 합시다.











socket.io 설치는



npm install socket.io

입력하시면 끝입니다.

그리고 우리의 server.js에서 셋팅이 조금 필요합니다.





1. 하단과 같은 코드를 const 많이 모여있는 곳 하단에 추가해주시면 됩니다.

```
const http = require('http').createServer(app);
const { Server } = require("socket.io");
const io = new Server(http);
```
(복붙하실 때 const app = express() 보다 밑에와야합니다)




2. server.js 중간쯤에 보시면 예전에 만들어뒀던 app.listen 이거 코드를

(이랬던걸)
```
app.listen(8080, function () {
  console.log('listening on 8080')
});

(이렇게)
http.listen(8080, function () {
  console.log('listening on 8080')
});
```
이렇게 바꾸시길 바랍니다.

뭘 한거냐면 그냥 간략하게 express를 이용해서 서버를 띄우던걸

http라는 nodejs 기본 라이브러리 + socket.io를 이용해서 띄운겁니다.


갑자기 http라는게 뭐냐고 물으신다면

https://stackoverflow.com/questions/17696801/express-js-app-listen-vs-server-listen

다음 게시물을 참고하시면 되겠습니다.

(실은 우리는 현재 http라는걸 이용해서 서버를 띄우고 있습니다. express라는 라이브러리는 http라는 라이브러리를 쉽게 사용하기 위한 도구일 뿐입니다)

아무튼 소켓을 뚫을 수 있는 서버로 업그레이드 한거지 과거에 만들었던 서버와 동작방식은 차이가 없습니다.













채팅할 수 있는 페이지를 하나 만들어줍니다.



socket.ejs 파일을 새로 만들어봅시다.

안에 들어갈 내용은 그냥.. index.ejs에 있던거 전부 복붙하면 되겠습니다.

그 다음에 /socket으로 방문하면 socket.ejs를 보여주도록 합시다.

이건 이제 눈감고도 짤 수 있겠네요.





(server.js)
```
app.get('/socket', function(요청,응답){
 응답.render('socket.ejs')
});
```
그럼 이제 /socket 으로 접속하면 socket.ejs 보입니까. 전 보입니다.

그리고 여기 HTML 파일에도 socket.io 라이브러리를 설치하셔야합니다.

그래야 쉬운 문법을 이용해서 서버와 채팅을 주고받을 수 있으니까요.



구글에 socket.io cdn 이라고 검색하시면 cdn 제공해주는 페이지가 몇개 뜰텐데

https://cdnjs.com/libraries/socket.io (대충 이런 곳들이요)

거기서 socket.io.js 라고 끝나는 파일을 다운받거나 링크를 복사해서 script태그로 첨부해주시면 됩니다.

근데 내가 설치한 socket.io 라이브러리와 동일한 버전을 가져오면 되겠습니다.

라이브러리 버전은 여러분들 작업폴더의 package.json 파일에 기록되어있습니다.




```
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
```
▲ 그래서 저는 이런 코드를 chat.ejs에 복붙했습니다. 끝!

(이거 따라치시면 안됩니다 여러분의 package.json에 써있는 버전과 동일한거 찾으셔야함)

웹소켓 연결하는 법



socket.ejs 파일에 진짜 채팅 기능개발을 해보도록 합시다.

script태그로 socket.io 설치한 곳 밑에 script태그를 또 열어서 다음과 같이 작성합니다.





(chat.ejs)
```
<script src="jQuery 설치한곳"></script>
<script src="socket.io 설치한곳"></script>

<script>
  var socket = io();
</script>
```
▲ 그냥 한줄 쓰시면 이제 웹소켓을 이용해 서버와 실시간 소통채널을 개설한겁니다.

서버도 누군가 웹소켓으로 접속한걸 캐치해주고 싶으면





(server.js)
```
io.on('connection', function(){
  console.log('연결되었어요');
});
```
▲ 어떤놈이 웹소켓으로 서버에 connection 했을 때 콘솔창에 뭐 출력하라는 소리입니다.

그럼 이제 /socket 페이지를 방문할 때마다 자동으로 웹소켓으로 서버와 연결해줍니다.

연결이 될 때마다 서버는 콘솔창에 뭔가 출력해주고요.


-----

유저가 서버에게 데이터 보내는 법



유저가 서버에 간단한 메세지를 보내고 싶으시면

socket.emit() 이라는 간단한 코드 한줄이면 됩니다.

버튼을 누르면 유저 -> 서버에게 메세지를 전달해봅시다.



(chat.ejs)
```
<script src="jQuery 설치한곳"></script>
<script src="socket.io 설치한곳"></script>

<button id="send">서버로 데이터 보내기</button>

<script>
  var socket = io();
  $('#send').click(function(){
    socket.emit('user-send', '안녕하쇼')
  });
</script>
```
▲ emit() 안에는 파라미터가 두개 필요한데, 왼쪽은 이벤트 명을 작명하시면 되고 오른쪽은 전달할 데이터 적어주시면 됩니다.

그럼 서버는 'user-send' 라는 이벤트명으로 보낸 '안녕하쇼'라는 데이터를 수신할 수 있습니다.







유저가 보낸 데이터를 서버가 수신하는 법은

(server.js)
```
io.on('connection', function(socket){
  console.log('연결되었어요');

  socket.on('user-send', function(data){
    console.log(data)
  });

});
```
▲ 이벤트리스너랑 비슷한 문법을 씁니다.

'user-send' 라는 이벤트가 발생하면 console.log(data) 라는걸 실행해주세요~라는 코드입니다.

socket.on을 쓰면 되는데 socket.on은 콜백함수 파라미터를 function(socket) 이렇게 하나 넣어주시면 사용가능합니다.

data라는 파라미터엔 유저가 보낸 글이 들어있습니다. 그니까 '안녕하쇼'라는 문자가 들어있겠네요.

진짜 수신하는지 확인하고 싶으면 빨리 전송버튼 눌러보십시오.


------

### (Socket.io) 실시간 데이터 보내고 받는 법 2


서버가 유저에게 메세지 보내는 법



서버가 유저들에게 메세지를 보내고 싶으면

io.emit('작명', '보낼메세지');
이렇게 쓰면 됩니다.

그럼 모든 유저에게 메세지를 보낼 수 있습니다.

모든 유저에게 보내는걸 일명 "broadcast 한다"고 합니다.









유저는 서버의 메세지를 수신하고 싶으면



그니까 서버가 io.emit() 한걸 수신하고 싶으면 이벤트리스너가 필요합니다.



(socket.ejs)
```
<script>
  var socket = io();
  socket.on('작명', function(data){
    console.log(data)
  })

</script>
```
항상 모든 웹소켓 메세지들은 이벤트리스너로 수신할 수 있습니다.













그럼 단체 채팅방 만들고 싶으면



이렇게 코드를 짜면 되지않을까요.



(server.js)
```
io.on('connection', function (socket) {

  socket.on('user-send', function (data) {
    io.emit('broadcast', data)  //모든사람에게 데이터 전송
  });

});
```
아무튼 위와같이 코드 짜면 무슨 일이 일어날까요?

1. user-send 이벤트가 일어나면 (유저가 메세지를 보내면)

2. 모든 참여자에게 io.emit('broadcast', 유저가보낸메세지) 해줍니다.

서버가 모든 사람에게 메세지를 뿌려주는 확성기 역할을 해주겠군요.

이게 단체 채팅방의 작동방식 아니겠습니까.


(chat.ejs)
```
<script>
  var socket = io();
  $('#send').click(function(){
    socket.emit('user-send', '안녕하쇼')
  });

  socket.on('broadcast', function(data) {
      $('#content').append('<div>' + data + '</div>')
  });
</script>
```
▲ 유저는 socket.on 어쩌구라는 이벤트리스너를 장착해놓으면

서버가 io.emit()으로 보낼 때마다 그 데이터를 수신가능합니다.

그리고 유저는 'broadcast' 이름의 데이터가 도착하면 html로 만들어줍니다.



그리고 이 정도 코드만 짜놓으면 유저간 자유롭게 채팅을 나눌 수 있는 서비스가 완성된 것입니다.

















socket으로 메세지 보낼 땐 id와 header 정보도 전달됩니다


```
io.on('connection', function(socket){
  console.log(socket);
});
```
서버에서 socket이라는 파라미터를 출력해보면

지금 접속한 유저의 header 정보, 유니크한 socket용 id 이런 것들이 출력됩니다.

특히 socket.id 하면 유저의 유니크한 id를 출력해볼 수 있는데

이걸 이용해서 내가 원하는 사람에게만 메세지를 보내거나 할 수도 있습니다.








```
io.on('connection', function(socket){
  io.to(socket.id).emit("broadcast", '서버응답임');
});
io.to(소켓아이디).emit()
```
이러면 원하는 소켓id를 가진 사람에게만 메세지를 보낼 수 있습니다.















하위 채팅방 만드는 법



하위 채팅방을 만들어서 거기 들어있는 사람끼리만 채팅을 할 수 있게 만들 수도 있습니다.

서버가 유저를 채팅방에 쏙 집어넣어주면 되는데

socket.join("room1");

이런 코드를 짜면 room1 이라는 채팅방에 유저를 넣어줄 수 있습니다.

채팅방은 미리 만들 필요 없고 그냥 이름 작명하면 알아서 만들어줍니다.



1. 그럼 유저가 room1에 접속하고 싶으면 서버에게 요청을 하고

2. 서버는 그럼 요청받으면 room1에 집어넣어주면 채팅방 완성이겠네요

요청도 GET POST 이런게 아니라 그냥 socket으로 합니다.







(socket.ejs)
```
<button id="room1">채팅방1 입장</button>
<button id="room1-send">채팅방1에 메세지 전송</button>

<script>
  $('#room1').click(function(){
    socket.emit('joinroom', '제발');
  });

  $('#room1-send').click(function(){
    socket.emit('room1-send', '어쩌구저쩌구' )
  });

</script>
```
1. 유저는 채팅방1 입장버튼 누르면 room1에 입장시켜달라고 떼를 썼고

그럼 서버는 입장시켜주도록 코드짭니다.

2. 그리고 채팅방1 전송버튼 누르면 어쩌구저쩌구라고 메세지를 보냅니다.


(server.js)
```
io.on('connection', function(socket){

  socket.on('joinroom', function(data){
    socket.join("room1");
  });

  socket.on('room1-send', function(data){
    io.to("room1").emit('broadcast', data);
  });
});
```
1. 서버는 떼쓰는 요청을 받으면 room1에 넣어주면 되고

2. room1-send라는 이름의 요청을 받으면 room1에 있는 사람들에만 broadcast 해주면 됩니다.

io.to('룸이름').emit()

이렇게 쓰면 원하는 룸의 사람들에게만 broadcast 가능합니다.







브라우저를 몇개 더 열어서 /socket 페이지 접속해서 테스트해보도록 합시다.

----

### Node+Express 서버와 React 연동하기


이번 강의 빠른 요약 : 두개 합치는건 별거 아니고

서버는 유저가 메인페이지로 접속하면 리액트로 만든 html 파일을 보내주면 끝입니다.



서버만들 때 Express + MongoDB를 사용하면 JavaScript 만으로도 풀스택 개발을 체험해볼 수 있는 시대입니다.

여기다가 React를 더하고 싶은 분들이 많아서 준비했습니다.

리액트/서버개발 다시한번 개념정리부터 들어갑니다.











서버는 누가 html 파일 요청하면 보내주는 간단한 프로그램입니다.



진짜로 서버는 별거 아니고 어떤 고객이 codingapple.com으로 접속하면 거기맞는 html을 보내주는 기계일 뿐입니다.

임시 서버를 Node + Express로 쉽게 만들어봅시다.



1. 작업폴더를 에디터로 오픈 한 뒤에 터미널을 열어서 npm init 입력 후 뭐 선택하라고 하면 엔터 여러번

2. npm install express 입력  

3. server.js 파일을 만드시고 다음 코드 작성


```
const express = require('express');
const path = require('path');
const app = express();

const http = require('http').createServer(app);
http.listen(8080, function () {
  console.log('listening on 8080')
});
```

4. 터미널에서 node server.js 입력하시면 브라우저로 localhost:8080 접속시 서버가 뜹니다.

5. nodemon이라는게 있다면 nodemon server.js를 입력합니다. 그러면 서버 코드 바꿀 때마다 node server.js 로 다시 입력 안해도 됩니다.

------


##### 리액트는 HTML을 이쁘게 만들어주는 툴입니다.



리액트는 대단한거 아니고 앱처럼 부드럽게 동작하는 HTML을 만들고 싶을 때 사용하는 툴입니다.




![20220425_143716](/assets/20220425_143716.png)


▲ 카톡 같은 모바일 앱 생각해보면

그런 앱들은 새로고침 없이 페이지 전환이 샥샥 되죠?


 <br>
 그런 식으로 새로고침할 필요없이 부드럽게 웹사이트를 만들고 싶을 때 리액트 쓰면 됩니다.

쌩자바스크립트로도 가능한데 코드 길어져서 귀찮아서 리액트쓰는 것임

어떤 식으로 개발하는지는 리액트 강좌 무료파트 몇개 들어보면 이해갑니다.











리액트를 사용하면 Nodejs 서버의 view 부분 기능개발이 필요없습니다.

 <br>

Nodejs 서버만들기 강의를 들으셨던 분들에게 말씀드리자면
 <br>

우리 지금까지 ejs/html 파일 여러개 만들어서 페이지만들고 그런 짓거리를 하지 않았습니까.

 <br>

 그런거 개발은 리액트가 알아서 할 수 있으니 ejs파일은 버리셔도 됩니다.
 <br>

애초에 리액트에서 페이지를 여러개 만들고 그걸 라우팅도 할 수 있습니다.
 <br>

그니까 "누가 /list로 접속하면 글목록 html들 보여주셈" 을 서버 언어로 짰었는데

이걸 리액트에서도 똑같이 코드를 짤 수 있다는 겁니다. (근데 웹앱처럼 스무스하게 라우팅해줌 베리굿)


 <br>

그래서 리액트 잘쓰면 서버에 작성할 코드는

"유저가 글리스트 요청하면 DB에서 데이터 뽑아서 전해주세요" 라는 데이터 입출력 API밖에 없습니다.  
 <br>

그리고 가끔 데이터 뽑아주기 전에 미들웨어로 "니 로그인했냐" 라고 물어보는거 그 정도 밖에 없겠군요.  



 <br>
하지만 언제나 리액트쓰는게 마냥 좋은 일은 아닙니다. 전환이 부드러운 웹앱만들고 싶으면 쓰는게 리액트라니까요

페이지 20개 30개 되는 사이트는 그냥 페이지로 나누는 것도 좋은 선택입니다. 리액트로만 만들면 코드 매우 더러워짐  


 <br>


#### 리액트 프로젝트 만드는 법



지금 하고 있는 server.js 옆에 서브폴더로 리액트 프로젝트를 하나 만들어봅시다.

0. nodejs 극 최신버전이 아니면 에러납니다.

1. 터미널에 npx create-react-app 프로젝트명 을 입력합니다. 프로젝트명 자유작명하셈 다만 작명할 때 띄어쓰기하지마십시오.

2. 그럼 서브폴더에 리액트 프로젝트가 생성되는데 그걸 다시 에디터로 오픈합니다.

3. 리액트 문법으로 열심히 만들고 싶은걸 개발해봅니다. 개발시 코드를 미리보고 싶으면 npm run start 를 입력합니다.   

4. 개발 완료되면 리액트 프로젝트 터미널에 npm run build를 입력하면 리액트 완성본 파일이 build 폴더내에 생성됩니다. 그럼 서버에서 보낼 준비 완료!













##### 리액트로 만든 HTML 전송하는법



리액트로 개발한 html파일을 고객에게 보내주면 그게 Nodejs 서버랑 리액트 합치는거 끝임


![20220425_143931](/assets/20220425_143931.png)


▲ 리액트로 개발을 다 마친 후 npm run build 라는걸 하시면 build라는 폴더가 생기고 안에 html css js 파일이 생성됩니다.

그 중에 html 파일은 사진에 보이는 index.html 파일 딱 하나입니다.

왜냐면 기본적인 리액트 프로젝트는 SPA라는걸 만들어주는데 이게 뭐냐면

html 페이지가 하나이고 다른 페이지 이동은 자바스크립트를 이용해서 스무스하게 구현하는 웹앱을 말합니다.

SPA는 기본적으로 HTML 파일 하나가 끝입니다.





이걸 서버에다가 이렇게 코드를 짜면

(server.js)
어떤 놈이 메인페이지로 접속하면 저거 리액트로 build한 index.html 보내주셈
리액트와 Nodejs 서버 합치기 끝입니다.

![20220425_144135](/assets/20220425_144135.png)


▲ 예를 들면 폴더구조를 이렇게 만들었다고 칩시다.

server.js 옆에다가 react-project라는 폴더명으로 리액트 프로젝트를 하나 만든겁니다.

그럼 안에 build한 파일들이 있겠죠?



이렇게 되어있는 경우 코드를 어떻게 짜냐면  

(server.js에 추가)
```
app.use(express.static(path.join(__dirname, 'react-project/build')));

app.get('/', function (요청, 응답) {
  응답.sendFile(path.join(__dirname, '/react-project/build/index.html'));
});

```
express.static이라는걸 쓰시면 특정 폴더안의 파일들을 static 파일로 고객들에게 잘 보내줄 수 있습니다.

그럼 아마 build 폴더 안의 css js img 파일들도 잘 사용할 수 있겠죠.

그리고 늘 하던대로 누군가 / 페이지로 접속하면 리액트로 만든 html 보내주는겁니다.

그럼 localhost:8080 으로 접속하시면 리액트 프로젝트가 나옵니다. 합치기 끝!


-------


##### (리액트 아는사람만) 리액트에서 라우팅을 담당하는 경우



리액트에서도 서버가 하던 라우팅을 대신 해줄 수 있습니다. react-router-dom을 설치하시면 됩니다.

그럼 누가 /list 로 접속하면 글목록 보여주고 /mypage 접속하면 마이페이지도 보여줄 수 있겠는데

그럼 nodejs 서버에서 라우팅이 필요없어지겠군요!



근데 리액트 라우팅으로 /list 페이지를 개발해놨는데 실제 localhost:8080/list 로 접속하면 아무것도 안뜹니다.

왜냐면 브라우저 URL창에 때려박는건 서버에게 요청하는거지 리액트 라우터에게 라우팅 요청하는게 아니기 때문입니다.

이걸 리액트가 라우팅하게 전권을 넘기고 싶다면 server.js 에 다음과 같은 코드를 밑에 추가하십시오.



(server.js에 추가)
```
app.get('*', function (요청, 응답) {
  응답.sendFile(path.join(__dirname, '/react-project/build/index.html'));
});
```
별표 * 라는 것은 모든 문자라는 뜻입니다.

"고객이 URL란에 아무거나 입력하면 걍 리액트 프로젝트나 보내주셈"이라는 뜻인데 이렇게 하면 리액트 라우팅 잘됩니다. 끝!


-----

##### 리액트로 프론트엔드를 만들 경우 개발흐름



예를 들어서 DB에서 글목록 데이터를 꺼내서 HTML로 보여주고 싶은 경우

이전엔 뭐 글목록.html 페이지를 서버에서 보내줬을 텐데

리액트가 있을 경우 리액트는 index.html 페이지 하나로 개발하기 때문에

1. 서버는 누군가 /list로 GET요청을 하면 DB에서 데이터 꺼내서 보내준다고 API를 짜놓습니다.

2. 리액트는 글목록 페이지를 보여주고 싶으면 서버로 ajax GET요청을 보냅니다.

3. 그럼 데이터 받아오겠죠? 그걸 가지고 html에 집어넣든 맘대로 개발하면 됩니다.



리액트는 페이지가 index.html 하나만 있기 때문에

서버와의 통신은 거의 ajax로 진행하는 것만 잘 알아두면 됩니다.

세션이 있을 경우 회원정보 확인같은 것도 ajax로 알아서 됩니다.





그리고 nodejs 서버파일엔 const 여러개 모여있는 곳 하단에
```
app.use(express.json());
var cors = require('cors');
app.use(cors());
```
이 코드 넣고 시작하셔야 리액트와 nodejs 서버간 ajax 요청 잘됩니다.






##### 서브디렉토리에 리액트앱 발행하고 싶은 경우



지금 메인페이지가 리액트앱인데 그거 말고 /react 이렇게 접속하면 리액트 앱 보여주고 싶은 경우 어떻게 하냐면



(server.js)
```
app.use( '/', express.static( path.join(__dirname, 'public') ))
app.use( '/react', express.static( path.join(__dirname, 'react-project/build') ))

app.get('/', function(요청,응답){
  응답.sendFile( path.join(__dirname, 'public/main.html') )
})
app.get('/react', function(요청,응답){
  응답.sendFile( path.join(__dirname, 'react-project/build/index.html') )
})
```
▲ server.js 라우팅을 다 이렇게 바꿔주시고



 ```

(리액트프로젝트 내의 package.json)
{
  "homepage": "/react",
  "version": "0.1.0",
  ... 등
}
 ```

▲ 리액트 프로젝트 내의 package.json에 homepage라는 항목을

여러분이 발행을 원하는 서브디렉토리명으로 새로 기입해주시면 됩니다.





그럼 방금 server.js 에서 /react 접속시 리액트 프로젝트보내고

/ 접속시 일반 html 파일 보내라고 했으니 정말 그렇게 잘 됩니다. 끝!


---------


서버앱과 리액트앱을 동시에 띄워서 개발을 진행하고 싶으면



그니까 리액트도 localhost로 미리보기 띄워놓고, 서버도 localhost로 미리보기를 띄워두고 개발을 진행하고 싶다면

리액트에서 package.json이라는 파일을 열어서 proxy라는 부분 설정을

서버 미리보기 띄우던 localhost:어쩌구 이걸로 설정해주면 됩니다.

그러면 리액트에서 서버로 ajax 요청 이런거 잘됨

https://create-react-app.dev/docs/proxying-api-requests-in-development/

이걸 참고합시다.







 
