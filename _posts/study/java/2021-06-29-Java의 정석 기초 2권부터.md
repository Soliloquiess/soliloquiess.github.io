---
title: "[자바]Java 정석 기본편 제네릭스 12장 이후"
layout: post
subtitle: Java
date: "2021-06-29 07:52:51 +0900"

categories: study
tags: Java
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---

### 제네릭스, 열거형, 어노테이션

#### 제네릭스 : 다양의 타입의 객체를 다루는 메서드나 컴파일 시 타입 체크를 해주는 기능.

객체 타입 컴파일 시 타입 안정성을 높이고 형 변환의 번거로움이 줄어든다.

##### 제네릭스의 장점

1. 타입 안정성을 제공한다.
2. 타입 체크와 형변환을 생략할 수 있으므로 코드가 간결해진다.

---

#### 타입변수

- ArrayList 클래스의 선언에서 클래스의 이름 옆의 <> 안에 있는 E를 타입변수라고 하며 일반적으로는 Type의 첫글자인 T를 쓴다.

물론 T만 쓰는게 아니고 다른걸 써도 된다.

ArrayList< E > 의 경우 Element의 E를 쓰거나 Map< K,V >와 같이 여러개일 경우 콤마로도 구분이 가능하다.

그리고 ArrayList와 같은 제네릭 클래스 생성시 참조변수와 생성자에 타입 변수 E 대신 Tv와 같은 실제타입을 지정해 줘야한다.

ArrayList < Tv > tvList = new ArrayList< Tv >();

---

#### 제네릭스의 용어

class Box < T > {}
라는 제네릭 클래스 BOX 가 선언되어 있을 떄

BOX< T > : 제네릭 클래스 'T의 Box' 또는 'T Box'라고 읽는다.

T: 타입 변수 또는 타입 매개변수(T는 타입 문자)
Box : 원시타입(raw type)

---

#### 와일드 카드

- 제네릭 클래스를 생성시 참조변수에 지정된 제네릭 타입과 생성자에 지정된 제네릭 타입은 일치해야 한다.

ArrayList< Tv > list = new ArrayList< Tv >()

만약 일치하지 않으면 컴파일 에러가 난다.

그럼 제네릭 타이벵 다형성을 쓰는 법은 없나?

제네릭 타입으로 와일드 카드를 사용하면 된다.

와일드 카드는 기호 "?"를 사용하는데 'extends'와 'super로 상한, 하한을 제한할 수 있다.

< ? extends T > : 와일드 카드의 상한 제한. T와 그 자손들만 가능
< ? super T > : 와일드 카드의 하한 제한 . T와 그 조상들만 가능
< ? > : 제한 없음. 모든 타입이 가능 < ? extends Object >와 동일.

---

#### 어노테이션이란

- 주석처럼 프로그래밍 언어에 영향을 미치지 않으면서도 다른 프로그램에게 유용한 정보를 제공할 수 있다라는 장점이 있다.( 어노테이션의 뜻은 주석, 주해 , 메모이다.)

---

### 쓰레드

#### 프로세스(Process)와 쓰레드(thread)

- 프로세스란 간단히 말해서 실행중인 프로그램이다. 프로개름을 실행하면 OS로 부터 실행에 필요한 자원(메모리)을 할당받아 프로세스가 된다.

프로세스는 프로그램을 수행하는데 필요한 데이터와 메모리 등 자원 그리고 쓰레드로 구성되어 있으며, 프로세스의 자원을 이용해서 실제로 작업을 수행하는 것이 쓰레드다.

그래서 모든 프로세스에는 최소한 하나 이상의 쓰레드가 존재하며, 둘 이상의 쓰레드를 가진 프로세스를 '멀티쓰레드 프로세스'라고 한다.

---

#### 멀티쓰레딩의 장단점

- DOS 와 같은 OS는 한번에 한 가지 작업만 할 수 있다. 반면에 윈도우와 같은 멀티 태스킹이 가능한 OS는 동시에 여러 작업을 수행할 수 있다.

싱글 쓰레드 프로그램과 멀티 쓰레드 프로그램의 차이도 이와 같다고 생각하면 된다.

###### 멀티쓰레드의 장점.

- CPU의 사용률을 향상시킨다.
- 자원을 보다 효율적으로 사용할 수 있다.
- 사용자에 대한 응답성이 향상된다.
- 작업이 분리되어 코드가 간결해진다.

메신저로 채팅하면서 파일을 다운로드 받거나 음성대화를 나눌 수 있는 것이 가능한 이유가 바로 멀티쓰레드로 작성되어있기 때문이다.

만약 싱글 쓰레드로 작성되어 있다면 파일을 다운 받을 시 다른 일(채팅)을 전혀 할 수 없을 것이다.

여러 사용자에게 서비스를 해주는 서버인 경우 멀티스레드로 작성하는 것은 필수적이여서
하나의 서버프로세스가 여러개의 스레드를 생성해서 스레드와 사용자의 요청이 일대이로 처리되도록 프로그래밍 해야한다.

만일 싱글스레드로 서버 프로그램을 작성한다면 사용자의 요청마다 새로운 프로세스를 생성해야하는 데 프로세스를 생성하는 것은 쓰레드를 생성하는 것에 비해 더 많은 시간과 메모리 공간이 필요하므로 더 많은 수의 사용자 요청을 서비스 하기 어렵다.

그러나 멀티스레드가 꼭 좋은것만 있는것은 아닌데 멀티쓰레드는 여러 쓰레드가 같은 프로세스 내에서 자원을 공유하면서 작업을 하기 때문에 발생할 수 있는 동기화, 교착상태와 같은 문제들을 고려해서 신중히 프로그래밍 해야한다.

---

#### 쓰레드의 구현과 실행

- 쓰레드를 구현하는 건 Thread 클래스 상속 받는 것과 Runnable 인터페이스를 구현하는 법 모두 두가지가 있다. 어느 쪽을 선택해도 별 차이는 없지만 Thread 클래스를 상속한다면 다른 클래스를 상속받을수 없으므로 Runnable 인터페이스를 구현하는 법이 일반적이다.

###### Runnable 인터페이스를 구현하는 방법은 재사용성이 높고 코드의 일관성을 유지할 수 있기 떄문에 보다 객체지향적인 방법이다.


--------



#### 쓰레드의 실행 - start()

쓰레드 실행했다고 자동으로 실행되는 것은 아니다. start()를 호출해야만 쓰레드가 실행된다.

t1.start(); // 쓰레드 1을 실행시킨다.

t2.start(); // 쓰레드 2를 실행시킨다.

사실은 start()가 호출되어도 바로 실행이 아니라 실행 대기상태에 있다가 자기 차례가 되어야 실행된다. 물론 대기중인 쓰레드가 하나도 없으면 곧바로 실행상태가 된다.

쓰레드의 실행순서는 OS의 스케줄러가 작성한 스케줄에 의해 결정된다.

또, 한번 실행이 종료된 쓰레드는 다시 실행할 수 없다.
하나의 쓰레드에 대해 한번만 start()가 호출이 가능하다.

즉 쓰레드를 한번 더 수행하려면 쓰레드 객체를 new로 한번 더 다시 생성해서 수행해야 하낟.

-----------

#### start(), run()

start,run 의 차이?
왜 쓰레드 실행시 run이 아닌 start를 호출하나?

main에서 run을 호출하는 건 생성된 쓰레드를 실행하는게 아니라 단순히 클래스에 선언된 메서드를 호출하는 것일 뿐이다.

반면 start()는 새로운 쓰레드가 작업 실행하는데 필요한 호출스택(call stack)을 생성한 뒤 run을 호출해서 생성된 호출스택에 run()이 첫번째로 올라가게 한다.

모든 쓰레드는 독립적인 작업을 수행하기 위해 자기만의 호출스택을 필요로 하고 새로운 쓰레드를 생성하고 실행시킬 때 마다 새로운 호출스택이 생성되고 쓰레드가 종료되면 작업에 사용된 호출스택은 소멸된다.

-------

#### main 쓰레드

- main메서드 작업 수행하는 것도 쓰레드고 이를 main쓰레드라고 한다.

public static void main 메서드 사용하면서 이미 쓰레드를 쓰고 있었다.

지금까지 main이 수행 마치면 프로그램 종료되었으나 만약 다른 쓰레드가 있으면 모든 쓰레드가 종료되기 전까지 프로그램이 종료되지 않는다.

###### 실행 중인 사용자 쓰레드가 하나도 없을 때 프로그램은 종료된다.

쓰레드는 사용자 쓰레드('user thread', non-daemon thread)와 데몬쓰레드 (daemon thread). 두 종류가 있다.


------------

#### 싱글 쓰레드와 멀티 쓰레드

전에 멀티쓰레드의 장점을 수행했는데 마냥 장점만 있진 않다.

멀티쓰레드가 싱글쓰레드보다 더 걸릴수 있는데 이유는 프로세스나 쓰레드간 작업전환인 컨텍스트 스위칭(context switching) 때문이다.

작업전환시엔 현재 진행중인 작업상태, 예를 들어 다음에 실행할 위치, 프로그램 카운터 등의 정보를 저장하고, 읽어오는 시간이 소요된다.

참고로 쓰레드의 스위칭에 비해 프로세스 스위칭이 더 많은 정보를 저장해야하므로 더 많은 시간이 소요된다.

그래서 싱글코어에서 단순히 cpu만 쓰는 계산작업이면 멀티쓰레드보다 싱글쓰레드로 프로그래밍 하는 것이 효율적이다.

-------------

#### 쓰레드의 I/O 블락킹

두 쓰레드가 서로 다른 자원 쓰는 작업시앤 싱글쓰레드 프로세스보다 멀티 프로세스가 더 효율적이다.

예를 들면 사용자로부터 데이터를 입력받는 작업, 네트워크로 파일 주고받는 작업, 프린터로 파일 출력하는 작업과 같이 외부기기와의 입출력을 필요로 하는 경우가 이에 해당한다.

-----------

#### 쓰레드의 우선순위

쓰레드는 우선순위(priority)라는 속성(멤버변수)를 가지고 있는데 이 우선순위 값에 따라 스레드가 얻는 실행시간이 달라진다.

쓰레드가 수행하는 작업의 중요도에 따라 쓰레드의 우선순위를 서로 다르게 지정하여 특정 쓰레드가 더 많은 작업 시간을 갖도록 할 수 있다.

void setPriority(int newPriority) // 쓰레드의 우선순위를 지정한 값으로 변경한다.
int getPrioirty() // 쓰레드의 우선순위를 반환한다.

---------------


#### 데몬 쓰레드 



데몬 쓰레드는 다른 일반 쓰레드(데몬 쓰레드가 아닌 쓰레드)의 작업을 돕는 보조적인 역할을 수행하는 쓰레드다.

일반쓰레드가 모두 종료되면 데몬쓰레드는 강제로 자동 종료된다. 
왜냐하면 일반 쓰레드가 종료되면 데몬 쓰레듸의 존재가 의미가 없다.

이 점을 제외하고는 데몬쓰레드와 일반 쓰레드는 다르지 않다.

데몬쓰레드의 예로는 가비지 컬렉터, 워드프로세서의 자동저장, 화면 갱신 등이 있다.
데몬쓰레드는 일반 쓰레드의 작성방법과 실행방법이 같으며 다만 쓰레드를 생성한 뒤 실행전 setDaemon(true)를 호출하기만 하면 된다. 그리고 데몬 쓰레드가 생성한 쓰레드는 자동적으로 데몬 쓰레드가 된다.


boolean isDaemon() : 쓰레드가 데몬쓰레드인지 확인한다. 데몬쓰레드면 true를 반환한다.
void setDaemon(boolean on) : 쓰레드를 데몬 쓰레드로 또는 사용자 쓰레드로 변경한다 매개변수 on의 값을 true로 지정시 데몬쓰레드가 된다.



----------


#### 쓰레드의 상태

- 쓰레드는 생성된 후부터 종료까지 여러 상태를 가질수 있다

new : 쓰레드가 생성되고 아직 start() 가 호출되지 않은 상태
Runnable : 실행중 또는 실행 가능한 상태
Blocked : 동기화 블럭에 의해서 일시정지된 상태(lock이 풀릴때 까지 기다리는 상태)
Waiting, Timed_wating: 쓰레드의 작업이 종료되지는 않았지만 실행 가능하지 않은(unrunnable) 일시정지의 상태, Timed_Waiting 은 일시정지 시간이 지정된 겨웅를 의미
Terminated: 쓰레드의 작업이 종료된 상태

------

#### 쓰레드의 실행제어

쓰레드가 어려운 이유는 동기화와 스케줄링이다.

우선순위를 통해 쓰레드간의 스케줄링으로 앞에서 하긴 했지만
이것만으로 부족하다. 효율적인 멀티쓰레드 프로그램을 만들기 위해 보다 정교한 스케줄링으로 프로세스에게 주어진 자원과 시간을 여러쓰레드가 낭비없이 사용하도록 프로그래밍 해야한다.


sleep: 지정된 시간 동안 스레드를 일시정지 시킨다, 지정된 시간이 지나고 나면 자동으로 다시 실행대기상태가 된다.

join: 지정된 시간동안 쓰레드가 실행되도록 한다. 지정된 시간이 지나거나 작업이 종료되면 join()을 호출한 쓰레드로 다시 돌아와 실행을 계속한다.

interrupt: sleep()이나 join()에 의해 일시정지상태인 쓰레드를 깨워서 실행대기상태로 만든다.

stop : 쓰레드를 즉시 종료시킨다.

suspend: 쓰레드를 일시정지 시킨다. resume()을 호출하면 다시 실행대기 상태가 된다.

yield(): 실행 중에 자신에게 주어진 실행시간을 다른 쓰레드에게 양보(yield)하고 자신은 실행대기상태가 된다.


-----


#### 쓰레드의 동기화(synchronization)

싱글쓰레드 프로세스의 경우 프로세스 내에서 단 하나의 쓰레드만 작업하기 때문에 프로세스 자원을 가지고 작업하는 데 별 문제가 없지만, 멀티 쓰레드 프로세스의 경우 여러 쓰레드가 같은 프로세스 내의 자원을 공유해서 작업하기 때문에 서로의 작업에 영향을 주게 된다.

만일 쓰레드 A가 작업 중에 다른 쓰레드 B로 제어권이 넘어갔을 때, 쓰레드 A가 작업하던 공유데이터를 쓰레드 B가 임의로 변경하였다면, 다시 쓰레드 A가 제어권으를 받아서 나머지 작업을 마쳤을 때 원래 의도해던것과 다른 결과를 얻을 수 있다.

이러한 일이 발생하는 걸 방지하기 위해 한 쓰레드가 특정 작업을 끝마치기 전 까지 다른 쓰레드에 의해 방해받지 않도록 하는 것이 필요하다. 그래서 도입된게 임계영역(critical section) 과 잠금(락, lock) 이다.

공유 데이터를 사용하는 코드영역을 임계영역으로 지정해두고, 공유데이터(객체)가 가지고 있는 lock을 획득한 단 하나의 쓰레드만 이 영역 내의 코드를 수행하게 한다.

그리고 해당 쓰레드가 임계 여영ㄱ내의 모든 코드를 수행하고 벗어나서 lock을 반납해야만 다른 쓰레드가 반납된 lcok을 획득하여 임계영역의 코드를 수행할 수 있게 된다.

이처럼 한 쓰레드가 진행중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는 것을 쓰레드의 동기화(synchronization)이라고 한다.

###### 쓰레드의 동기화 - 한 쓰레드가 진행중인 작업을 다른 쓰레드가 간섭하지 못하게 막는 것.

wait()과 notify()

synchronized로 동기화해서 공유데이터를 보호하는것 까지는 좋은데, 특정 쓰레드가 객체의 락을 가진 상태로 오랜 시간을 보내지 않도록 하는것도 중요하다.

만약 계좌에 출금할 돈이 부족해서 한 쓰레드가 락을 보유한 채로 돈이 입금 될 때까지 기다리면, 다른 쓰레드들은 모두 해당 객체의 락을 기다리느라 다른 작업들도 원활히 되지 않을 것이다.

이러한 상황을 개선하기 위해 고안된 것이 wait과 notify이다 .동기화 된 임계영역의 코드를 수행하다가 작업을 더이상 진행할 상황이 아니면 일단 wait()을 호출하여 쓰레드가 락을 반납하고 기다리게 한다. 그러면 다른 쓰레드가 락을 얻어 해당 객체에 대한 작업을 수행할 수 있게 된다. 

나중에 작업을 진행할 수 있는 상황이 되면 notify()를 호출해서 작업을 중단했던 쓰레드가 다시 락을 얻어 작업을 진행할 수 있게 된다.

wait(), notify(), notifyAll()
- object에 정의되어 있다.
- 동기화 블록(synchronized 블록) 내에서만 사용할 수 있다.
- 보다 효율적인 동기화를 가능하게 한다.

-------------------------



### 람다와 스트림

#### 람다식

람다식은 간단히 말해서 메서드를 하나의 식(expression)으로 표현한 것이다. 람다식은 함수를 간략하면서도 명확하게 표현할 수 있게 해준다.

메서드를 람다식으로 표현하면 메서드의 이름과 반환값이 없어지므로 람다식을 익명함수라고도 한다.

-----


#### 스트림

지금까지 우리는 많은 수의 데이터를 다룰 때 컬렉션이나 배열에 데이터를 담고 원하는 결과를 얻기 위해 for문과 iterator를 이용해서 코드를 작성했다. 그러나 이런방식은 너무 길고 알아보기 어렵다. 그리고 재사용도 떨어진다.


또 데이터 소스마다 다른방식으로 다뤄야 한다. 예를 들어 리스트는 sort사용시 collection이나 iterator 같은 인터페이스로 컬렉션 다루는 방식을 표준화 했지만 각 컬렉션엔 같은 기능의 메서드가 중복되어 정의되어 있다. 예를 들어 List를 정렬할때 Collection.sort를 써야하고, 배열 정렬시엔 Array.sort를 쓰는 것 처럼

이러한 문제점을 해결하려 만든게 스트림이다. 스트림은 데이터 소스를 추상화 하고 데이터를 다루는데 자주 사용되는 메서드를 정의해놓았다. 데이터 소스를 추상화 했다는 것은 데이터 소스가 무엇이던 같은 방식으로 다룰수 있게 된 것과 코드의 재사용성이 높아진 것을 의미한다.

------


### 입출력

#### 입출력(I/O)과 스트림(stream)

I/O란 입출력을 말하고 컴퓨터 내부 또는 외부의 장치와 프로그램간의 데이터를 주고 받는 것을 말한다.

예를 들면 sysout 을 이용해서 화면에 데이터를 출력한다거나 키보드로부터 데이터를 입력받는다든가 이러는게 가장 기본적인 입출력의 예이다.

#### 스트림(Stream)

자바에서 입출력을 수행하려면 즉, 어느 한쪽에서 다른 쪽으로 데이터를 전달하려면 두 대상을 연결하고 데이터를 전송할 수 있는 무언가가 필요한데, 이것을 스트림이라고 정의했다. 

위에서 정의한 Stream과 입출력에서의 스트림은 같은 용어를 쓰지만 다른개념이다.


###### 스트림이란 데이터를 운반하는데 사용되는 연결통로이다.

스트림은 연속적인 데이터의 흐름을 물에 비유해서 붙여진 이름인데, 여러가지로 유사한 점이 많다. 물이 한쪽방향으로 흐르는 것과 같이 스트림은 단방향 통신만 가능하기 때문에 하나의 스트림으로 입력과 출력을 동시에 처리할 수 없다.

그래서 입력과 출력을 동시에 수행하려면 입력을 위한 입력 스트림(input stream)과 출력스트림(output stream), 모두 2개의 스트림이 필요하다.

스트림은 먼저보낸 데이터를 먼저 받게 되어있으며 중간에 건너뜀 없이 연속적으로 데이터를 주고 받는다.

큐와 같은 FIFO 구조로 되어있다고 생각하면 된다.


----------


#### 보조스트림

위에서 언급한 스트림 외에도 스트림의 기능을 보완하기 위한 보조스트림이 제공된다. 

보조스트림은 실제 데이터를 주고받는 스트림이 아니여서 데이터를 입출력하는 기능은 없지만 스트림의 기능을 향상시키거나 새로운 기능을 추가할 수 있다.

보조스트림만으로는 입출력을 처리할 수 없고 스트림을 먼저 생성한 후에 이를 이용해서 보조스트림을 생성해야 한다.

----


#### 문자 기반 스트림 - Reader, Writer

지금까지 위에서 본 스트림은 바이트 기반의 스트림이였다. 바이트 기반은 입출력 단위가 1바이트 라는 뜻이다. 이미 알고 있는 것과 같이 C언어와 달리 Java에서는 한 문자를 의미하는 char형이 1byte가 아니라 2byte이기 때문에 바이트 기반의 스트림으로 2byte인 문자를 처리하는 데에는 어려움이 있다. 이를 보완하기 위해 문자기반의 스트림이 제공된다.

문자 데이터를 입출력 할때는 바이트 기반의 스트림 대신 문자기반의 스트림을 사용한다.



