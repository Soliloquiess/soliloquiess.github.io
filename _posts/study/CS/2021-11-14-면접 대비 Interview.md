---
title: "[CS] 면접 대비 Interview"
layout: post
subtitle: CS
date: "2021-11-14-05:58:53 +0900"
categories: study
tags: CS
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---

# 브라우저 동작 방법

---
# 언어

---

<br><br>

#### 가비지 컬렉션이란?

 정리되지 않은 메모리, 유효하지 않은 메모리 주소인 가비지를 정리해주는 프로그램

 Heap 메모리를 재활용 하기위해 참조되지 않는 객체들을 해제시켜 가용한 공간을 만드는 작업

 프로그래머가 직접 메모리를 정리하지 않아도 되어 개발 속도가 대폭 향상된다.

 메모리를 언제 되찾을 지 결정하기 위한 오버헤드 발생 문제점 존재

<br><br>

#### Vector와 ArrayList의 차이는?

 Vector : 동기식. 한 스레드가 벡터 작업 중이면 다른 스레드가 벡터 보유 불가능

 ArrayList : 비동기식. 여러 스레드가 arraylist에서 동시 작업이 가능

<br><br>

#### String과 StringBuffer의 차이는?

 String : 불변. 문자를 수정하려면 지우고 다시 생성해야함 (new) → 문자열 연산이 많으면 기능 떨어짐

 StringBuffer : 가변. 한번 만들고 필요할 때 크기를 변경하여 문자를 변경함 (append()와 같이)

 StringBuilder : 동기화 지원X. 멀티스레드 환경에 부적합 → 싱글 스레드에서 StringBuffer보다 좋음

<br><br>

#### Serialization이란?

 직렬화. 객체의 상태 혹은 데이터 구조를 기록할 수 있는 포맷으로 변환해줌

 나중에 재구성 할 수 있게 자바 객체를 JSON으로 변환해주거나 JSON을 자바 객체로 변환해주는 라이브러리

<br><br>

#### Java의 메모리 영역은?

 - 메소드 / 스택 / 힙

 메소드 : 바이트 코드, 전역 변수, static 변수

 스택 : 매개 변수, 지역 변수 (사용 끝나면 바로 소멸, 컴파일 시에 메모리 할당)

 힙 : new로 생성된 객체(c에서는 malloc()). 호출이 끝나도 사라지지 않고 프로그램 실행 시 동적 할당

<br><br>

#### 오버로딩과 오버라이딩 차이는?

 오버로딩 : 메소드의 이름은 같고, 매개변수를 다르게 함으로써 여러 메소드를 만드는 것

 오버라이딩 : 부모클래스로부터 상속받은 메소드를 재정의하는 것. 자식 객체에서 오버라이딩한 메소드는 호출시 오버라이딩한 메소드가 우선시 되어 호출됨 (동일한 리턴타입, 메소드 이름, 매개변수를 가져야함)

<br><br>

#### 추상클래스와 인터페이스 차이는?

 추상클래스 : 클래스 내에 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 경우. extends를 통해 기능을 이용하고 확장하도록 하는 클래스

 인터페이스 : 모든 메소드가 추상 메소드인 경우 (여러 implements가 가능해 다중 상속 구현 가능)  뼈대만 있으며, 구현하는 모든 클래스에 대해 강제적으로 메소드를 구현하도록 만듬

<br><br>

#### 제네릭이란?

 클래스에서 사용할 타입을 클래스 외부에서 설정하도록 만드는 것

 제네릭으로 선언한 클래스는, 내가 원하는 타입으로 만들어 사용이 가능함

 <안에는 참조자료형(클래스, 인터페이스, 배열)만 가능함

 (기본자료형을 이용하기 위해선 wrapper 클래스를 활용해야 함)

<br><br>

#### 접근 지정자 4가지

 public : 모든 접근 허용

 protected : 상속받은 클래스 or 같은 패키지만 접근 허용

 default : 기본 제한자. 자신 클래스 내부 or 같은 패키지만 접근 허용

 private : 외부 접근 불가능. 같은 클래스 내에서만 가능

<br><br>

#### Call by Value vs Call by Reference

 값에 의한 호출 : 값을 복사해서 새로운 함수로 넘기는 호출 방식. 원본 값 변경X

 참조에 의한 호출 :  주소 값을 인자로 전달하는 호출 방식. 원본 값 변경O

<br><br>

#### 배열과 연결리스트 차이는?

 배열은 인덱스를 가짐. 원하는 데이터를 한번에 접근하기 때문에 접근 속도 빠름.

 크기 변경이 불가능하며, 데이터 삽입 및 삭제 시 그 위치의 다음 위치부터 모든 데이터 위치를 변경해야 되는 단점 존재

 연결리스트는 인덱스 대신에 현재 위치의 이전/다음 위치를 기억함.

 크기는 가변적. 인덱스 접근이 아니기 때문에 연결되어 있는 링크를 쭉 따라가야 접근이 가능함. (따라서 배열보다 속도 느림)

 데이터 삽입 및 삭제는 논리적 주소만 바꿔주면 되기 때문에 매우 용이함

 - 데이터의 양이 많고 삽입/삭제가 없음. 데이터 검색을 많이 해야할 때 → Array
 - 데이터의 양이 적고 삽입/삭제 빈번함 → LinkedList

<br><br>

#### Hash란?

 데이터 삽입 및 삭제 시, 기존 데이터를 밀어내거나 채우지 않고 데이터와 연관된 고유한 숫자를 생성해 인덱스로 사용하는 방법

 검색 속도가 매우 빠르다

<br><br>

#### Java 컴파일 과정

 컴파일러가 소스코드를 자바 바이트 코드(.class)로 변환

 JVM이 바이트코드를 기계어로 변환하고, 인터프리터 방식으로 애플리케이션 실행

<br><br>

#### C++ 실행 과정

 - 전처리 : #define, #include 지시자 해석

 - 컴파일 : 고급 언어 소스 프로그램 입력 받고, 어셈블리 파일 만듬

 - 어셈블 : 어셈블리 파일을 오브젝트 파일로 만듬

 - 링크 : 오브젝트 파일을 엮어 실행파일을 만들고 라이브러리 함수 연결

 - 실행

<br><br>

#### 메모리, 성능을 개선하기 위해 생각나는 방법은?

 static을 사용해 선언한다.

 인스턴스 변수에 접근할 일이 없으면, static 메소드를 선언하여 호출하자

 모든 객체가 서로 공유할 수 있기 때문에 메모리가 절약되고 연속적으로 그 값의 흐름을 이어갈 수 있는 장점이 존재

<br><br>

#### 클래스와 구조체의 차이는?

 구조체는 하나의 구조로 묶일 수 있는 변수들의 집합이다.

 클래스는 변수뿐만 아니라, 메소드도 포함시킬 수 있음

 (물론 함수 포인터를 이용해 구조체도 클래스처럼 만들어 낼 수도 있다.)

<br><br>

#### 스레드는 어떤 방식으로 생성하나요? 장단점도 말해주세요

 생성방법 : Runnable(인터페이스)로 선언되어 있는 클래스 or Thread 클래스를 상속받아서 run() 메소드를 구현해주면 됨

 장점 : 빠른 프로세스 생성, 메모리를 적게 사용 가능, 정보 공유가 쉬움

 단점 : 데드락에 빠질 위험이 존재

<br><br>

#### 포인터를 이해하기 쉽도록 설명해주세요

 포인터는 메모리 주소를 저장하는 변수임

 주소를 지칭하고 있는 곳인데, 예를 들면 엘리베이터에서 포인터는 해당 층을 표시하는 버튼이라고 할 수 있음. 10층을 누르면 10층으로 이동하듯, 해당 위치를 가리키고 있는 변수!

 포인터를 사용할 때 주의할 점은, 어떤 주소를 가리키고 있어야만 사용이 가능함


 -----


 # 운영체제

---

<br><br>

#### 프로세스와 스레드 차이

  프로세스는 메모리 상에서 실행중인 프로그램을 말하며, 스레드는 이 프로세스 안에서 실행되는 흐름 단위를 말한다.

  프로세스마다 최소 하나의 스레드를 보유하고 있으며, 각각 별도의 주소공간을 독립적으로 할당받는다. (code, data, heap, stack)

  스레드는 이중에 stack만 따로 할당받고 나머지 영역은 스레드끼리 서로 공유한다.

  ##### [요약]

  **프로세스** :  자신만의 고유 공간과 자원을 할당받아 사용

  **스레드** : 다른 스레드와 공간과 자원을 공유하면서 사용

<br><br>

#### 멀티 프로세스로 처리 가능한 걸 굳이 멀티 스레드로 하는 이유는?

  프로세스를 생성하여 자원을 할당하는 시스템 콜이 감소함으로써 자원의 효율적 관리가 가능함

  프로세스 간의 통신(IPC)보다 스레드 간의 통신 비용이 적어 작업들 간 부담이 감소함

  대신, 멀티 스레드를 사용할 때는 공유 자원으로 인한 문제 해결을 위해 '동기화'에 신경써야 한다.

<br><br>

#### 교착상태(DeadLock)가 무엇이며, 4가지 조건은?

  프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태를 말한다.

  시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생하는 문제임

  교착상태의 4가지 조건은 아래와 같다.

  - 상호배제 : 프로세스들이 필요로 하는 자원에 대해 배타적 통제권을 요구함
  - 점유대기 : 프로세스가 할당된 자원을 가진 상태에서 다른 자원 기다림
  - 비선점 : 프로세스가 어떤 자원의 사용을 끝날 때까지 그 자원을 뺏을 수 없음
  - 순환대기 : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있음

  이 4가지 조건 중 하나라도 만족하지 않으면 교착상태는 발생하지 않음

  (순환대기는 점유대기와 비선점을 모두 만족해야만 성립합. 따라서 4가지가 서로 독립적이진 않음)

<br><br>

#### 교착상태 해결 방법 4가지

  - 예방
  - 회피
  - 무시
  - 발견

<br><br>

#### 메모리 계층 (상-하층 순)

  |  레지스터  |
  | :--------: |
  |    캐시    |
  |   메모리   |
  | 하드디스크 |

<br><br>

#### 메모리 할당 알고리즘 First fit, Next fit, Best fit 결과

  - First fit : 메모리의 처음부터 검사해서 크기가 충분한 첫번째 메모리에 할당
  - Next fit : 마지막으로 참조한 메모리 공간에서부터 탐색을 시작해 공간을 찾음
  - Best fit : 모든 메모리 공간을 검사해서 내부 단편화를 최소화하는 공간에 할당

<br><br>

#### 페이지 교체 알고리즘에 따른 페이지 폴트 방식

  OPT : 최적 교체. 앞으로 가장 오랫동안 사용하지 않을 페이지 교체 (실현 가능성 희박)

  FIFO : 메모리가 할당된 순서대로 페이지를 교체

  LRU : 최근에 가장 오랫동안 사용하지 않은 페이지를 교체

  LFU : 사용 빈도가 가장 적은 페이지를 교체

  NUR : 최근에 사용하지 않은 페이지를 교체

<br><br>

#### 외부 단편화와 내부 단편화란?

  외부 단편화 : 작업보다 많은 공간이 있더라도 실제로 그 작업을 받아들일 수 없는 경우 (메모리 배치에 따라 발생하는 문제)

  내부 단편화 : 작업에 필요한 공간보다 많은 공간을 할당받음으로써 발생하는 내부의 사용 불가능한 공간

<br><br>

#### 가상 메모리란?

  메모리에 로드된, 실행중인 프로세스가 메모리가 아닌 가상의 공간을 참조해 마치 커다란 물리 메모리를 갖는 것처럼 사용할 수 있게 해주는 기법

<br><br>

#### 페이징과 세그먼테이션이란?

  ##### 페이징

  페이지 단위의 논리-물리 주소 관리 기법.
  논리 주소 공간이 하나의 연속적인 물리 메모리 공간에 들어가야하는 제약을 해결하기 위한 기법
  논리 주소 공간과 물리 주소 공간을 분리해야함(주소의 동적 재배치 허용), 변환을 위한 MMU 필요

  특징 : 외부 단편화를 없앨 수 있음. 페이지가 클수록 내부 단편화도 커짐

  ##### 세그먼테이션

  사용자/프로그래머 관점의 메모리 관리 기법. 페이징 기법은 같은 크기의 페이지를 갖는 것 과는 다르게 논리적 단위(세그먼트)로 나누므로 미리 분할하는 것이 아니고 메모리 사용할 시점에 할당됨

<br><br>

#### 뮤텍스, 세마포어가 뭔지, 차이점은?

  ##### 세마포어

  운영체제에서 공유 자원에 대한 접속을 제어하기 위해 사용되는 신호
  공유자원에 접근할 수 있는 최대 허용치만큼만 동시에 사용자 접근 가능
  스레드들은 리소스 접근 요청을 할 수 있고, 세마포어는 카운트가 하나씩 줄어들게 되며 리소스가 모두 사용중인 경우(카운트=0) 다음 작업은 대기를 하게 된다

  ##### 뮤텍스

  상호배제, 제어되는 섹션에 하나의 스레드만 허용하기 때문에, 해당 섹션에 접근하려는 다른 스레드들을 강제적으로 막음으로써 첫번재 스레드가 해당 섹션을 빠져나올 때까지 기다리는 것
  (대기열(큐) 구조라고 생각하면 됨)

  ##### 차이점

  - 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없음
  - 세마포어는 소유 불가능하지만, 뮤택스는 소유가 가능함
  - 동기화의 개수가 다름

<br><br>

#### Context Switching이란?

  하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전의 프로세스 상태를 보관하고 새로운 프로세스의 상태를 적재하는 작업

  한 프로세스의 문맥은 그 프로세스의 PCB에 기록됨

<br><br>

#### 사용자 수준 스레드 vs 커널 수준 스레드 차이는?

  ##### 사용자 수준 스레드

  장점 : context switching이 없어서 커널 스레드보다 오버헤드가 적음 (스레드 전환 시 커널 스케줄러 호출할 필요가 없기 때문)

  단점 : 프로세스 내의 한 스레드가 커널로 진입하는 순간, 나머지 스레드들도 전부 정지됨 (커널이 스레드의 존재를 알지 못하기 때문에)

  ##### 커널 수준 스레드

  장점 : 사용자 수준 스레드보다 효율적임. 커널 스레드를 쓰면 멀티프로세서를 활용할 수 있기 때문이다. 사용자 스레드는 CPU가 아무리 많아도 커널 모드의 스케줄이 되지 않으므로, 각 CPU에 효율적으로 스레드 배당할 수가 없음

  단점 : context switching이 발생함. 이 과정에서 프로세서 모드가 사용자 모드와 커널 모드 사이를 움직이기 때문에 많이 돌아다닐 수록 성능이 떨어지게 된다.

<br><br>

#### 가상메모리란?

  프로세스에서 사용하는 메모리 주소와 실제 물리적 메모리 주소는 다를 수 있음

  따라서 메모리 = 실제 + 가상 메모리라고 생각하면 안됨

  메모리가 부족해서 가상메모리를 사용하는 건 맞지만, 가상메모리를 쓴다고 실제 메모리처럼 사용하는 것은 아님

  실제 메모리 안에 공간이 부족하면, **현재 사용하고 있지 않은 데이터를 빼내어 가상 메모리에 저장해두고, 실제 메모리에선 처리만 하게 하는 것이 가상 메모리의 역할**이다.

  즉, 실제 메모리에 놀고 있는 공간이 없게 계속 일을 시키는 것. 이를 도와주는 것이 '가상 메모리'

<br><br>

#### fork()와 vfork()의 차이점은?

  fork()는 부모 프로세스의 메모리를 복사해서 사용

  vfork()는 부모 프로세스와의 메모리를 공유함. 복사하지 않기 때문에 fork()보다 생성 속도 빠름.
  하지만 자원을 공유하기 때문에 자원에 대한 race condition이 발생하지 않도록 하기 위해 부모 프로세스는 자식 프로세스가 exit하거나 execute가 호출되기 전까지 block된다

<br><br>

#### Race Condition이란?

  두 개 이상의 프로세스가 공통 자원을 병행적으로 읽거나 쓸 때, 공용 데이터에 대한 접근이 순서에 따라 실행 결과가 달라지는 상황

  Race Condition이 발생하게 되면, 모든 프로세스에 원하는 결과가 발생하는 것을 보장할 수 없음. 따라서 이러한 상황은 피해야 하며 상호배제나 임계구역으로 해결이 가능하다.

<br><br>

#### 리눅스에서 시스템 콜과 서브루틴의 차이는?

  우선 커널을 확인하자

  <br>

  <img src="https://s24255.pcdn.co/wp-content/uploads/2012/07/Kernel.png">

  <br>

  커널은 하드웨어를 둘러싸고 있음

  즉, 커널은 하드웨어를 제어하기 위한 일종의 API와 같음

  <br>

  서브루틴(Subr>outine)은 우리가 프로그래밍할 때 사용하는 대부분의 API를 얘기하는 것

  ```
  stdio.h에 있는 printf나 scanf
  string.h에 있는 strcmp나 strcpy
  ```


  <br><br>

  #### 서브루틴과 시스템 콜의 차이는?

  서브루틴이 시스템 콜을 호출하고, 시스템 콜이 수행한 결과를 서브루틴에 보냄

  시스템 콜 호출 시, 커널이 호출되고 커널이 수행한 임의의 결과 데이터를 다시 시스템 콜로 보냄

  즉, 진행 방식은 아래와 같다.

  ```
  서브루틴이 시스템 콜 호출 → 시스템 콜은 커널 호출
  → 커널은 자신의 역할을 수행하고 나온 결과 데이터를 시스템 콜에게 보냄
  → 시스템 콜이 다시 서브루틴에게 보냄
  ```

  실무로 사용할 때 둘의 큰 차이는 없음(api를 호출해서 사용하는 것은 동일)

<br><br>

<br><br>


-----


# 데이터베이스

------

<br><br>

#### 오라클 시퀀스(Oracle Sequence)

 UNIQUE한 값을 생성해주는 오라클 객체

 시퀀스를 생성하면 PK와 같이 순차적으로 증가하는 컬럼을 자동 생성할수 있다.

 ```sql
 CREATE SEQUENCE 시퀀스이름
 	START WITH n
 	INCREMENT BY n ...
 ```

<br><br>

#### DBMS란?

 데이터베이스 관리 시스템

 다수의 사용자가 데이터베이스 내의 데이터를 접근할 수 있도록 설계된 시스템

<br><br>

#### DBMS의 기능은?

- 정의 기능(DDL: Data Definition Language)  
  - 데이터베이스가 어떤 용도이며 어떤 식으로 이용될것이라는 것에 대한 정의가 필요함  
  - CREATE, ALTER, DROP, RENAME

- 조작 기능(DML: Data Manipulation Language)  
  - 데이터베이스를 만들었을 때 그 정보를 수정하거나 삭제 추가 검색 할 수 있어야함  
  - SELECT, INSERT, UPDATE, DELETE

- 제어 기능(DCL: Data Control Language)  
  - 데이터베이스에 접근하고 객체들을 사용하도록 권한을 주고 회수하는 명령  
  - GRANT REVOKE

<br><br>

#### UML이란?

 프로그램 설계를 표현하기 위해 사용하는 그림으로 된 표기법

 이해하기 힘든 복잡한 시스템을 의사소통하기 위해 만듬

<br><br>

#### DB에서 View는 무엇인가? 가상 테이블이란?

 허용된 데이터를 제한적으로 보여주기 위한 것

 하나 이상의 테이블에서 유도된 가상 테이블이다.

 - 사용자가 view에 접근했을 때 해당하는 데이터를 원본에서 가져온다.

 view에 나타나지 않은 데이터를 간편히 보호할 수 있는 장점 존재

<br><br>

#### 정규화란?

 중복을 최대한 줄여 데이터를 구조화하고, 불필요한 데이터를 제거해 데이터를 논리적으로 저장하는 것

 이상현상이 일어나지 않도록 정규화 시킨다!

<br><br>

#### 이상현상이란?

 릴레이션에서 일부 속성들의 종속으로 인해 데이터 중복이 발생하는 것 (insert, update, delete)

<br><br>

#### 데이터베이스를 설계할 때 가장 중요한 것이 무엇이라고 생각하나요?

 무결성을 보장해야 합니다.

 ##### 무결성 보장 방법은?

 데이터를 조작하는 프로그램 내에서 데이터 생성, 수정, 삭제 시 무결성 조건을 검증한다.

 트리거 이벤트 시 저장 SQL을 실행하고 무결성 조건을 실행한다.

 DB제약조건 기능을 선언한다.

<br><br>

#### 데이터베이스 무결성이란?

 테이블에 있는 모든 행들이 유일한 식별자를 가질 것을 요구함 (같은 값 X)

 외래키 값은 NULL이거나 참조 테이블의 PK값이어야 함

 한 컬럼에 대해 NULL 허용 여부와 자료형, 규칙으로 타당한 데이터 값 지정

<br><br>

#### 트리거란?

 자동으로 실행되도록 정의된 저장 프로시저

 (insert, update, delete문에 대한 응답을 자동으로 호출한다.)

 ##### 사용하는 이유는?

 업무 규칙 보장, 업무 처리 자동화, 데이터 무결성 강화

<br><br>

#### 오라클과 MySQL의 차이는?

 일단 Oracle이 MySQL보다 훨~씬 좋음

 오라클 : 대규모 트랜잭션 로드를 처리하고, 성능 최적화를 위해 여러 서버에 대용량 DB를 분산함

 MySQL : 단일 데이터베이스로 제한되어있고, 대용량 데이터베이스로는 부적합. 작은 프로젝트에서 적용시키기 용이하며 이전 상태를 복원하는데 commit과 rollback만 존재

<br><br>

#### Commit과 Rollback이란?

 Commit : 하나의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산

 Rollback : 하나의 트랜잭션 처리가 비정상적으로 종료되어 DB의 일관성을 깨뜨렸을 때, 모든 연산을 취소시키는 연산

<br><br>

#### JDBC와 ODBC의 차이는?

 - JDBC
   자바에서 DB에 접근하여 데이터를 조회, 삽입, 수정, 삭제 가능
   DBMS 종류에 따라 맞는 jdbc를 설치해야함

 - ODBC
   응용 프로그램에서 DB 접근을 위한 표준 개방형 응용 프로그램 인터페이스
   MS사에서 만들었으며, Excel/Text 등 여러 종류의 데이터에 접근할 수 있음

<br><br>

#### 데이터 베이스에서 인덱스(색인)이란 무엇인가요

- 책으로 비유하자면 목차로 비유할 수 있다.
- DBMS에서 저장 성능을 희생하여 데이터 읽기 속도를 높이는 기능
- 데이터가 정렬되어 들어간다
- 양이 많은 테이블에서 일부 데이터만 불러 왔을 때, 이를 풀 스캔 시 처리 성능 떨어짐
- 종류
  - B+-Tree 인덱스 : 원래의 값을 이용하여 인덱싱
  - Hash 인덱스 : 칼럼 값으로 해시 값 게산하여 인덱싱, 메모리 기반 DB에서 많이 사용
  - B>Hash
- 생성시 고려해야 할 점
  - 테이블 전체 로우 수 15%이하 데이터 조회시 생성
  - 테이블 건수가 적으면 인덱스 생성 하지 않음, 풀 스캔이 빠름
  - 자주 쓰는 컬럼을 앞으로 지정
  - DML시 인덱스에도 수정 작업이 동시에 발생하므로 DML이 많은 테이블은 인덱스 생성 하지 않음

<br><br>

--------


# 네트워크

---

<br><br>

#### OSI 7계층을 설명하시오

> OSI 7계층이란, 통신 접속에서 완료까지의 과정을 7단계로 정의한 국제 통신 표준 규약

 **물리** : 전송하는데 필요한 기능을 제공 ( 통신 케이블, 허브 )

 **데이터링크** : 송/수신 확인. MAC 주소를 가지고 통신함 ( 브릿지, 스위치 )

 **네트워크** : 패킷을 네트워크 간의 IP를 통해 데이터 전달 ( 라우팅 )

 **전송** : 두 host 시스템으로부터 발생하는 데이터 흐름 제공

 **세션** : 통신 시스템 사용자간의 연결을 유지 및 설정함

 **표현** : 세션 계층 간의 주고받는 인터페이스를 일관성있게 제공

 **응용** : 사용자가 네트워크에 접근할 수 있도록 서비스 제공

<br><br>

#### TCP/IP 프로토콜을 스택 4계층으로 짓고 설명하시오

 - ##### LINK 계층

    물리적인 영역의 표준화에 대한 결과

    가장 기본이 되는 영역으로 LAN, WAN과 같은 네트워크 표준과 관련된 프로토콜을 정의하는 영역이다

 - ##### IP 계층

    경로 검색을 해주는 계층임

    IP 자체는 비연결지향적이며, 신뢰할 수 없는 프로토콜이다

    데이터를 전송할 때마다 거쳐야할 경로를 선택해주지만, 경로가 일정하지 않음. 또한 데이터 전송 중에 경로상 문제가 발생할 때 데이터가 손실되거나 오류가 발생하는 문제가 발생할 수 있음. 따라서 IP 계층은 오류 발생에 대한 대비가 되어있지 않은 프로토콜임

 - ##### TCP/UDP (전송) 계층

    데이터의 실제 송수신을 담당함

    UDP는 TCP에 비해 상대적으로 간단하고, TCP는 신뢰성잇는 데이터 전송을 담당함

    TCP는 데이터 전송 시, IP 프로토콜이 기반임 (IP는 문제 해결에 문제가 있는데 TCP가 신뢰라고?)

    → IP의 문제를 해결해주는 것이 TCP인 것. 데이터의 순서가 올바르게 전송 갔는지 확인해주며 대화를 주고받는 방식임. 이처럼 확인 절차를 걸치며 신뢰성 없는 IP에 신뢰성을 부여한 프로토콜이 TCP이다

 - ##### 애플리케이션 계층

    서버와 클라이언트를 만드는 과정에서 프로그램 성격에 따라 데이터 송수신에 대한 약속들이 정해지는데, 이것이 바로 애플리케이션 계층이다

<br><br>

#### TCP란?

 서버와 클라이언트의 함수 호출 순서가 중요하다

 **서버** : socket() 생성 → bind() 소켓 주소할당 → listen() 연결요청 대기상태 → accept() 연결허용 → read/write() 데이터 송수신 → close() 연결종료

 **클라이언트** : socket() 생성 → connect() 연결요청 → read/write() 데이터 송수신 → close() 연결종료

 ##### 둘의 차이는?

 클라이언트 소켓을 생성한 후, 서버로 연결을 요청하는 과정에서 차이가 존재한다.

 서버는 listen() 호출 이후부터 연결요청 대기 큐를 만들어 놓고, 그 이후에 클라이언트가 연결 요청을 할 수 있다. 이때 서버가 바로 accept()를 호출할 수 있는데, 연결되기 전까지 호출된 위치에서 블로킹 상태에 놓이게 된다.

 이처럼 연결지향적인 TCP는 신뢰성 있는 데이터 전송이 가능함 (3-way handshaking)

 흐름제어와 혼잡제어를 지원해서 데이터 순서를 보장해줌

 - 흐름제어 : 송신 측과 수신 측의 데이터 처리 속도 차이를 조절해주는 것

 - 혼잡 제어 : 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것

 정확성 높은 전송을 하기 위해 속도가 느린 단점이 있고, 주로 웹 HTTP 통신, 이메일, 파일 전송에 사용됨

<br><br>

#### 3-way handshaking이란?

 TCP 소켓은 연결 설정과정 중에 총 3번의 대화를 주고 받는다.

 (SYN : 연결 요청 플래그 / ACK : 응답)

 - 클라이언트는 서버에 접속 요청하는 SYN(M) 패킷을 보냄
 - 서버는 클라이언트 요청인 SYN(M)을 받고, 클라이언트에게 요청을 수락한다는 ACK(M+1)와 SYN(N)이 설정된 패킷을 발송함
 - 클라이언트는 서버의 수락 응답인 ACK(M+1)와 SYN(N) 패킷을 받고, ACK(N+1)를 서버로 보내면 연결이 성립됨
 - 클라이언트가 연결 종료하겠다는 FIN 플래그를 전송함
 - 서버는 클라이언트의 요청(FIN)을 받고, 알겠다는 확인 메시지로 ACK를 보냄. 그 이후 데이터를 모두 보낼 때까지 잠깐 TIME_OUT이 됨
 - 데이터를 모두 보내고 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN플래그를 전송함
 - 클라이언트는 FIN 메시지를 확인했다는 ACK를 보냄
 - 클라이언트의 ACK 메시지를 받은 서버는 소켓 연결을 close함
 - 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해서, 일정 시간동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거침 ( TIME_WAIT )

<br><br>

#### UDP란?

 TCP의 대안으로, IP와 같이 쓰일 땐 UDP/IP라고도 부름

 TCP와 마찬가지로, 실제 데이터 단위를 받기 위해 IP를 사용함. 그러나 TCP와는 달리 메시지를 패킷으로 나누고, 반대편에서 재조립하는 등의 서비스를 제공하지 않음
 즉, 여러 컴퓨터를 거치지 않고 데이터를 주고 받을 컴퓨터끼리 직접 연결할 때 UDP를 사용한다.

 UDP를 사용해 목적지(IP)로 메시지를 보낼 수 있으며, 컴퓨터를 거쳐 목적지까지 도달할 수도 있음
 (도착하지 않을 가능성도 존재함)

 정보를 받는 컴퓨터는 포트를 열어두고, 패킷이 올 때까지 기다리며 데이터가 오면 모두 다 받아들인다. 패킷이 도착했을 때 출발지에 대한 정보(IP와 PORT)를 알 수 있음

 UDP는 이런 특성 때문에 비신뢰적이고, 안정적이지 않은 프로토콜임. 하지만 TCP보다 속도가 매우 빠르고 편해서 데이터 유실이 일어나도 큰 상관이 없는 스트리밍이나 화면 전송에 사용됨

<br><br>

#### HTTP와 HTTPS의 차이는?

 HTTP 동작 순서 : TCP → HTTP

 HTTPS 동작 순서 : TCP → SSL → HTTP

 SSL(Secure Socket Layer)을 쓰냐 안쓰냐의 차이다. SSL 프로토콜은 정보를 암호화시키고 이때 공개키와 개인키 두가지를 이용한다.

 HTTPS는 인터넷 상에서 정보를 암호화하기 위해 SSL 프로토콜을 이용해 데이터를 전송하고 있다는 것을 말한다. 즉, 문서 전송시 암호화 처리 유무에 따라 HTTP와 HTTPS로 나누어지는 것

 모든 사이트가 HTTPS로 하지 않는 이유는, 암호화 과정으로 인한 속도 저하가 발생하기 때문이다.

<br><br>

#### GET과 POST의 차이는?

 둘다 HTTP 프로토콜을 이용해 서버에 무언가 요청할 때 사용하는 방식이다.

 GET 방식은, URL을 통해 모든 파라미터를 전달하기 때문에 주소창에 전달 값이 노출됨. URL 길이가 제한이 있기 때문에 전송 데이터 양이 한정되어 있고, 형식에 맞지 않으면 인코딩해서 전달해야 함

 POST 방식은 HTTP BODY에 데이터를 포함해서 전달함. 웹 브라우저 사용자의 눈에는 직접적으로 파라미터가 노출되지 않고 길이 제한도 없음.

 보통 GET은 가져올 때, POST는 수행하는 역할에 활용한다.

 GET은 SELECT 성향이 있어서 서버에서 어떤 데이터를 가져와서 보여주는 용도로 활용

 POST는 서버의 값이나 상태를 바꾸기 위해 활용

<br><br>

#### IOCP를 설명하시오

 IOCP는 어떤 I/O 핸들에 대해, 블록 되지 않게 비동기 작업을 하면서 프로그램 대기시간을 줄이는 목적으로 사용된다.

 동기화 Object 세마포어의 특성과, 큐를 가진 커널 Object다. 대부분 멀티 스레드 상에서 사용되고, 큐는 자체적으로 운영하는 특징 때문에 스레드 풀링에 적합함

 동기화와 동시에 큐를 통한 데이터 전달 IOCP는, 스레드 풀링을 위한 것이라고 할 수 있음

 ##### POOLING이란?

 여러 스레드를 생성하여 대기시키고, 필요할 때 가져다가 사용한 뒤에 다시 반납하는 과정
 (스레드의 생성과 파괴는 상당히 큰 오버헤드가 존재하기 때문에 이 과정을 이용한다)

 IOCP의 장점은 사용자가 설정한 버퍼만 사용하기 때문에 더 효율적으로 작동시킬 수 있음.
 (기존에는 OS버퍼, 사용자 버퍼로 따로 분리해서 운영했음)

 커널 레벨에서는 모든 I/O를 비동기로 처리하기 때문에 효율적인 순서에 따라 접근할 수 있음

<br><br>

#### 라우터와 스위치의 차이는?

 라우터는 3계층 장비로, 수신한 패킷의 정보를 보고 경로를 설정해 패킷을 전송하는 역할을 수행하는 장비

 스위치는 주로 내부 네트워크에 위치하며 MAC 주소 테이블을 이용해 해당 프레임을 전송하는 2계층 장비

<br><br>

--------------------------


# 웹

---

<br>

## 스프링

<br>

#### 스프링이 뭔지 간단히 설명해보세요

  스프링은 자바 플랫폼을 위한 오픈소스 애플리케이션 프레임워크입니다. 자바 SE로 된 자바 객체 POJO를 자바 EE에 의존적이지 않게 연결해주는 역할을 합니다.
  스프링의 특징으로는 크기와 부하 측면에서 경량 시킨 것과, IOC 기술로 애플리케이션의 느슨한 결합을 도모시킨 것이 있습니다.

<br><br>

#### 스프링이랑 스프링 부트는 차이점이 뭔가요?

  스프링 부트는 스프링에서 사용하는 프로젝트를 간편하게 셋업할 수 있는 서브 프로젝트입니다. 독립 컨테이너에서 동작할 수 있기 때문에 임베디드 톰켓이 자동으로 실행되구요. 임베디드 컨테이너에서 애플리케이션을 실행시키기에는 다소 불안전해서 큰 프로젝트는 사용하지 않는 것이 좋습니다.

<br><br>

#### MVC패턴이란?

  MVC 패턴은 코드의 재사용에 유용하며, 사용자 인터페이스와 응용 프로그램 개발에 소요되는 시간을 줄여주는 효과적인 설계 방식을 말합니다.

  구성요소로는 Model, View, Controller가 있는데요. 모델은 핵심적인 비즈니스 로직을 담당하여 데이터베이스를 관리하는 부분이고, 뷰는 사용자에게 보여주는 화면, 컨트롤러는 모델과 뷰 사이에서 정보 교환을 할 수 있도록 연결시켜주는 역할을 합니다.

<br><br>

#### MVC1이랑 MVC2 패턴 차이에 대해 설명해주세요.

  모델1은 JSP페이지 안에서 로직 처리를 위해 자바 코드가 함께 사용됩니다. 요청이 오면, 직접 자바빈이나 클래스를 이용해 작업을 처리하고, 이를 클라이언트에 출력해줍니다. 구조가 단순한 장점이 있지만, JSP 내에서 html 코드와 자바 코드가 같이 사용되면서 복잡해지고 유지보수가 어려운 단점이 있습니다.

  모델2는 이와는 다르게 모든 처리를 JSP에서만 담당하는 것이 아니라 서블릿을 만들어 역할 분담을 하는 패턴입니다. 요청 결과를 출력해주는 뷰만 JSP가 담당하고, 흐름을 제어해주고 비즈니스 로직에 해당하는 컨트롤러의 역할을 서블릿이 담당하게 됩니다. 이처럼 역할을 분담하면서 유지보수가 용이해지는 장점이 있지만 습득하기 힘들고 구조가 복잡해지는 단점도 있습니다.

<br><br>

#### 스프링 MVC 구조 흐름에 대해 과정대로 설명해보세요.

  우선, 디스패처 서블릿이 클라이언트로부터 요청을 받으면, 이를 요청할 핸들러 이름을 알기 위해 핸들러맵핑에게 물어봅니다.

  핸들러맵핑은 요청 url을 보고 핸들러 이름을 디스패처 서블릿에게 알려줍니다. 이때 핸들러를 실행하기 전/후에 처리할 것들을 인터셉터로 만들어 줍니다.

  디스패처 서블릿은 해당 핸들러에게 제어권을 넘겨주고, 이 핸들러는 응답에 필요한 서비스를 호출하고 렌더링해야 하는 뷰 이름을 판단하여 디스패처 서블릿에게 전송해줍니다.

  디스패처 서블릿은 받은 뷰 이름을 뷰 리졸버에게 전달해 응답에 필요한 뷰를 만들라고 명령합니다.

  이때 해당하는 뷰는 디스패처 서블릿에게 받은 모델과 컨트롤러를 활용해 원하는 응답을 생성해서 다시 보내줍니다.

  디스패처 서블릿은 뷰로부터 받은 것을 클라이언트에게 응답해줍니다.

<br><br>

#### 스프링 필터랑 인터셉터의 차이점은 뭔가요?

  필터와 인터셉터는 실행되는 시점에서 차이가 있습니다. 필터는 웹 애플리케이션에 등록을 하고, 인터셉터는 스프링의 context에 등록을 합니다. 따라서 컨트롤러에 들어가기 전 작업을 처리하기 위해 사용하는 공통점이 있지만, 호출되는 시점에서 차이가 존재합니다.

<br><br>

#### IOC란?

  IOC란, 인스턴스의 생성부터 소멸까지 개발자가 아닌 컨테이너가 대신 관리해주는 것을 말합니다. 인스턴스 생성의 제어를 서블릿과 같은 bean을 관리해주는 컨테이너가 관리합니다.

<br><br>


#### Dispatcher-Servlet이란?

  서블릿 컨테이너에서 HTTP 프로토콜을 통해 들어오는 모든 요청을 제일 앞에서 처리해주는 프론트 컨트롤러를 말합니다.

 따라서 서버가 받기 전에, 공통처리 작업을 디스패처 서블릿이 처리해주고 적절한 세부 컨트롤러로 작업을 위임해줍니다.

 디스패처 서블릿이 처리하는 url 패턴을 지정해줘야 하는데, 일반적으로는 .mvc와 같은 패턴으로 처리하라고 미리 지정해줍니다.


 디스패처 서블릿으로 인해 web.xml이 가진 역할이 상당히 축소되었습니다. 기존에는 모든 서블릿을 url 매핑 활용을 위해 모두 web.xml에 등록해 주었지만, 디스패처 서블릿은 그 전에 모든 요청을 핸들링해주면서 작업을 편리하게 할 수 있도록 도와줍니다. 또한 이 서블릿을 통해 MVC를 사용할 수 있기 때문에 웹 개발 시 큰 장점을 가져다 줍니다.

<br><br>

#### DI(Dependency Injection)란?

 스프링 컨테이너가 지원하는 핵심 개념 중 하나로, 설정 파일을 통해 객체간의 의존관계를 설정하는 역할을 합니다.

 각 클래스 사이에 필요로 하는 의존관계를 Bean 설정 정보 바탕으로 컨테이너가 자동으로 연결합니다.

 객체는 직접 의존하고 있는 객체를 생성하거나 검색할 필요가 없으므로 코드 관리가 쉬워지는 장점이 있습니다.

<br><br>

#### AOP(Aspect Oriented Programming)란?

 공통의 관심 사항을 적용해서 발생하는 의존 관계의 복잡성과 코드 중복을 해소해줍니다.

 각 클래스에서 공통 관심 사항을 구현한 모듈에 대한 의존관계를 갖기 보단, Aspect를 이용해 핵심 로직을 구현한 각 클래스에 공통 기능을 적용합니다.

 간단한 설정만으로도 공통 기능을 여러 클래스에 적용할 수 있는 장점이 있으며 핵심 로직 코드를 수정하지 않고도 웹 애플리케이션의 보안, 로깅, 트랜잭션과 같은 공통 관심 사항을 AOP를 이용해 간단하게 적용할 수 있습니다.

<br><br>

#### AOP 용어들을 설명해보세요

 Advice : 언제 공통 관심기능을 핵심 로직에 적용할지 정의

 Joinpoint : Advice를 적용이 가능한 지점을 의미 (before, after 등등)

 Pointcut : Joinpoint의 부분집합으로, 실제로 Advice가 적용되는 Joinpoint를 나타냄

 Weaving : Advice를 핵심 로직코드에 적용하는 것

 Aspect : 여러 객체에 공통으로 적용되는 공통 관심 사항을 말함. 트랜잭션이나 보안 등이 Aspect의 좋은 예

<br><br>

#### DAO(Data Access Object)란?

 DB에 데이터를 조회하거나 조작하는 기능들을 전담합니다.

 Mybatis를 이용할 때는, mapper.xml에 쿼리문을 작성하고 이를 mapper 클래스에서 받아와 DAO에게 넘겨주는 식으로 구현합니다.

<br><br>

#### Annotation이란?

 소스코드에 @어노테이션의 형태로 표현하며 클래스, 필드, 메소드의 선언부에 적용할 수 있는 특정기능이 부여된 표현법을 말합니다.

 애플리케이션 규모가 커질수록, xml 환경설정이 매우 복잡해지는데 이러한 어려움을 개선시키기 위해 자바 파일에 어노테이션을 적용해서 개발자가 설정 파일 작업을 할 때 발생시키는 오류를 최소화해주는 역할을 합니다.

 어노테이션 사용으로 소스 코드에 메타데이터를 보관할 수 있고, 컴파일 타임의 체크뿐 아니라 어노테이션 API를 사용해 코드 가독성도 높여줍니다.

- @Controller : dispatcher-servlet.xml에서 bean 태그로 정의하는 것과 같음.
- @RequestMapping : 특정 메소드에서 요청되는 URL과 매칭시키는 어노테이션
- @Autowired : 자동으로 의존성 주입하기 위한 어노테이션
- @Service : 비즈니스 로직 처리하는 서비스 클래스에 등록
- @Repository : DAO에 등록

<br><br>

#### Spring JDBC란?

 데이터베이스 테이블과, 자바 객체 사이의 단순한 매핑을 간단한 설정을 통해 처리하는 것

 기존의 JDBC에서는 구현하고 싶은 로직마다 필요한 SQL문이 모두 달랐고, 이에 필요한 Connection, PrepareStatement, ResultSet 등을 생성하고 Exception 처리도 모두 해야하는 번거러움이 존재했습니다.

 Spring에서는 JDBC와 ORM 프레임워크를 직접 지원하기 때문에 따로 작성하지 않아도 모두 다 처리해주는 장점이 있습니다.

<br><br>

#### MyBatis란?

 객체, 데이터베이스, Mapper 자체를 독립적으로 작성하고, DTO에 해당하는 부분과 SQL 실행결과를 매핑해서 사용할 수 있도록 지원함

 기존에는 DAO에 모두 SQL문이 자바 소스상에 위치했으나, MyBatis를 통해 SQL은 XML 설정 파일로 관리합니다.

 설정파일로 분리하면, 수정할 때 설정파일만 건드리면 되므로 유지보수에 매우 좋습니다. 또한 매개변수나 리턴 타입으로 매핑되는 모든 DTO에 관련된 부분도 모두 설정파일에서 작업할 수 있는 장점이 있습니다.

<br><br>
