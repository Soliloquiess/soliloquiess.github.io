---
title: "[Spring] 스프링 핵심 원리 이해"
layout: post
subtitle: Spring
date: "2021-06-06-04:58:53 +0900"
categories: study
tags: Spring
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---

여기서 할건 스프링 안쓰고 순수 자바로 할 거

#### 동작 확인

기본 메인 클래스 실행( CoreApplication.main() )
IntelliJ Gradle 대신에 자바 직접 실행
최근 IntelliJ 버전은 Gradle을 통해서 실행 하는 것이 기본 설정이다. 이렇게 하면 실행속도가 느리다. 다
음과 같이 변경하면 자바로 바로 실행해서 실행속도가 더 빠르다.
Preferences Build, Execution, Deployment Build Tools Gradle
Build and run using: Gradle IntelliJ IDEA
Run tests using: Gradle IntelliJ IDEA

```

비즈니스 요구사항과 설계
회원
회원을 가입하고 조회할 수 있다.
회원은 일반과 VIP 두 가지 등급이 있다.
회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다. (미확정)
주문과 할인 정책
회원은 상품을 주문할 수 있다.
회원 등급에 따라 할인 정책을 적용할 수 있다.
할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용해달라. (나중에 변경 될 수 있
다.)
할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을
미루고 싶다. 최악의 경우 할인을 적용하지 않을 수 도 있다. (미확정)
요구사항을 보면 회원 데이터, 할인 정책 같은 부분은 지금 결정하기 어려운 부분이다. 그렇다고 이런 정책이
결정될 때 까지 개발을 무기한 기다릴 수 도 없다. 우리는 앞에서 배운 객체 지향 설계 방법이 있지 않은가!
인터페이스를 만들고 구현체를 언제든지 갈아끼울 수 있도록 설계하면 된다. 그럼 시작해보자.

```

##### 회원 도메인 설계

회원 도메인 요구사항
회원을 가입하고 조회할 수 있다.
회원은 일반과 VIP 두 가지 등급이 있다.
회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다. (미확정)

![20210606_205130](/assets/20210606_205130.png)

![20210606_205150](/assets/20210606_205150.png)

![20210606_212026](/assets/20210606_212026.png)

화면 단축키 쓸떄 맥이랑 윈도우 헷갈리면 여기 keymap에 가서 보면 옆에 단축키가 뭐인지 나온다.

그리고 중간에 뭐 안되면 alt+enter 눌러보자.


-----

```
package hello.core.member;

import java.util.HashMap;
import java.util.Map;

public class MemoryMemberRepository implements MemberRepository{

    private static Map<Long, Member> store = new HashMap<>();

    @Override
    public void save(Member member) {
        store.put(member.getId(), member);  //저장소에 넣고
    }
    @Override
    public Member findById(Long memberId) {
        return store.get(memberId); //꺼내온다.
    }
}


```

근데 이렇게 테스트 하면 너무 많다. 일일이 다 해야되기 떄문 그래서 Junit5를 사용하게 된다.


```
package hello.core.member;

import org.assertj.core.api.Assertions;
import org.junit.jupiter.api.Test;

public class MemberServiceTest {

    MemberService memberService = new MemberServiceImpl();
    @Test

    void join(){

        //given(이런이런게 주어졌을때)
        Member member = new Member(1L, "memberA", Grade.VIP );



        //when(이럴떄)

        memberService.join(member);
        Member findMember = memberService.findMember(1L);
        //then(이렇게 된다.)
        Assertions.assertThat(member).isEqualTo(findMember);
    }
}



```


이렇게 테스트 코드를 작성하고 멤버가 같으면(찾으면) success를 띄운다.

MemberRepository는 인터페이스 Impl의존하는데 오른쪽 MemoryMemberRepository는 구현체(실제 할당하는거) 의존.


Impl이 둘다 의존. 추상화에도 의존하고 구현체에도 의존하고 있다.



회원 도메인 설계의 문제점
이 코드의 설계상 문제점은 무엇일까요?
다른 저장소로 변경할 때 OCP 원칙을 잘 준수할까요?
DIP를 잘 지키고 있을까요?
의존관계가 인터페이스 뿐만 아니라 구현까지 모두 의존하는 문제점이 있음
주문까지 만들고나서 문제점과 해결 방안을 설명





----------



##### 주문과 할인 도메인 설계
주문과 할인 정책
회원은 상품을 주문할 수 있다.
회원 등급에 따라 할인 정책을 적용할 수 있다.
할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용해달라. (나중에 변경 될 수 있
다.)
할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을
미루고 싶다. 최악의 경우 할인을 적용하지 않을 수 도 있다. (미확정)

![20210606_235940](/assets/20210606_235940.png)

1. 주문 생성: 클라이언트는 주문 서비스에 주문 생성을 요청한다.
2. 회원 조회: 할인을 위해서는 회원 등급이 필요하다. 그래서 주문 서비스는 회원 저장소에서 회원을 조회
한다.
3. 할인 적용: 주문 서비스는 회원 등급에 따른 할인 여부를 할인 정책에 위임한다.
4. 주문 결과 반환: 주문 서비스는 할인 결과를 포함한 주문 결과를 반환한다.
> 참고: 실제로는 주문 데이터를 DB에 저장하겠지만, 예제가 너무 복잡해 질 수 있어서 생략하고, 단순히 주문
결과를 반환한다.


![20210607_000133](/assets/20210607_000133.png)



------------


새로운 할인 정책 개발
새로운 할인 정책을 확장해보자.
악덕 기획자: 서비스 오픈 직전에 할인 정책을 지금처럼 고정 금액 할인이 아니라 좀 더 합리적인 주문 금액
당 할인하는 정률% 할인으로 변경하고 싶어요. 예를 들어서 기존 정책은 VIP가 10000원을 주문하든
20000원을 주문하든 항상 1000원을 할인했는데, 이번에 새로 나온 정책은 10%로 지정해두면 고객이
10000원 주문시 1000원을 할인해주고, 20000원 주문시에 2000원을 할인해주는 거에요!
순진 개발자: 제가 처음부터 고정 금액 할인은 아니라고 했잖아요.
악덕 기획자: 애자일 소프트웨어 개발 선언 몰라요? “계획을 따르기보다 변화에 대응하기를”
순진 개발자: … (하지만 난 유연한 설계가 가능하도록 객체지향 설계 원칙을 준수했지 후후)
> 참고: 애자일 소프트웨어 개발 선언 https://agilemanifesto.org/iso/ko/manifesto.html
순진 개발자가 정말 객체지향 설계 원칙을 잘 준수 했는지 확인해보자. 이번에는 주문한 금액의 %를 할인해
주는 새로운 정률 할인 정책을 추가하자.


![20210607_013052](/assets/20210607_013052.png)


![20210607_014147](/assets/20210607_014147.png)

윈도우에서 ctrl+shift+t로
여기서 Junit5 테스트를 하고 뒤에 test를 붙여준다.


![20210607_021847](/assets/20210607_021847.png)
![20210607_021854](/assets/20210607_021854.png)

인터페이스, 구체적인거도 의존하고 다의존하면 망한거(DIP위반)

잘보면 클라이언트인 OrderServiceImpl 이 DiscountPolicy 인터페이스 뿐만 아니라
FixDiscountPolicy 인 구체 클래스도 함께 의존하고 있다. 실제 코드를 보면 의존하고 있다! DIP 위반

----


정책 변경


![20210607_022430](/assets/20210607_022430.png)


중요!: 그래서 FixDiscountPolicy 를 RateDiscountPolicy 로 변경하는 순간 OrderServiceImpl 의
소스 코드도 함께 변경해야 한다! OCP 위반

기름차에서 전기차로 바꿨다고 라이센스 갱신하지 않지만 이 경우 라이센스를 바꿔야 할 경우가 된거임.




어떻게 문제를 해결할 수 있을까?
클라이언트 코드인 OrderServiceImpl 은 DiscountPolicy 의 인터페이스 뿐만 아니라 구체 클래스도
함께 의존한다.
그래서 구체 클래스를 변경할 때 클라이언트 코드도 함께 변경해야 한다.
DIP 위반 추상에만 의존하도록 변경(인터페이스에만 의존)
DIP를 위반하지 않도록 인터페이스에만 의존하도록 의존관계를 변경하면 된다.
#### 인터페이스에만 의존하도록 설계를 변경하자
