---
title: "[Spring] mvc를 Spring mvc로"
layout: post
subtitle: Spring
date: "2021-06-01-04:58:53 +0900"

categories: study
tags: Spring
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---


![20210602_130416](/assets/20210602_130416.png)

일반 mvc로 구현하면 생산성이 떨어진다. 그래서 Spring mvc를 사용한다.

서블릿도 클래스.

프론트 컨트롤러와 핵심적으로 연결된 핸들러 매핑이란게 있었다.

클라이언트 요청에 대한 pojo를 찾아줌.

pojo들이 마지막으로 프론트 컨트롤러에 view의 경로 요청함.

이 pojo들의 view의 경로를 이탈하게 되면 프론트 컨트롤러는 ViewResolver와 연동되어서 결과 받아옴.

MVC에서 C가 2가지 FrontController+ Pojo로 묶여있었었다.

그리고 pojo가 Model과 연동되고 Model이 jdbc(Mybatis)와 연동되어있었다.


그리고 프론트 컨트롤러는 jsp(view)와 포워딩 했었다.


![20210602_133045](/assets/20210602_133045.png)


maven은 상태 관리 프로그램.
그리고 스프링 프로젝트는 부트가 아니라 legacy파일로 생성한다.(spring mvc project)


스프링은 맨 마지막 이름이 컨텍스트 패스로 등록이 된다.

![20210602_135254](/assets/20210602_135254.png)

맨 마지막 이름으로 등록 이 경우엔 myapp


만들어 질때 스프링 프레임 워크가 네트워크 연결해서 자동으로 만들어진다.

스프링도 mvc로 따는데 m은 아직 없다 v는 샘플로 home.jsp가 있고
c도 homecontroller (pojo)가 있다.


![20210602_140445](/assets/20210602_140445.png)

이런 클래스들이 스프링에선 자동으로 만들어주고 숨어있다.

객체 넘어갈떄 객체 바인딩으로 포워딩 기법으로 넘어간다.

![20210602_143225](/assets/20210602_143225.png)

스프링과 일반 mvc의 차이로
일반 mvc가 pojo의 개수가 많다.


저 부분의 pojo를 어떻게 하나로 만드냐
메서드로 만들어야 되는데

클라이언트에서 membetContent.do라는 메서드 요청 왔을떄 오른쪽 처리

그외에도 각각 메서드 요청 왔을 떄 처리



기존 핸들러 방식은 스트림과 클래스가 매핑이 되어 있었음

그래서 어떤 요청이 오면 어떤 pojo가 오고 처리함.


![20210602_145213](/assets/20210602_145213.png)

일반 mvc에선 각 do 요청이 오면

근데 스프링은 저 검은 글씨처럼 MemberController하나로 처리가 다 가능하다.

![20210602_145833](/assets/20210602_145833.png)

아래부분을 위처럼 바꾸는 걸 머리를 써야한다.

이런 메서드들을 처리해야 여러개의 pojo를 하나의 메서드로 처리가 가능하다.


개별로 했던 기능을 전부 메서드 단위로 만들어줘야한다(컨트롤러를 전부 메서드로 넣어서 하나로 만든다.)

![20210602_151009](/assets/20210602_151009.png)

이렇게 여러 컨트롤러를 하나로 만든다.

이제 이 컨트롤러는 어떠한 요청이 와도 여기서 처리함.

그럼 어떠한 메서드를 처리해야 할지 고민.

그럼 요청이 왔을떄 컨트롤러가 아닌 메서드와 요청하는 법이 없을까?

![20210602_153059](/assets/20210602_153059.png)

그래서 스프링은 그런 방법을 적용시켰다(바로 메서드 가게)

이런 어노테이션 기호가 있으면 핸들러 매핑으로 자동으로 관리해준다.


![20210602_153347](/assets/20210602_153347.png)

내부적으로 이렇게 바뀌게 된다.


----

HandelerMapping, FrontController, ViewResolver는 스프링에서 제공해주는데 이유가 우리가 거의 손댈 일이 없다 수정도 할 일이 거의 없음.


핸들러 매핑에 매핑 걸어주고 우리는 pojo부터 바로 코딩(스프링도 마찬가지 다 정의 되어있음)

나머지는 수정할 일이 없다

수정할 부분을 굳이 찾는다 하면

![20210602_154252](/assets/20210602_154252.png)

이런 부분


![20210602_162625](/assets/20210602_162625.png)

mvnRepository에서 자동으로 네트워크를 통해 Libraries에 설치해준다.

![20210602_163905](/assets/20210602_163905.png)


그리고 gson을 다운받자
이건 자바 오브젝트를 쉽게 json형태로 바꿔주는 라이브러리다.

![20210602_164555](/assets/20210602_164555.png)

아래 부분을 카피해서 dependecies 에 추가한다.

적어주면 자동으로 api가 다운받아진다.

![20210602_164943](/assets/20210602_164943.png)

----



mvc에서 스프링으로 오면서 pojo 줄이고 (한개로 바꿈) 이게 대표적.

그리고 데이터베이스 설정하는 부분이 약간 변동이 된다.

스프링 프레임워크를 만들면 HandelerMapping, FrontController, ViewResolver 이 3개가 없어진게 아니라 메이븐에 만들어진다.

@RequestMapping 어노테이션으로 인해 간단해졌음을 알아두자.

-----


![20210602_171746](/assets/20210602_171746.png)

이 파일은 읽어들여서 xml 내용을 실행

설정파일

서블릿 xml파일은 rootcontext.xml 은

web.xml보면
root context.xml과 servelet-context.xml이 보이는데 각 리스너와 디스패쳐 서블릿이 읽어들임.

COntextLoaderListener와 DispatcherServlet이 각각 순차적으로 1,2번으로 읽어들인다.


커넥션 풀 만드는게 참 중요한 작업.

스프링에서도 디비 연결하는 작업이 있다.

스프링에서 mybatis로 읽어들이는데
스프링과 역할 나눠서 함.

spring과 jdbc 연결하는 거.


![20210602_172419](/assets/20210602_172419.png)

mybatis를 연결하기 위해 이 3가지 파일이 필요하다.

![20210602_172739](/assets/20210602_172739.png)

이런 API를 다운받기 위해 pom.xml에 설정해줘야한다.



![20210602_173430](/assets/20210602_173430.png)

우린 mysql 8이므로 8버전 커넥터를 받아야 한다.

![20210602_173613](/assets/20210602_173613.png)

가면 2개가 있는데 둘다 받아야 된다고 한다.

가서 mvnRepository에서 젤 많은거 받아주자,.

springjdbc도 받아주자.

낮은버전도 된다. 3.1.1 받자

![20210602_174006](/assets/20210602_174006.png)


이건 jdbc 연결해주는 레퍼지토리



![20210602_174336](/assets/20210602_174336.png)

이렇게 나오면 성공

자바에서는 A라는 클래스 만들고 사용하려면 객체 생성해서 쓰는 방법과
xml파일 bean으로 받는다.



클래스 이름만 알면 객체 생성가능한데 이게 리플렉션 기법이다.

![20210602_181913](/assets/20210602_181913.png)


 window 탭으로 가서 File Associations 으로 가서 .xml로 가서 보자.

 


----
