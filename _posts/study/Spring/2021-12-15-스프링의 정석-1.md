---
title: "[Spring] 스프링의 정석-1"
layout: post
subtitle: Spring
date: "2021-12-03-04:58:53 +0900"
categories: study
tags: Spring
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---


![20211223_114843](/assets/20211223_114843.png)

static이 아니면 객체 생성해야된다.
static이면 객체 생성할 필요가 없다.
브라우저와 WAS가 있어야 원격 프로그램을 실행할 수 있다.


![20211223_115206](/assets/20211223_115206.png)


인스턴스 메서드 = 객체 생성 후 호출.

```
public class Hello {
	//2.URL과 메서드를 연결
	@RequestMapping("/hello")
	public static void main() {//static넣어도 되긴 하는데 안넣어도 됨.
		System.out.println("HELLO");
	}
}
```

인스턴스 메서드 호출 가능하다 = 중간에 누군가 객체 생성을 해준다.(톰캣이 내부적으로 객체 생성을 해준다.)



-----


HttpServletRequest의 메서드를


![20211223_135419](/assets/20211223_135419.png)


쿼리스트링 - 값 전달시 사용


![20211223_135719](/assets/20211223_135719.png)

& 표시 이용해서 값을 여러개 보낼 수 있다.


- 클라이언트 : 서비스를 요청하는 어플리케이션

- 서버 : 서비스를 제공하는 어플리케이션

브라우저 이용해서 URL 입력해서 요청시 해당 서버에 있는 톰캣이 받아서 객체에 저장 생성하고 나눠서 저장 그리고 메서드의 매개변수로 저장.

우리가 원하는 대로 저장하고 스프링은 알아서 저장해 둠.


쿼리스트링은 네임밸류로 값들이 붙어있다.

![20211223_203825](/assets/20211223_203825.png)


![20211223_210606](/assets/20211223_210606.png)
1대의 pc에 여러 서버프로그램이 여러개 있다.
이 ip주소로는 구분 안됨 여러개 주소 존재하므로

그떄 구분하는게 포트번호다

Web Server : 웹을 서비스
웹 어플리케이션 서버(WAS):  웹 어플리케이션을 서비스하는 서버


톰캣의 내부 구조

톰캐싱 요청을 하 8080포트로 요청이 간다.
쓰레드 풀에 사용자 요청이 들어간다.
미리 만들어두면 한가한 스레드가 그걸 처리한다.
서비스가 요청 처리하는데 그 안에 커넥터가 있다.
프로토콜 종류에 따라 어떤 프로토콜 처리할게 달라진다.

서버 안에 서비스가 있고 서비스가 엔진(서비스엔진이 있다) 이 있다.

여러개 호스트 있다.
하나의 톰캣 서버에 여러개 톰캣 서버가 있을 수 있다.

![20211223_211818](/assets/20211223_211818.png)
컨텍스트가 웹 어플리케이션이다.

하나하나가 sts 프로젝트에 해당한다.

sts는 서로 영향을 주지 않는 독립적인 곳에서 돌아간다.

그 안에 서블릿이 있다.

서블릿 : 작은 서버 프로그램(서버에서 실행되는 프로그램)
컨트롤러랑 같은 개념이라 보면된다.

서블릿이 같은 컨텍스트 안에서 돌아간다.

정리하면 톰캣 서버 안에 서비스가 있고 그 서비스 처리하는게 엔진이고
그 안에 호스트가 여러개 있을 수 있고, 호스트 안에는 컨텍스트가 여러개 있을 수 있다.

그 안에 있는게 서블릿이고 이 둘중에 eventlist가 컨텍스트 이름, 그 앞이 호스트 이름이다.

----




스레드 풀에 있는 요청을 받아서 엔진에 전달하고 호스트로 가고 호스트에서 컨텍스트로 간다.

dispatcher서블릿이 받아서 메인메서드를 호출한다.

-----

톰캣설치경로
conf server.xml : Tomcat 서버 설정 파일
톰캣설치경로
conf web.xml Tomcat 의 모든 web app 의 공통 설정
웹앱이름
/WEB INF/ web.xml web app 의 개별 설정
[
참고 STS 에서는 프로젝트 src / webapp /WEB INF/ web.xml
IntelliJ
에서는 프로젝트 src / webapp /WEB INF/ web.xml

----
![20211223_214556](/assets/20211223_214556.png)


![20211223_215340](/assets/20211223_215340.png)
그리고 sts에는 web.xml이 두개인데 하나는 공통설정 하나는 개별설정이다.


사실 @ Controller와 @ RequestMapping은 스프링에서만 쓰고 서블릿에서는 @ WebServlet을 사용. 서블릿은 후에 설명


![20211223_220153](/assets/20211223_220153.png)

그리고 위 처럼 url, 매핑 했는데 이게 너무 길고 불편해서 어노테이션 기반으로 바꿨다.

---------


## 프로토콜

서로간의 통신을 위한 약속 , 규칙주고 받을 데이터에 대한 형식을 정의한 것

### HTTP란?

단순하고 읽기 쉽다 . 텍스트 기반의 프로토콜
상태를 유지하지 않는다 .(stateless) 클라이언트 정보를 저장 X

그래서 클라이언트 요청이 들어오면 중복된 건지 모른다.
이걸 보완하기 위해 나온게 쿠키와 세션이다.


---



단순하고 읽기 쉽다 . 텍스트 기반의 프로토콜

상태를 유지하지 않는다 .(stateless) 클라이언트 정보를 저장 X

확장 가능하다 . 커스텀 헤더 (header) 추가 가능


http메서드는 편지와 비슷하다.


![20211223_222725](/assets/20211223_222725.png)

![20211223_223353](/assets/20211223_223353.png)

네트워크 부분을 보면 이렇게 헤더가 나눠진게 보인다

![20211223_225820](/assets/20211223_225820.png)


-------

- 바이너리 파일: 문자 와 숫자 가 저장되어 있는 파일
  파일 데이터를 있는 그대로 읽고 쓴다


- 텍스트 파일: 문자 만 있는 저장되어 있는 파일
숫자를 문자로 변환 후 쓴다



MIME : 텍스트 기반 프로토콜에 바이너리 데이터 전송하기 위해 고안

HTTP 의 Content Type 헤더에 사용 데이터의 타입을 명시


------


### Base64

바이너리
데이터를 텍스트 데이터로 변환할 때 사용
64진법은 '0'~' 9','A'~'Z', a'~'z 모두 64 개 (6 의 문자로 구성)


------------



# SpringMVC

### 1.관심사의 분리 Separation of Concerns


#### OOP 5대 원칙

1. SRP: 단일 책임의 원칙(하나의 메서드는 하나의 책임)

![20211224_000233](/assets/20211224_000233.png)

공통 코드의 분리 - 입력의 분

출력의 분리 - 변하는 것과 변하지 않는


처리하는 곳 = Controller
보여주는 곳 = View
실제 왔다갔다 하는 데이터 = Model

![20211224_002303](/assets/20211224_002303.png)

이게 코드를 분리해서 전달하기 위해 모델이 필요하다

----

Dispatcher서블릿이 입력을 받으면 처리하고 해당 컨트롤러에 요청을 처리한다. 그 결과를 다시 주면 뷰에 전달한다.


![20211224_003012](/assets/20211224_003012.png)

여기서 모델을 컨트롤러에 주면 모델에 결과 저장한다.

뷰에서는 전달받은 걸 응답 만들어서 클라이언트에 전송한다.

이게 단순화 된 MVC다

![20211224_003340](/assets/20211224_003340.png)
![20211224_010900](/assets/20211224_010900.png)

----------

## 서블릿과 JSP(둘은 같은 말)

### 서블릿의 생명주기
![20211225_161649](/assets/20211225_161649.png)

그리고 서블릿은 싱글톤이다. 1개 인스턴스고 재활용한다.

jsp 는 따로 웹 서블릿이든 뭐든 매핑할 필요 없다. 자동으로 매핑되기 때문


![20211225_175456](/assets/20211225_175456.png)

서블릿은 늦은 초기화 (지연된 초기화, lazy init)), 스프링은 빠른 초기화(early-init)


#####jsp 기본객체 : 생성 없이 사용할 수 있는 객체


유효 범위(scope)와 속성(attribute)
![20211225_182234](/assets/20211225_182234.png)

------


## @RequestParam과 @ModelAttribute

###1. @RequestParam

요청의 파라미터를 연결할 매개변수에 붙이는 어노테이션

###2. @ModelAttribute
적용 대상을 Model의 속성으로 자동 추가해주는 어토네이션
반환 타입 또는 컨트롤러 메서드의 매개변수에 적용 가능

###3. @WebDataBinder

![20211225_225408](/assets/20211225_225408.png)


에러와 결과를 BindingResult에 저장


브라우저 통해서 요청값이 객체에 바인딩 될 때 중간역할을 해주는게 데이터 바인더고 크게 2가지로 먼저 타입변환 하고 데이터 검증한다. 그 결과를 바인딩 리절트에 저장하고  컨트롤러에 넘겨줘서 컨트롤러가 그 결과를 본다는거만 알아두자.


src/main/webapp/WEB-INF/spring에서 root-context.xml 은 non-web관련 설정 파일
그 안에 appServlet 안의 servlet-context.xml은 web관련 설정파일.


그리고 servlet-context.xml 안 <resources mapping="/resources/**" location="/resources/" />
 이 경로를 고치면 주소 치는거를 줄일수 있다.(정적 resources경로를 줄일 수 있다.)


--------

## Redirect 와 Forward

### 1. 처리 과정 비교

redirect는 브라우저가 로케이션에서 알려준대로 수동으로 클라이언트가 요청하면 응답이 자동으로 들어온다.(get이건 post건 상관없이 리다이렉트 됨.)

forward는 request 요청하고 response

그냥 요청만 보내면 write.jsp가 처리하는지 다른게 처리하느닞 모름(MVC 기능을 수행)

리다이렉트는 요청 2번, 포워드는 1번이다.
