---
title: "[Backend] JDBC"
layout: post
subtitle: JDBC
date: '2021-03-09 19:45:51 +0900'

categories: class
tags: Backend
# layout: post
# title:  WebFrontEnd
# subtitle:   "시작하기"
# categories: study
# tags: java
comments: true
---

## Web Back-End : Servlet/JSP 연동

서버단에서 실행하는 가장 대표적인 디비를 http프로토콜로 이용하는건 불가능하죠
자바와 디비 프로토콜 연결하는 JDBC 사용


![20210329_092944](/assets/20210329_092944.png)


클라이언트가 서버에 요청.(Request) . 그리고 당연히 요청시 데이터를 가지고 요청하는데 이 떄 데이터를 파라미터라 한다.

그럼 서버에선해당 사이트는 내 접속을 처리할 수 있는 서버가 필요한데 이걸 Web Server 라 한다(다른 말로 http서버라 한다)

html이나 css,js만 인식 가능.

얘들만 가지고 할 수 없는 일 들

RDBMS는 디비 서버라 치면 얘들을 연결시켜야 하는데 중간에 뭔가가 필요하다
그걸 APplication Server 라 하고 우리는 자바 사용

얘가 하는일은 Logic 처리고 일괄적인 비즈니스 로직( 데이터베이스 로직이 됨.)
presetnation 은 화면에 보이는 역할.

톰캣은 웹서버 역할보다 어플리케이션 서버 역할을 한다.
WAS는 이 2개를 합쳐둔 거(Web Server+ Application Server)

톰캣은 이 두가지를 같이 처리할 수 있다.

어플리케이션 서버에서 자바 사용한다 했는데 우리가 해왔던 자바가 아니라 웹에서 수행할 수 있는 자바를 써야한다.

우리가 쓴건 java se(standard edition)

웹이 들어간 건 serverside 프로그램이 되고 그걸 enterprise라고 한다

-> javaEE(Enterprise Edition)
그리고 javaEE에서 서블릿을 사용한다.
서블릿은 웹에서 돌아가는 자바라 보면 된다.

그리고 서블릿으로만 처리하기 방대한데 이걸 해결하기 위해 JSP가 나왔고 사용한다.(서블릿과 문법 비슷)


마지막으로 RDBMS와 연결해주는걸 JDBC라 보면 된다.


--------

![20210329_093514](/assets/20210329_093514.png)

사이트 만들면 실제 사이트는 이클립스에서 실행하지 않으거 내가 만든 서버는 이러이러한거고 이러하다는 걸 설정하는데 그 많은 파일들 중 구분할 수 있게 하는 게 web.xml를 사용.

![20210329_093754](/assets/20210329_093754.png)

근데 3.0 이상부터는 Annotation사용 (ex. @Override)
아무튼 저부분을 꼭 체크해주자.




![20210329_094159](/assets/20210329_094159.png)
서블릿 임플리먼트 하면 5개의 메서드 호출(이건 우리가 하느넥 아닌 톰캣에서 자동으로 하는 거)
destroy는 서버에서 제거될 떄 자원 끊을 때 (톰캣 종료시 생성했던 내용들 제거)

2.는 아직 잘 모르겠다.
3은 서블릿의 정보같은데. 아직 정확한 용도는 잘 모르겠다.

4.init은 destroy와 반대

5.마지막 서비스라는 메서드가 아주 중요

클라이언트가 요청한걸 request, 응답을 response한걸 여기서 service가 다 해준다.

이걸 안 만들면 서비스에 요청처리를 할 수 없다.
위의 4개는 반드시 만들 필요는 없는데, service 메서드는 반드시 만들고 필요하다.

근데 불편해서 GenericServlet 상속받자. 그리고 서비스라는 메서드 오버라이드
![20210329_094551](/assets/20210329_094551.png)

----


흔히 form쓰는데 어떠한 데이터를 서버에 전송하는데 방식이 2가지 있다.
get, post

get은 url로 주소뒤에 ?해서 넘어감. 길이제한과 노출 위험성
post는 바디에 포함되서 길이제한과 노출 위험성이 줄어듬.


![20210329_095042](/assets/20210329_095042.png)

get, post때의 처리방식이 조금씩 다르다.
http전용환경이다

![20210329_095110](/assets/20210329_095110.png)

얘들은 정해져 있어서 제네릭서블릿 쓰기보다

Httpservlet사용
![20210329_095146](/assets/20210329_095146.png)
![20210329_095204](/assets/20210329_095204.png)
근데 얘도 추상클래스네.

추상메서드가 없는 추상클래스는 그 메서드 중들 하나만 골라서 구현해도 된다.(하나 이상만 오버라이드)

![20210329_095252](/assets/20210329_095252.png)
urlmapping은 아까 만든 클래스 이름과 동일.
page 이동은 get,post있는데 일단 get만

![20210329_095433](/assets/20210329_095433_qiaqmtfet.png)
![20210329_095417](/assets/20210329_095417.png)

![20210329_095433](/assets/20210329_095433.png)

![20210329_100146](/assets/20210329_100146.png)
저 상위클래스의 메서드 사용하면 출력 가능하다고 적혀있다.



아까 url 부분을 ssafy로 바꿨는데 저기가 root context.
싸피는 뒤에보니까 HelloSsafy인데 이건 타입 이름.

![20210329_100146](/assets/20210329_100146_z9y5bbs1k.png)

그리고 그 뒤는 매핑한 걸 찾아가는
![20210329_100345](/assets/20210329_100345.png)

![20210329_100345](/assets/20210329_100345_eph8geqlr.png)

get이냐 post에 따라 doGet 이 부분 결정

화면에 저런 내용들 보여주라고 요청.
서블릿 역할 =
    1. 데이터 보내주는 거 얻어내세요.
		2. 그 데이터 보낸거로 일처리 해주세요.(로직처리)
		3. 응답 페이지 만들어내기(html)



----

![20210329_100515](/assets/20210329_100515.png)

url 패턴이 hello ssfay.do라는 걸 찾는다.

![20210329_103913](/assets/20210329_103913.png)


![20210329_104618](/assets/20210329_104618.png)
![20210329_104629](/assets/20210329_104629.png)

![20210329_104636](/assets/20210329_104636.png)
![20210329_104646](/assets/20210329_104646.png)
![20210329_104653](/assets/20210329_104653.png)
![20210329_104701](/assets/20210329_104701.png)

서블릿에는 파라미터 구분하는 게 존재.

![20210329_104701](/assets/20210329_104701_9cf6qtck6.png)

실행하면 주소창에 이렇게 나오는데
http://localhost:8080/backend/singleparam.do?userid=cyh1219&username=%EC%A1%B0%EC%96%91%ED%9B%88&area=0
url 인코더를 브라우저가 알아서 해줬따.


----------

1. data get
2. Logic
3. 응답page


![20210329_111218](/assets/20210329_111218.png)

get, post 방식 바꿔서 실행해보자.

post일때 깨지는데 get, post에서의 한글처리 방식을 꼭 기억하자.

![20210329_111735](/assets/20210329_111735.png)

하나의 파라미터 넘어오면 getParameter, 여러개 넘어오면 getParameterValues 쓴다고 기억해두자.(checkbox이런거 제외하면 다 getParameter)

----

## JSP


![20210329_112110](/assets/20210329_112110.png)
web에서 이 3개는 안 쓸 수가 없다.


![20210329_112212](/assets/20210329_112212.png)


하나 바뀐게 1.서블릿 자바파일로 변환

jsp는 서블릿 변환이 있으니까 jsp 보다 느림. 근데 최초에 한번 할때만 저 작업이 일어나고 그 뒤는 jsp 처럼 서블릿 메서드만 호출된다.

스크립트기반과 컴파일기반 언어(자바) 이런거의 차이는?
코딩시에는 스크립트 언어 따르지만 실행시엔 컴파일 언어 따름. 그러면 두개의 장점만 가져와서 따른다.

post는 jsp는 제일 처음 한번만 서블릿 변환. get,post와는 변환되는 거와 연관성이 없다.

![20210329_113135](/assets/20210329_113135.png)



메서드 영역 선언부

![20210329_112952](/assets/20210329_112952.png)

중요한 건 !로 선언한다는거


![20210329_112807](/assets/20210329_112807.png)

응답페이지 만드는 건 태그 밖에 html태그로 쓰면 됨

Data get, Logic, response 객체같은 걸 쓸 수 있다.

![20210329_113235](/assets/20210329_113235.png)

![20210329_113258](/assets/20210329_113258.png)


jsp는 자바로 변환
이 안에있는 코드가 서블리승로 변환시 포함 시키지 마라.

자바의 주석과 html 주석과 이런거 차이 보자.







------------


서블릿 쓰다보니 불편한 점이 있어서 asp처럼 쉽게 백엔드 구성하기 위해 자바에서도 문법 비슷하게 사용

![20210329_123707](/assets/20210329_123707.png)


![20210329_123917](/assets/20210329_123917.png)

### 서블릿

- 웹 컨테이너에서 실행되며, 동적인 컨텐츠를 생성하기 위한 자바클래스.



서블릿 프로그램

- 장점
1. 플랫폼 독립성
2. 서버 독립성
3. 확장성
4. 개발 용이.

![20210329_124401](/assets/20210329_124401.png)

직접 임포트 안하고 자동 임포트 되긴 하는데 일단 기억은 해두자.

----

클라이언트로 부터 요청 왔을 때 달라는 걸 줘야되는 데 그때 응답

![20210329_132428](/assets/20210329_132428.png)
![20210329_132439](/assets/20210329_132439.png)

맨 위 하얀 줄이 요청줄
Get방식으로 서블릿 달라고 요청.
그 밑으로 body가 들어감.

![20210329_132701](/assets/20210329_132701.png)

파라미터가 어디에 담겨서 가냐.


![20210329_132855](/assets/20210329_132855.png)


--------


![20210329_133001](/assets/20210329_133001.png)

클라이언트가 요청 보내면  리퀘스트와 리스폰스 객체 만듬.(타입은 HttpRequest, HttpResponse), 톰캣이 일단 요청 받음

저 두개를 컨테이너(톰캣)이 만든다.(리퀘스트 톰캣이 받음), 리스폰은 아직 값이 없어서 아무것도 없다. 필요한 정보는 리퀘스트에 넣어놈.

![20210329_133304](/assets/20210329_133304.png)

스레드한테 전달(스레드도 톰캣이 new 해서 만듬) 스레드 하나 만들고 나서 스레드 한 녀석 만들고 얘한테 리퀘스트와 리스폰을 전달. 스레드는 클라이언트 수만큼 만듬(클라이언트가 500개면 스레드도 500개)

![20210329_133346](/assets/20210329_133346.png)

스레드가 서비스 메서드. doget사용해서 실행해서 답 만들고 만든 답을 리스폰에 담고 프린트해서 담은 답을 컨테이너가 담고 마지막 답을 클라이언트에 전달하고 그동안 쓰던 건 없애준다.
그리고 서비스 함수 실행해서 답을 막 만들어냄(response에 답을 담음)

![20210329_133421](/assets/20210329_133421.png)
톰캣 담은거 요청보내고

![20210329_133428](/assets/20210329_133428.png)
리스폰,리퀘스트 담은 스레드 없애고 클라이언트한테 보냄









-----

html,css, js 파일은 세 군데 중 어디에 와야 하나?

![20210329_184310](/assets/20210329_184310.png)


static 한 것들은 다 Ws에 줌.

![20210329_185407](/assets/20210329_185407.png)

현재 http 1.1버전 쓰고 포트번호 8080

![20210329_185713](/assets/20210329_185713.png)

이 부분은 우리 맘대로 수정하면 된다.

컨테이너와 컴포넌트 개념을 알아야 한다.


---


![20210329_190641](/assets/20210329_190641.png)

헬로 서블릿은 주소창에 표기되는 거.

get방식. post는 주소창에서 바로 입력 못함.

---

```
//@WebServlet("/HelloServlet")
//@WebServlet(value = {"/hello","/sub/hello","hello2"})	// 슬래시 다음 hello,sub/hello, hello2 가 오든 뭐가오든 전부 얘가 처리한다는 의미
@WebServlet(value = {"/board","/board/","hello2"})
public class HelloServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

//   
//    public HelloServlet() {
//        super();
//        // TODO Auto-generated constructor stub
//    }


```

Restapi

get으로 board 요청하고 post로 보드요청

일단 url 매핑은 절대 헷갈리지 말자 주소에 클라이언트가 어떤 주소를 치고 들어오느냐에 따라 그 주소에 맞는 적절한 서버 자원을 매칭시키는게 url 매핑이고 이게 아주 중요하다.


![20210329_192149](/assets/20210329_192149.png)

서버를 띄우지 못해서 실행을 할 수 없다.

톰캣 404, 403, 500 보고 이해하고 해결할 줄 알아야 한다.


![20210329_192149](/assets/20210329_192149_tzsxa4aic.png)

![20210329_193512](/assets/20210329_193512.png)

----
기본적으로 웹은 멀티쓰레드 고려해야(다양한 상황 고려해야)
